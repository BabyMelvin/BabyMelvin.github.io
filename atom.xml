<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杭</title>
  <icon>https://www.gravatar.com/avatar/a55812411182009695184e657360cb4f</icon>
  <subtitle>Practice makes perfect!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-02-27T15:10:00.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Melvin</name>
    <email>hang.yasuo@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo introduce</title>
    <link href="http://yoursite.com/2019/02/20/hello-world/"/>
    <id>http://yoursite.com/2019/02/20/hello-world/</id>
    <published>2019-02-20T14:34:09.171Z</published>
    <updated>2016-02-27T15:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Kernel sync and async</title>
    <link href="http://yoursite.com/2018/11/08/Kernel-sync/"/>
    <id>http://yoursite.com/2018/11/08/Kernel-sync/</id>
    <published>2018-11-08T00:47:55.000Z</published>
    <updated>2019-02-20T14:31:34.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-介绍"><a href="#0-介绍" class="headerlink" title="0.介绍"></a>0.介绍</h1><p>kernel有很多的同步和异步机制，做简单整理，力求能够熟练使用。</p><a id="more"></a><h1 id="1-同步机制"><a href="#1-同步机制" class="headerlink" title="1.同步机制"></a>1.同步机制</h1><ul><li><code>并发</code>：多个执行单元同时被执行</li><li><code>竞态</code>:并发的执行单元对共享资源(硬件资源和软件上的全局变量等)的访问导致竞争状态。<br>并发与竞态。</li></ul><p>假设有2个进程试图同时向一个设备的相同位置写入数据，就会造成数据混乱。处理并发常用的技术:<code>加锁</code>或者<code>互斥</code>，即确保在任何时间只有一个执行单元可以操作共享资源。在Linux内核中主要通过<code>semaphore</code>机制和<code>spin_lock</code>机制实现。</p><h2 id="1-1-信号量"><a href="#1-1-信号量" class="headerlink" title="1.1 信号量"></a>1.1 信号量</h2><p>Linux内核信号量在概念和原理上与用户信号量一样的，但是它不能在内核之外使用，<code>它是一种睡眠锁</code>.</p><p>如果有一个任务想要获得已经被占用的信号量时，信号量会将这个<code>进程放入一个等待队列</code>，然后让其睡眠当持有信号量的进程将其释放后，处与等待队列中任务被唤醒，并让其获得信号量。</p><ul><li>信号量在创建时需要<code>设置一个初始值</code>，表示<strong>允许几个任务同时访问该信号量</strong>保护的共享资源。初始值为1就变成互斥锁(Mutex)，即同时只能有一个任务可以访问信号量保护的共享资源。</li><li>当任务访问完被信号量保护的共享资源后，必须释放信号量。释放信号量通常把信号量的值加1实现，如果释放后信号量的值为非正数，表明有任务任务等待当前信号量，因此要唤醒信号量的任务。</li></ul><p>信号量的实现也是与体系结构相关的，定义在<code>&lt;asm/semaphore.h&gt;</code>中，struct semaphore类型用类表示信号量。</p><p>1.定义信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span></span><br></pre></td></tr></table></figure><p>2.初始化信号量</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void sema_init(struct semaphore*sem,int val) 该函数用于初始化信号量设置信号量的初值，它设置信号量sem的值为val;</span><br></pre></td></tr></table></figure><p><strong>互斥锁</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_MUTEX</span><span class="params">(struct semaphore*sem)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数用于初始化一个互斥锁，即它把信号量sem的值设置为1.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_MUTEX_LOCKED</span><span class="params">(struct semaphore*sem)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数也用于初始化一个互斥锁，但它把信号量sem的值设置为0,即一开始就处于已锁状态。</p><p>定义与初始化工作可由如下宏完成： </p><ul><li><code>DECLARE_MUTEX(name)</code>定义一个信号量name，并初始话它的值为1. </li><li><code>DECLARE_MUTEXT_LOCKED(name)</code>定义一个信号量name，但把它的初始值设置为0,即创建时就处于已锁的状态。</li></ul><p>3.获取信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(struct semaphore*sem)</span></span>;</span><br></pre></td></tr></table></figure><p>获取信号量sem,<strong>可能会导致进程睡眠</strong>，<strong>因此不能在中断上下文使用该函数</strong>。 该函数将把sem的值减1:</p><ul><li>如果信号量的sem值为非负，就直接返回.</li><li>否则调用者将被挂起。<strong>直到别的任务释放该信号量才能继续运行</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">down_interruptible</span><span class="params">(struct semaphore*sem)</span></span>;</span><br></pre></td></tr></table></figure><p>获取信号量sem.如果信号量不可用，进程将被置为<code>TASK_INTERRUPTIBLE</code>类型的睡眠状态。该函数返回值来区分正常返回还是被信号中断返回:</p><ul><li>如果返回0，表示获得信号量正常返回</li><li>如果被信号打断，返回<code>-EINTR</code>.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dow_killable</span><span class="params">(struct semaphore*sem)</span></span>;</span><br></pre></td></tr></table></figure><p>获取信号量sem,如果信号量不可用，进程将被设置为<code>TASK_KILLABLE</code>类型的睡眠状态. 注：<code>down()</code>函数已经不建议继续使用。建议使用<code>down_killable()</code>或d<code>own_interruptible()</code>函数。</p><p>4.释放信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(struct semaphore*sem)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数释放信号量sem,即把sem的值加1,如果sem的值为非正数，表明有任务等待该信号量，因此唤醒这些等待者。</p><h2 id="1-2-自旋锁"><a href="#1-2-自旋锁" class="headerlink" title="1.2 自旋锁"></a>1.2 自旋锁</h2><p><strong>自旋锁最多只能被一个可执行单元持有</strong>。自旋锁不会引起调用者睡眠,如果一个执行难线程试图获得一个已经持有的自旋锁，那么线程就会一直进行忙循环，一直等待下去在那里看是否该自旋锁的保持者已经释放了锁，“自旋”就是这个意思。</p><p>1.初始化<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_init(x);</span><br></pre></td></tr></table></figure></p><p>该宏用于初始化自旋锁x，自旋锁在使用前必须先初始化。</p><p>2.获取锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spin_lock(x)</span><br></pre></td></tr></table></figure><p>获取自旋锁lock，如果成功，立即获得锁，并马上返回，否则它将一直自旋在那里，直到该自旋锁的保持者释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spin_trylock(x)</span><br></pre></td></tr></table></figure><p>试图获取自旋锁lock，如果能立即获得锁，并返回真，否则立即返回假。它不会一直等待释放.</p><p>3.释放锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spin_unlock(x)</span><br></pre></td></tr></table></figure><p>释放自旋锁lock,它与<code>spin_lock</code>或<code>spin_trylock</code>配对。<code>锁用完要进行释放</code></p><h2 id="1-3-信号量与自旋锁比较"><a href="#1-3-信号量与自旋锁比较" class="headerlink" title="1.3 信号量与自旋锁比较"></a>1.3 信号量与自旋锁比较</h2><ul><li>信号量可能允许有多个持有者，而自旋锁任何时候只能允许一个持有者.当然也有信号量叫互斥信号量(只能一个持有者)，允许有多个持有者的信号量叫计数信号量</li><li>信号量适合保持较长时间，而自旋锁适合于保持时间非常短的情况，在实际应用中自旋锁控制代码只有几行，而持有自旋锁的时间也不会超过两次上下文切换的时间，因此线程一旦要进行切换，就至少花费出人两次，自旋锁的占用时间如果远远长于两次上下文切换，我们就应该选择信号量。</li></ul><h1 id="2-异步"><a href="#2-异步" class="headerlink" title="2.异步"></a>2.异步</h1><p>主要使用队列来形成一种类似”缓冲”，从而产生异步。这个缓冲可以是数据，可以是”函数”。</p><h2 id="2-1-等待队列wait-queue"><a href="#2-1-等待队列wait-queue" class="headerlink" title="2.1 等待队列wait_queue"></a>2.1 等待队列wait_queue</h2><p>可以使用等待队列来实现进程阻塞，在阻塞进程时，将进程放入等待队列，当唤醒进程时，从等待队列中取出进程。</p><p>1.定义和初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wait_queue_head_t</span> my_queue;</span><br><span class="line">init_waitqueue_head(&amp;my_queue);</span><br></pre></td></tr></table></figure><p>可以使用宏来完成，定义和初始化过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_WAIT_QUEUE_HEAD(my_queue);</span><br></pre></td></tr></table></figure><p>2.睡眠</p><p><strong>a.有条件睡眠</strong></p><ul><li><code>wait_event(queue,condition)</code>:当condition为真时，立即返回；否则让进程进入<code>TASK_UNINTERRUPTIBLE</code>模式的睡眠，并挂在queue参数所指定的等待队列上。</li><li><code>wait_event_interruptible(queue,conditon)</code>:当condition为真时，立即返回；否则让进程<code>TASK_INTERRUPTIBLE</code>的睡眠，并挂起queue参数所指定的等待队列</li><li><code>int wait_event_killable(wait_queue_t queue,condition)</code>:当condition为真时，立即返回；否则让进程进入<code>TASK_KILLABLE</code>的睡眠，并挂在queue参数所指定的等待队列上。</li></ul><p><strong>b.无条件睡眠(老版本，建议不再使用)</strong></p><ul><li><code>sleep_on(wait_queue_head_t *q)</code>:让进程进入不可中断的睡眠，并把它放入等待队列q.</li><li><code>interruptible_sleep_on(wait_queue_head_t *q)</code>:让进程进入可中断的睡眠，并把它放入等待队列q。</li></ul><p>3.唤醒</p><ul><li><code>wake_up(wait_queue_t *q)</code>:从等待队列q中唤醒状态为<code>TASK_UNINTERRUPTIBLE</code>,<code>TASK_INTERRUPTIBLE</code>,<code>TASK_KILLABLE</code>的所有进程。</li><li><code>wake_up_interruptible(wait_queue_t*q)</code>:从等待队列q中唤醒状态为<code>TASK_INTERRUPTIBLE</code>的进程。</li></ul><h2 id="2-2completion"><a href="#2-2completion" class="headerlink" title="2.2completion"></a>2.2completion</h2><p>内核编程中常见的一种模式是，<strong>在当前线程之外初始化某个活动</strong>，<strong>然后等待该活动的结束</strong>。内核中提供了另外一种机制——completion接口。<strong>Completion是一种轻量级的机制</strong>，他允许一个线程告诉另一个线程某个工作已经完成。实现基于等待队列。</p><p>1.结构与初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> done;     <span class="comment">/*用于同步的原子量*/</span></span><br><span class="line"><span class="keyword">wait_queue_head_t</span> wait;<span class="comment">/*等待事件队列*/</span></span><br><span class="line">&#125; x;</span><br></pre></td></tr></table></figure><p>函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_completion</span><span class="params">(x)</span></span>;</span><br></pre></td></tr></table></figure></p><p>宏实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_COMPLETION(work)</span><br></pre></td></tr></table></figure><p>2.等待</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wait_for_completion(work);</span><br></pre></td></tr></table></figure><p>3.完成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">completion(work);</span><br></pre></td></tr></table></figure><h2 id="2-3-工作队列work-struct"><a href="#2-3-工作队列work-struct" class="headerlink" title="2.3 工作队列work_struct"></a>2.3 工作队列work_struct</h2><p>工作队列一般用来做滞后的工作，比如在中断里面要做很多事，但是比较耗时，<strong>这时就可以把耗时的工作放到工作队列</strong>。说白了就是<code>系统延时调度</code>的一个自定义函数。</p><p>工作队列的使用分两种情况:</p><ul><li><code>利用系统</code>共享的工作队列来添加自己的工作，这种情况处理函数<code>不能消耗太多时间</code>,这样会影响共享队列中其他任务的处理;</li><li>另外一种是创建自己的工作队列并添加工作。</li></ul><h3 id="2-3-1-使用系统"><a href="#2-3-1-使用系统" class="headerlink" title="2.3.1 使用系统"></a>2.3.1 使用系统</h3><p>1.声明工作函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>2.创建一个工作结构体变量，并将处理函数和参数的入口地址赋给这个工作结构体变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译时创建名为my_work的结构体变量</span></span><br><span class="line"><span class="comment">//并把 函数入口地址 和 参数地址 赋给它;</span></span><br><span class="line">DECLARE_WORK(my_work,my_func,&amp;data);</span><br></pre></td></tr></table></figure><p>如果不想要在编译时就用<code>DECLARE_WORK()</code>创建并初始化工作结构体变量，也可以在程序运行时再用<code>INIT_WORK()</code>创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个名为my_work的结构体变量，创建后才能使用INIT_WORK()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">my_work</span>;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化已经创建的my_work，其实就是往这个结构体变量中添加处理函数的入口地址和data的地址</span></span><br><span class="line"><span class="comment">// 通常在驱动的open函数中完成</span></span><br><span class="line">INIT_WORK(&amp;my_work,my_func,&amp;data);</span><br></pre></td></tr></table></figure><p>3.将工作结构体变量添加入系统的共享工作队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schedule_work(&amp;my_work); <span class="comment">//添加入队列的工作完成后会自动从队列中删除</span></span><br></pre></td></tr></table></figure><h3 id="2-3-2-创建自己的工作队列来添加工作"><a href="#2-3-2-创建自己的工作队列来添加工作" class="headerlink" title="2.3.2 创建自己的工作队列来添加工作"></a>2.3.2 创建自己的工作队列来添加工作</h3><p>1.声明工作处理函数和一个指向工作队列的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">p_queue</span>;</span></span><br></pre></td></tr></table></figure><p>2.创建自己的工作队列和工作结构体变量(通常在<code>open</code>函数中完成)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个名为my_queue的工作队列并把工作队列的入口地址赋给声明的指针</span></span><br><span class="line">p_queue=create_workqueue(<span class="string">"my_queue"</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个工作结构体变量并初始化，和第一种情况的方法一样</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">my_work</span>;</span></span><br><span class="line">INIT_WORK(&amp;my_work, my_func, &amp;data);</span><br></pre></td></tr></table></figure><p>3.将工作添加入自己创建的工作队列等待执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作用与schedule_work()类似</span></span><br><span class="line"><span class="comment">//不同的是将工作添加入p_queue指针指向的工作队列而不是系统共享的工作队列</span></span><br><span class="line">queue_work(p_queue, &amp;my_work);</span><br></pre></td></tr></table></figure><p>4.第四步：删除自己的工作队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">destroy_workqueue(p_queue); <span class="comment">//一般是在close函数中删除</span></span><br></pre></td></tr></table></figure><h2 id="2-4-tasklet"><a href="#2-4-tasklet" class="headerlink" title="2.4 tasklet"></a>2.4 tasklet</h2><p>小进程，主要用于执行一些小任务，对这些任务使用全功能进程比较浪费。也称为中断下半部，<strong>在处理软中断时执行</strong>。</p><p>1.初始化和结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span>* <span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> state;</span><br><span class="line"><span class="keyword">atomic_t</span> count;</span><br><span class="line"><span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>函数：<code>tasklet_init(t,func,data)</code></p><p>宏：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_TASKLET(name,func,data);<span class="comment">//tasklet is scheduled for executation</span></span><br><span class="line"><span class="comment">//两种状态：TASKLET_STATE_SCHED</span></span><br><span class="line"><span class="comment">//TASKLET_STATE_RUN//tasklet is running(SMP only)</span></span><br></pre></td></tr></table></figure></p><p>2.执行:<code>tasklet_schedule(t)</code><br>3.销毁</p><p>函数：<br>宏：</p><h2 id="2-5-工作队列和tasklet区别"><a href="#2-5-工作队列和tasklet区别" class="headerlink" title="2.5 工作队列和tasklet区别"></a>2.5 工作队列和tasklet区别</h2><p>Linux2.6内核使用了不少工作队列来处理任务，他在使用上和tasklet最大的不同是<strong>工作队列的函数可以使用休眠</strong>，而tasklet的函数是不允许使用休眠的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-介绍&quot;&gt;&lt;a href=&quot;#0-介绍&quot; class=&quot;headerlink&quot; title=&quot;0.介绍&quot;&gt;&lt;/a&gt;0.介绍&lt;/h1&gt;&lt;p&gt;kernel有很多的同步和异步机制，做简单整理，力求能够熟练使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Kernel" scheme="http://yoursite.com/categories/Kernel/"/>
    
    
      <category term="KernelAPI" scheme="http://yoursite.com/tags/KernelAPI/"/>
    
  </entry>
  
  <entry>
    <title>WMS</title>
    <link href="http://yoursite.com/2018/09/24/WMS/"/>
    <id>http://yoursite.com/2018/09/24/WMS/</id>
    <published>2018-09-24T15:24:06.000Z</published>
    <updated>2019-02-02T11:21:31.745Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>获取调用包名</title>
    <link href="http://yoursite.com/2018/09/07/%E8%8E%B7%E5%8F%96%E8%B0%83%E7%94%A8%E5%8C%85%E5%90%8D/"/>
    <id>http://yoursite.com/2018/09/07/获取调用包名/</id>
    <published>2018-09-06T20:23:40.000Z</published>
    <updated>2019-02-02T11:21:31.752Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>权限检查</title>
    <link href="http://yoursite.com/2018/09/07/%E6%9D%83%E9%99%90%E6%A3%80%E6%9F%A5/"/>
    <id>http://yoursite.com/2018/09/07/权限检查/</id>
    <published>2018-09-06T20:22:48.000Z</published>
    <updated>2019-02-02T11:21:31.752Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常见的Intent</title>
    <link href="http://yoursite.com/2018/08/17/%E5%B8%B8%E8%A7%81%E7%9A%84Intent/"/>
    <id>http://yoursite.com/2018/08/17/常见的Intent/</id>
    <published>2018-08-17T13:10:17.000Z</published>
    <updated>2019-02-02T11:21:31.752Z</updated>
    
    <content type="html"><![CDATA[<p>Intent启动另外一个应用的activity，如Intent和Intent filter使用说明中。许多系统应用已经设置了内部的隐式Intent。</p><a id="more"></a><h1 id="1-闹钟-alarm-clock"><a href="#1-闹钟-alarm-clock" class="headerlink" title="1.闹钟(alarm clock)"></a>1.闹钟(alarm clock)</h1><ul><li>action：<code>ACTION_SET_ALARM</code></li><li>extras:<ul><li><code>EXTRA_HOUR</code>:闹钟小时数</li><li><code>EXTRA_MINUTES</code>:闹钟分钟数</li><li><code>EXTRA_MESSAGE</code>:闹钟的说明信息</li><li><code>EXTRA_DAYS</code>：每周哪几天重复Calender中的数据，组成一个ArrayList.</li><li><code>EXTRA_RINGTONE</code>:提供铃声的URI，或者没有铃声<code>VALUE_RINGTONE_SILENT</code></li><li><code>EXTRA_VIBRATE</code>:是否振动，布尔值。</li><li><code>EXTRA_SKIP_UI</code>:是否跳过响应app的UI。</li></ul></li></ul><p><strong>使用说明</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAlarm</span><span class="params">(String message,<span class="keyword">int</span> hour,<span class="keyword">int</span> minutes)</span></span>&#123;</span><br><span class="line">Intent intent=<span class="keyword">new</span> Intent(AlarmClock.ACTION_SET_ALARM)</span><br><span class="line">.putExtra(AlarmClock.EXTRA_MESSAGE,message)</span><br><span class="line">.putExtra(AlarmClock.EXTRA_HOUR,hour)</span><br><span class="line">.putExtra(AlarmClock.EXTRA_MINUTES,minutes);</span><br><span class="line"><span class="keyword">if</span>(intent.resolveActivity(getPackageManager())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">startActivity(intent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要声明权限</span></span><br><span class="line">&lt;uses-permission android:name=<span class="string">"com.android.alarm.permission.SET_ALARM"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>响应app的xml过滤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity ...&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.SET_ALARM&quot; /&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><h1 id="2-创建计时器-timer"><a href="#2-创建计时器-timer" class="headerlink" title="2.创建计时器(timer)"></a>2.创建计时器(timer)</h1><ul><li>action:<code>ACTION_SET_TIMER</code></li><li>extras:<ul><li><code>EXTRA_LENGTH</code>:计时器秒数</li><li><code>EXTRA_MESSAGE</code>:计时器定制消息</li><li><code>EXTRA_SKIP_UI</code>:是否显示目标UI</li></ul></li></ul><p><strong>使用说明</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void startTimer(String message, int seconds) &#123;</span><br><span class="line">    Intent intent = new Intent(AlarmClock.ACTION_SET_TIMER)</span><br><span class="line">            .putExtra(AlarmClock.EXTRA_MESSAGE, message)</span><br><span class="line">            .putExtra(AlarmClock.EXTRA_LENGTH, seconds)</span><br><span class="line">            .putExtra(AlarmClock.EXTRA_SKIP_UI, true);</span><br><span class="line">    if (intent.resolveActivity(getPackageManager()) != null) &#123;</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//权限</span><br><span class="line">&lt;uses-permission android:name=&quot;com.android.alarm.permission.SET_ALARM&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p><strong>响应app</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SET_TIMER"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="3-显示所有闹钟"><a href="#3-显示所有闹钟" class="headerlink" title="3.显示所有闹钟"></a>3.显示所有闹钟</h1><p>4.4之后添加。 这个需要闹钟功能的app同时提供完成。</p><ul><li>action:<code>ACTION_SHOW_ALARMS</code></li></ul><p><strong>响应app</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity ...&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.SHOW_ALARMS&quot; /&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><h1 id="4-日历（calender）"><a href="#4-日历（calender）" class="headerlink" title="4.日历（calender）"></a>4.日历（calender）</h1><p>添加日历时间既要action，也要提供URI。</p><ul><li>action：<code>ACTION_INSERT</code></li><li>data uri:<code>Events.CONTENT_URI</code></li><li>mimetype:<code>vnd.android.cursor.dir/event</code></li><li>extras:<ul><li><code>EXTRA_EVENT_ALL_DAY</code>:是否是全天事件</li><li><code>EXTRA_EVENT_BEGIN_TIME</code>：事件开始的时间(1970以后毫秒数)</li><li><code>EXTRA_EVENT_END_TIME</code>:事件结束的时间(1970以后毫秒数)</li><li><code>TITLE</code>:事件标题</li><li><code>DESCRIPTION</code>:事件描述</li><li><code>EVENT_LOCATION</code>:事件地点</li><li><code>EVENT_EMAIL</code>:逗号分开邮箱地址</li></ul></li></ul><p><strong>使用说明</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void addEvent(String title, String location, long begin, long end) &#123;</span><br><span class="line">    Intent intent = new Intent(Intent.ACTION_INSERT)</span><br><span class="line">            .setData(Events.CONTENT_URI)</span><br><span class="line">            .putExtra(Events.TITLE, title)</span><br><span class="line">            .putExtra(Events.EVENT_LOCATION, location)</span><br><span class="line">            .putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, begin)</span><br><span class="line">            .putExtra(CalendarContract.EXTRA_EVENT_END_TIME, end);</span><br><span class="line">    if (intent.resolveActivity(getPackageManager()) != null) &#123;</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>响应app</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity ...&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.INSERT&quot; /&gt;</span><br><span class="line">        &lt;data android:mimeType=&quot;vnd.android.cursor.dir/event&quot; /&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><h1 id="5-相机"><a href="#5-相机" class="headerlink" title="5.相机"></a>5.相机</h1><h2 id="5-1-捕获图片或录像并返回"><a href="#5-1-捕获图片或录像并返回" class="headerlink" title="5.1 捕获图片或录像并返回"></a>5.1 捕获图片或录像并返回</h2><ul><li><p>action:</p><ul><li><code>ACTION_IMAGE_CAPTURE</code>:捕获图片</li><li><code>ACTION_VIDEO_CAPTURE</code>:捕获视频</li></ul></li><li><p>extras：</p><ul><li><code>EXTRA_OUTPUT</code>:返回内容的保存URI。</li></ul></li></ul><p>当相机应用成功返回到你自己的Activity(<code>onActivityResult()</code>回调)，就可以在<code>EXTRA_OUPUT</code>路径中找到返回内容。</p><p><strong>使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static final int REQUEST_IMAGE_CAPTURE=1;</span><br><span class="line">static final Uri mLocationForPhotos;</span><br><span class="line">public void capturePhoto(String targetFilename)&#123;</span><br><span class="line">Intent intent=new Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">intent.putExtra(MediaStore.EXTRA_OUTPUT,Uri.withAppendedPath(mLocaitonForPhotos,targetFilename));</span><br><span class="line">if(intent.resolveActivity(getPackageManager()) != null)&#123;</span><br><span class="line">startActivityForResult(intent, REQUEST_IMAGE_CAPTURE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">    if (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == RESULT_OK) &#123;</span><br><span class="line">        Bitmap thumbnail = data.getParcelable(&quot;data&quot;);</span><br><span class="line">        // Do other work with full size photo saved in mLocationForPhotos</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>响应的app</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity ...&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.media.action.IMAGE_CAPTURE&quot; /&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>响应的app处理intent，首先检查<code>EXTRA_OUTPUT</code>,并且调用<code>setResult()</code>包含缩略图extra的key是<strong>data</strong><br>样例：</p><ul><li><a href="https://developer.android.com/training/camera/photobasics" target="_blank" rel="noopener">take photos</a></li><li><a href="https://developer.android.com/training/camera/videobasics" target="_blank" rel="noopener">record videos</a></li></ul><h2 id="5-2-静态图片启动相机"><a href="#5-2-静态图片启动相机" class="headerlink" title="5.2 静态图片启动相机"></a>5.2 静态图片启动相机</h2><ul><li>aciton:<code>INTENT_ACTION_IMAGE_CAMERA</code></li></ul><p><strong>使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void capturePhoto() &#123;</span><br><span class="line">    Intent intent = new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA);</span><br><span class="line">    if (intent.resolveActivity(getPackageManager()) != null) &#123;</span><br><span class="line">        startActivityForResult(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>响应app</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity ...&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.media.action.STILL_IMAGE_CAMERA&quot; /&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><h2 id="5-3-用视频模式启动相机"><a href="#5-3-用视频模式启动相机" class="headerlink" title="5.3 用视频模式启动相机"></a>5.3 用视频模式启动相机</h2><ul><li>action:<code>INTENT_ACTION_VIDEO_CAMERA</code></li></ul><p><strong>使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void capturePhoto() &#123;</span><br><span class="line">    Intent intent = new Intent(MediaStore.INTENT_ACTION_VIDEO_CAMERA);</span><br><span class="line">    if (intent.resolveActivity(getPackageManager()) != null) &#123;</span><br><span class="line">        startActivityForResult(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity ...&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.media.action.VIDEO_CAMERA&quot; /&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><h1 id="6-联系人"><a href="#6-联系人" class="headerlink" title="6 联系人"></a>6 联系人</h1><h2 id="6-1-选择一个联系人"><a href="#6-1-选择一个联系人" class="headerlink" title="6.1 选择一个联系人"></a>6.1 选择一个联系人</h2><p>通过<code>onActivityResult()</code>返回内容(URI).如果没有提供<code>READ_CONTENT</code>权限，响应app提供临时权限。</p><ul><li>action：<code>ACTION_PICK</code></li><li>mime type:<code>Contacts.CONTENT_TYPE</code></li></ul><p><strong>使用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static final int REQUEST_SELECT_CONTACT = 1;</span><br><span class="line"></span><br><span class="line">public void selectContact() &#123;</span><br><span class="line">    Intent intent = new Intent(Intent.ACTION_PICK);</span><br><span class="line">    intent.setType(ContactsContract.Contacts.CONTENT_TYPE);</span><br><span class="line">    if (intent.resolveActivity(getPackageManager()) != null) &#123;</span><br><span class="line">        startActivityForResult(intent, REQUEST_SELECT_CONTACT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">    if (requestCode == REQUEST_SELECT_CONTACT &amp;&amp; resultCode == RESULT_OK) &#123;</span><br><span class="line">        Uri contactUri = data.getData();</span><br><span class="line">        // Do something with the selected contact at contactUri</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>见 <a href="https://developer.android.com/training/contacts-provider/retrieve-details" target="_blank" rel="noopener">Retrieve details for a contact</a></p><h2 id="6-2-选择特定联系人"><a href="#6-2-选择特定联系人" class="headerlink" title="6.2 选择特定联系人"></a>6.2 选择特定联系人</h2><p>特定联系人如号码，姓名等。</p><ul><li>action:<code>ACTION_PICK</code></li><li>mime type:<ul><li><code>CommonDataKinds.Phone.CONTENT_TYPE</code>:号码选择联系人</li><li><code>CommonDataKinds.Email.CONTENT_TYPE</code>:邮箱地址选择联系人</li><li><code>CommonDataKinds.StructuredPostal.CONTENT_TYPE</code>:邮寄地址选择联系人</li></ul></li></ul><p><strong>使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static final int REQUEST_SELECT_PHONE_NUMBER=1;</span><br><span class="line">public void selectContact()&#123;</span><br><span class="line">//start an activity for the user to pick a phone number from contacts</span><br><span class="line">Intent intent=new Intent(Intent.ACTION_PICK);</span><br><span class="line">intent.setType(CommonDataKinds.Phone.CONTENT_TYPE);</span><br><span class="line">if(intent.resolveActivity(getPackageManager())!=null)&#123;</span><br><span class="line">startActivityForResult(intent,REQUEST_SELECT_PHONE_NUMBER);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onActivityResult(int requestCode,int resultCode,Intent data)&#123;</span><br><span class="line">//get the URI and query the content provider for the phone number</span><br><span class="line">Uri contactUri=data.getData();</span><br><span class="line">String[] projection=new String[]&#123;CommonDataKinds.Phone.NUMBER&#125;;</span><br><span class="line">Cursor cursor=getContentResolver().query(contactUri,projection,null,null,null);</span><br><span class="line">//if the cursor returned is valid,get the phone number</span><br><span class="line">if(cursor!=null &amp;&amp; cursor.moveToFirst())&#123;</span><br><span class="line">int numberIndex=cursor.getColumnIndex(CommonDataKinds.Phone.NUMBER);</span><br><span class="line">String number=cursor.getString(numberIndex);</span><br><span class="line">//do something with the phone number</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3显示contact"><a href="#6-3显示contact" class="headerlink" title="6.3显示contact"></a>6.3显示contact</h2><p>两种方式获得contact的URI</p><ul><li>使用<code>ACTION_PICK</code>,前面说的那样(不需要app权限)</li><li><p>直接获得联系人所有列表（需要app<code>READ_CONTACTS</code>权限）。<a href="https://developer.android.com/training/contacts-provider/retrieve-names" target="_blank" rel="noopener">Retrieve a list of contacts</a></p></li><li><p>action:<code>ACTION_VIEW</code></p></li><li>uri scheme:<code>content:&lt;URI&gt;</code></li></ul><p><strong>使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void viewContact(Uri contactUri) &#123;</span><br><span class="line">    Intent intent = new Intent(Intent.ACTION_VIEW, contactUri);</span><br><span class="line">    if (intent.resolveActivity(getPackageManager()) != null) &#123;</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-4编辑已有联系人"><a href="#6-4编辑已有联系人" class="headerlink" title="6.4编辑已有联系人"></a>6.4编辑已有联系人</h2><ul><li>action:<code>ACTION_EDIT</code></li><li>URI scheme:<code>content:&lt;URI&gt;</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void editContact(Uri contactUri, String email) &#123;</span><br><span class="line">    Intent intent = new Intent(Intent.ACTION_EDIT);</span><br><span class="line">    intent.setData(contactUri);</span><br><span class="line">    intent.putExtra(Intents.Insert.EMAIL, email);</span><br><span class="line">    if (intent.resolveActivity(getPackageManager()) != null) &#123;</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>样例：<a href="https://developer.android.com/training/contacts-provider/modify-data" target="_blank" rel="noopener">Modify contacts using intents</a></p><h2 id="6-5插入联系人"><a href="#6-5插入联系人" class="headerlink" title="6.5插入联系人"></a>6.5插入联系人</h2><ul><li>action:<code>ACTION_INSERT</code></li><li>mime type:<code>Contacts.CONTENT_TYPE</code></li></ul><p><strong>使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void insertContact(String name, String email) &#123;</span><br><span class="line">    Intent intent = new Intent(Intent.ACTION_INSERT);</span><br><span class="line">    intent.setType(Contacts.CONTENT_TYPE);</span><br><span class="line">    intent.putExtra(Intents.Insert.NAME, name);</span><br><span class="line">    intent.putExtra(Intents.Insert.EMAIL, email);</span><br><span class="line">    if (intent.resolveActivity(getPackageManager()) != null) &#123;</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-邮件"><a href="#7-邮件" class="headerlink" title="7.邮件"></a>7.邮件</h1><p>编写邮件很多action，由是都需要附件和一些详细信息决定，如接受者，主题等。</p><ul><li><p>action:</p><ul><li><code>ACTION_SENDTO</code>:没有附件</li><li><code>ACTION_SEND</code>:一个附件</li><li><code>ACTION_SEND_MULTIPLE</code>:多个附件</li></ul></li><li><p>mime type:</p><ul><li><code>text/plain</code></li><li><code>*/*</code></li></ul></li><li><p>extras:</p><ul><li><code>Intent.EXTRA_EMAIL</code>:所有接受人的地址</li><li><code>Intent.EXTRA_CC</code>:所有CC接受者</li><li><code>Intent.EXTRA_BCC</code>:所有BCC接受者</li><li><code>Intent.EXTRA_SUBJECT</code>:邮件主题</li><li><code>Intent.EXTRA_TEXT</code>:邮件内容</li><li><code>Intent.EXTRA_STREAM</code>:附件Uri，如果是多个附件，要提供邮件数组。</li></ul></li></ul><p><strong>使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void composeEmail(String[] addresses, String subject, Uri attachment) &#123;</span><br><span class="line">    Intent intent = new Intent(Intent.ACTION_SEND);</span><br><span class="line">    intent.setType(&quot;*/*&quot;);</span><br><span class="line">    intent.putExtra(Intent.EXTRA_EMAIL, addresses);</span><br><span class="line">    intent.putExtra(Intent.EXTRA_SUBJECT, subject);</span><br><span class="line">    intent.putExtra(Intent.EXTRA_STREAM, attachment);</span><br><span class="line">    if (intent.resolveActivity(getPackageManager()) != null) &#123;</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果保证邮件是被email应用，而不是社交应用使用。使用<code>ACTION_SENDTO</code>,包含数组格式(scheme)<code>mailto:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void composeEmail(String[] addresses, String subject) &#123;</span><br><span class="line">    Intent intent = new Intent(Intent.ACTION_SENDTO);</span><br><span class="line">    intent.setData(Uri.parse(&quot;mailto:&quot;)); // only email apps should handle this</span><br><span class="line">    intent.putExtra(Intent.EXTRA_EMAIL, addresses);</span><br><span class="line">    intent.putExtra(Intent.EXTRA_SUBJECT, subject);</span><br><span class="line">    if (intent.resolveActivity(getPackageManager()) != null) &#123;</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>响应过滤</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:type</span>=<span class="string">"*/*"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SENDTO"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"mailto"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="8-文件存储"><a href="#8-文件存储" class="headerlink" title="8.文件存储"></a>8.文件存储</h1><h2 id="8-1-获得指定类型的文件"><a href="#8-1-获得指定类型的文件" class="headerlink" title="8.1 获得指定类型的文件"></a>8.1 获得指定类型的文件</h2><p>使用<code>ACTION_GET_CONTENT</code>和特定MIME类型来获得用户选择的文件，并给app返回一个引用。<strong>返回的应用是和当前activity的声明周期同步的</strong>。要之后使用，自己要进行备份。</p><p>在<code>onActivityResult()</code>返回指向文件的返回的Uri可以是任意类型.Uri，如<code>http:</code>,<code>file:</code>,<code>content:</code>。如果限制只是来至content provider(<code>content:</code>)通过<code>openFileDescriptor()</code>获得，应该在intent中添加<code>CATEGORY_OPENABLE</code>.</p><p>4.3以上允许选择多个文件<code>EXTRA_ALLOW_MULTIPLE</code>.可以通过<code>getClipData()</code>来获得多个文件内容。</p><ul><li>action:<code>ACTION_GET_CONTENT</code></li><li>mime type:和用户选择文件类型相对应</li><li><p>extras:</p><ul><li><code>EXTRA_ALLOW_MULTIPLE</code>:是否能够同时选择多个文件。</li><li><code>EXTRA_LOCAL_ONLY</code>:只是本地文件</li></ul></li><li><p>category(可选的)</p><ul><li><code>CATEGORY_OPENABLE</code>:返回openable文件通过<code>openFileDescriptor()</code>来进行表示。</li></ul></li></ul><p><strong>获得一个图片</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static final int REQUEST_IMAGE_GET=1;</span><br><span class="line">public void selectImage()&#123;</span><br><span class="line">Intent intent=new Intent(Intent.ACTION_GET_CONTENT);</span><br><span class="line">intent.setType(&quot;image/*&quot;);</span><br><span class="line">if(intent.resolveActivity(getPackageManager())!=null)&#123;</span><br><span class="line">startActivityForResult(intent,REQUEST_IMAGE_GET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onActivityResult(int requestCode,int resultCode,Intent data)&#123;</span><br><span class="line">if(requestCode == REQUEST_IMAGE_GET &amp;&amp; resultCode== RESULT_OK)&#123;</span><br><span class="line">Bitmap thumbnail =data.getParcelable(&quot;data&quot;);</span><br><span class="line">Uri fullPotoUri=data.getData();</span><br><span class="line"></span><br><span class="line">//do work with photo saved at fullPhotoUri</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>响应返回一个图片的过滤</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity&gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">&lt;action android:name=&quot;android.intent.action.GET_CONTENT&quot;/&gt;</span><br><span class="line">&lt;data android:type=&quot;image/*&quot;/&gt;</span><br><span class="line">&lt;!--The OPENABLE category declares that the returned file is accessible</span><br><span class="line">             from a content provider that supports OpenableColumns</span><br><span class="line">             and ContentResolver.openFileDescriptor()--&gt;</span><br><span class="line">&lt;category android:name=&quot;android.intent.category.OPENABLE&quot;/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><h2 id="8-2-打开特定类型的文件"><a href="#8-2-打开特定类型的文件" class="headerlink" title="8.2 打开特定类型的文件"></a>8.2 打开特定类型的文件</h2><p><code>ACTION_GET_CONTENT</code>是使用文件内容的副本导入到自己的app。4.4以后可以使用别的app来打开和创建文件，并且由其他应用来管理。使用<code>ACTION_OPEN_DOCUMENT</code>和<code>ACTION_CREATE_DOCUMENT</code>.</p><ul><li>action:<code>ACTION_OPEN_DOCUMENT</code>和<code>ACTION_CREATE_DOCUMENT</code></li><li>extras:<ul><li><code>EXTRA_MIME_TYPES</code>:和文件类型对应的MIME 类型。但是用这个必须初始MIME类型<code>setType()</code>值为<code>*/*</code>.</li><li><code>EXTRA_ALLOW_MUTIPLE</code>:是否允许同时选择多个文件</li><li><code>EXTRA_TITLE</code>:针对<code>ACTION_CREATE_DOCUMENT</code>具体化新建文件的名称。</li><li><code>EXTRA_LOCAL_ONLY</code>:是否选择本地文件。</li></ul></li><li>category:<ul><li><code>CATEGORY_OPENABLE</code>:返回的”openable”文件，能够使用<code>openFileDescriptor()</code>文件打开。</li></ul></li></ul><p><strong>获得一个图片</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static final int REQUEST_IMAGE_OPEN=1;</span><br><span class="line">public void selectImage()&#123;</span><br><span class="line">Intent intent=new Intent(Intent.ACTION_OPEN_DOCUMENT);</span><br><span class="line">intent.setType(&quot;image/*&quot;);</span><br><span class="line">intent.addCategory(Intent.CATEGORY_OPENABLE);</span><br><span class="line">// Only the system receives the ACTION_OPEN_DOCUMENT, so no need to test.</span><br><span class="line">    startActivityForResult(intent, REQUEST_IMAGE_OPEN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onActivityResult(int requestCode,int resultCode,Intent data)&#123;</span><br><span class="line">if(requestCode==REQUEST_IMAGE_OPEN &amp;&amp; resultCode == RESULT_OK)&#123;</span><br><span class="line">Uri fullPhotoUri=data.getData();</span><br><span class="line">//do work with full size phote saved at fullPhotoUri</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三方app不能对<code>ACTION_OPEN_DOCUMENT</code>做出反应。而是系统接收这个显示所有的文件。</p><p>为了允许你的app文件，允许其他应用打开他们，不需要实现<code>DocumentProvider</code>并且包含一个intent-filter<code>PROVIDER_INTERFACE</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider ...</span><br><span class="line">    android:grantUriPermissions=&quot;true&quot;</span><br><span class="line">    android:exported=&quot;true&quot;</span><br><span class="line">    android:permission=&quot;android.permission.MANAGE_DOCUMENTS&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.content.action.DOCUMENTS_PROVIDER&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/provider&gt;</span><br></pre></td></tr></table></figure><p>样例：<a href="https://developer.android.com/guide/topics/providers/document-provider" target="_blank" rel="noopener">Open files using storage access framework</a></p><h1 id="9-音乐或视频"><a href="#9-音乐或视频" class="headerlink" title="9.音乐或视频"></a>9.音乐或视频</h1><h2 id="9-1播放一个音乐文件"><a href="#9-1播放一个音乐文件" class="headerlink" title="9.1播放一个音乐文件"></a>9.1播放一个音乐文件</h2><ul><li>action:<code>ACTION_VIEW</code></li><li><p>uri schemem:</p><ul><li><code>file:&lt;URI&gt;</code></li><li><code>content:&lt;URI&gt;</code></li><li><code>http:&lt;URL&gt;</code></li></ul></li><li><p>MIME type:</p><ul><li><code>audio/*</code></li><li><code>application/ogg</code></li><li><code>application/x-ogg</code></li><li><code>application/itunes</code></li><li>或其他类型</li></ul></li></ul><p><strong>使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void playMedia(Uri file)&#123;</span><br><span class="line">Intent intent=new Intent(Intent.ACTION_VIEW);</span><br><span class="line">intent.setData(file);</span><br><span class="line">if(intent.resolveActiivty(getPackageManager()!=null)&#123;</span><br><span class="line">startActivity(intent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>响应app 过滤</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity&gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">&lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;</span><br><span class="line">&lt;data android:type=&quot;audio/*&quot;/&gt;</span><br><span class="line">&lt;data android:type=&quot;application/ogg&quot;/&gt;</span><br><span class="line">&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><h2 id="9-2播放基于搜索的音乐"><a href="#9-2播放基于搜索的音乐" class="headerlink" title="9.2播放基于搜索的音乐"></a>9.2播放基于搜索的音乐</h2><p>可以用来响应语音的intent。搜索匹配的列表，播放其中的内容。提供<code>EXTRA_MEDIA_FOCUS</code>提供模式。</p><ul><li>action:<code>INTENT_ACTION_MEDIA_PLAY_FROM_SEACRCH</code></li><li>extras:<ul><li><code>MediaStore.EXTRA_MEDIA_FOCUS</code>(必须的)显示搜索模式（艺术家，专辑，歌曲或者播放列表）。如果想听一个歌曲，应该有另外三个额外的内容。歌曲标题，艺术家和专辑。有下面搜索模式：<ul><li><strong>任意</strong>：<code>vnd.android.cursor.item/*</code>播放任意音乐。接收app应该自己选择比如播放者的播放列表。额外参数:<ul><li><code>QUERY</code>(必须的)。空字符串。为了向后兼容，比如当不知道搜索模式可以用这个作为未结构化搜索。</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Intent启动另外一个应用的activity，如Intent和Intent filter使用说明中。许多系统应用已经设置了内部的隐式Intent。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android组件" scheme="http://yoursite.com/tags/Android%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Intent和IntentFilter</title>
    <link href="http://yoursite.com/2018/08/15/Intent%E5%92%8CIntentFilter/"/>
    <id>http://yoursite.com/2018/08/15/Intent和IntentFilter/</id>
    <published>2018-08-15T13:24:17.000Z</published>
    <updated>2019-02-02T11:21:31.742Z</updated>
    
    <content type="html"><![CDATA[<p><code>Intent</code> 是一个消息传递对象，您可以使用它从其他应用组件请求操作。尽管 Intent 可以通过多种方式促进组件之间的通信.</p><a id="more"></a><p>用法主要三个分类：</p><ul><li><p><strong>启动Activity</strong>：启动Activity实例,并携带数据。两种启动方式。</p><ul><li><code>startActivity()</code></li><li><code>startActivityForResult()</code>，在主Activity的<code>onActivityResult()</code>回调返回结果。</li></ul></li><li><p><strong>启动服务</strong>：Service不是用界面后台执行的组件。启动方式有：</p><ul><li><code>startService</code>:交给服务自己处理，一次性操作（下载文件，等）</li><li><code>bindService()</code>绑定服务，交互操作。</li></ul></li><li><p><strong>传递广播</strong>：广播是任何应用均可接受的消息。有几种类型的广播：</p><ul><li><code>sendBroadcast()</code>无序的</li><li><code>sendOrderedBroadcast()</code>有序的广播</li><li><code>sendStickyBroadcast()</code>保持广播（任何人都能够接收的广播）</li></ul></li></ul><h1 id="1-Intent类型"><a href="#1-Intent类型" class="headerlink" title="1.Intent类型"></a>1.Intent类型</h1><p>Intent分为两种类型：</p><ul><li><strong>显示Intent</strong>：按名称(完全限定类名)指定要启动的组件。通常自己应用中使用显示Intent来启动组件，应为自己知道类名。<ul><li>创建显示Intent启动Activity或服务时，系统立即启动指定的组件</li></ul></li><li><strong>隐式Intent</strong>:不指定特定的组件，而是声明要执行的操作。如：显示用户位置，可以使用隐式Intent，请求具有此功能地图显示指定的位置。<ul><li>隐式启动和mainfest中的IntentFilter进行过滤。</li></ul></li></ul><h1 id="2-构建Intent"><a href="#2-构建Intent" class="headerlink" title="2.构建Intent"></a>2.构建Intent</h1><p>Intent中包含主要信息如下：</p><ul><li><p><strong>ComponentName</strong>。有是<strong>显示</strong>，没有则是<strong>隐式</strong>。Intent中字段<code>ComponentName</code>可以使用<code>setComponent()</code>,<code>setClass()</code>和<code>setClassName()</code>或Intent构造函数设置组件名称。</p></li><li><p><strong>Action</strong>：通用想要的动作使用<code>setAction()</code>或者Intent构造函数，如显示view或选择。这个动作最终取决于data和extras的内容。启动Intent一些常量，可以通用使用。如启动一个Activity:</p><ul><li><code>ACTION_VIEW</code>，字符串常量内容为<code>android.intent.action.VIEW</code>.结合<code>startActivity</code>能够启动activity显示，如图片或者地图信息。</li><li><code>ACTION_SEND</code>,可以在email或者一个社交媒体分享。</li></ul></li><li><p><strong>data</strong>:Uri或者是MIME类型。要什么样data类型由action来决定。一般都要指定，系统知道设么样的类型数据。<code>setData()</code>和<code>setType</code>，都有就设置<code>setDataAndType()</code></p></li><li><strong>category</strong>:指定intent组件的类型。<code>addCategory()</code>大部分不需要category.<ul><li><code>CATEGORY_BROWSABLE</code></li><li><code>CATEGORY_LAUNCHER</code>：点击图标启动的activity</li><li><code>CATEGORY_HOME</code>:桌面应用。</li></ul></li></ul><p>Intent上面提到的，决定Intent功能。可以携带一些其它的信息，用<strong>Extras</strong>来实现携带。</p><ul><li><strong>Extras</strong>:Key-value形式。<code>putExtra()</code></li><li><strong>Flags</strong>:<strong>怎样启动activity</strong>(activity task)和<strong>启动后怎么处理</strong>(是否属于最近的activity列表)。<code>setFlags()</code></li></ul><h2 id="2-1-启动例子"><a href="#2-1-启动例子" class="headerlink" title="2.1 启动例子"></a>2.1 启动例子</h2><p><strong>显示启动</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fileUrl:如：http://www.baidu.com/hello.png</span></span><br><span class="line">Intent downloadIntent=<span class="keyword">new</span> Intent(<span class="keyword">this</span>,DownloadService.class);</span><br><span class="line">downloadIntent.setData(Uri.parse(fileUrl));</span><br><span class="line">startService(downloadIntent);</span><br></pre></td></tr></table></figure><p><strong>隐式启动</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create the text message with a string</span></span><br><span class="line">Intent sendIntent=<span class="keyword">new</span> Intent();</span><br><span class="line">sendIntent.setAction(Intent.ACTION_SEND);</span><br><span class="line">sendIntent.putExtra(Intent.EXTRA_TEXT,textMessage);</span><br><span class="line">sendIntent.setType(<span class="string">"text/plain"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//verify that the intent will resolver to an activity</span></span><br><span class="line"><span class="keyword">if</span>(sendIntent.resolveActivity(getPackageManager()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">startActivity(sendIntent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>强制app选择器</strong>：默认动作是用户可以选择框，可以选择默认的app。但是如果想要每次都可选多个app(不去默认)。应该下面这样使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Intent sendIntent=<span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Always use string resource for UI text</span></span><br><span class="line"><span class="comment">//this says something like "Share this photo with"</span></span><br><span class="line">String title=getResources().getString(R.string.chooser_title);</span><br><span class="line"><span class="comment">//create intent to show the choose dialog</span></span><br><span class="line">Intent chooser=Intent.createChooser(sendIntent,title);</span><br><span class="line"></span><br><span class="line"><span class="comment">//verify the orignal intent will resolve to at least one activity</span></span><br><span class="line"><span class="keyword">if</span>(sendIntent.resolveActivity(getPackageManager())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">startActivity(chooser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-IntentFilter"><a href="#3-IntentFilter" class="headerlink" title="3.IntentFilter"></a>3.IntentFilter</h1><p>接收隐式Intent。在mainfest中声明<code>&lt;intent-filter&gt;</code>，每个组件可以声明<strong>一个或多个</strong>。每个intent-filter对应具体的intent。只有通过intent filter才能使用提供的组件。</p><p><strong>注意</strong>：显示的intent总是能够启动目标，忽略组件中的intent filters。</p><p><code>&lt;intent-filter&gt;</code>中使用<strong>一个或多个</strong>下面三个元素：</p><ul><li><code>&lt;action&gt;</code>：action的值。可以声明0个或多个该元素。多个必须匹配其中一个action。<ul><li>如果filter中没有action，intent没有匹配，所有intent都失败。</li><li>但是如果Intent没有指定action，只要filter包含action，就通过测试。</li></ul></li><li><code>&lt;data&gt;</code>：0个或多个属性。(sheme,host,port,path)和MIME type。<ul><li>URI格式<code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code>,如<code>content://com.example.project:200/folder/subfolder/etc</code><ul><li>如果没有scheme，host会被忽略</li><li>如果host没有，port会被忽略</li><li>如果scheme和host都没有path会被忽略</li></ul></li><li>对intent的URI和filter中URI比较，对比较filter中提供的URI部分，比如：<ul><li>如果filter只有scheme，匹配所有该scheme的intent</li><li>提供哪里，配置哪里就可以了。</li></ul></li><li>URI和MIME的intent，规则：<ul><li>Intent中都两个都没有，值匹配也都没有的filter.</li><li>intent只有一个(排除显示的，和继承URI)，filter也只有提供的那个。</li><li>两个都提供，filter也要都提供。如果过滤器仅列出MIME类型，则假定组件支持<code>content:</code>和<code>file:</code>数据。组件能够从本地获得文件或者contentprovider。因此，只列出data type不需要明确scheme(content,file).</li></ul></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--从content provider中获取图片并显示,不需要sheme--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"image/*"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--一个scheme和一个data type--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">android:mimeType</span>=<span class="string">"video/*"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;category&gt;</code>:category名称。可以包含0个或多个category。<ul><li>intent没有category，总是能够匹配过滤。</li></ul></li></ul><p><strong>注意</strong>：Android默认对隐式<code>startActivity()</code>和<code>startActivityForResult()</code>添加了<code>CATEGORY_DEFAULT</code>选项，如果你的activity想使用隐式intent，一定要声明<code>CATEGORY_DEFAULT</code>。</p><h2 id="3-1-例子"><a href="#3-1-例子" class="headerlink" title="3.1 例子"></a>3.1 例子</h2><p>一个activity声明接收<code>ACTION_SEND</code>,data 类型是text.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--可以使用exported=false限制访问--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"ShareActivity"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"text/plain"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：避免无意运行一个service，应该总是显示声明你自己的service，不用对自己的service添加intent filter。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;MainActivity&quot;&gt;</span><br><span class="line">&lt;!-- main entry,appear in app launcher --&gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">&lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</span><br><span class="line">&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line">&lt;activity android:name=&quot;ShareActivity&quot;&gt;</span><br><span class="line">&lt;!--handle &quot;SEND&quot; actions with text data --&gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">&lt;action android:name=&quot;android.intent.action.SEND&quot;/&gt;</span><br><span class="line">&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line">&lt;data android:mimeType=&quot;text/plain&quot;/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line">&lt;!-- handle &quot;send&quot; and &quot;send_multiple&quot; with media data--&gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">&lt;action android:name=&quot;android.intent.action.SEND&quot;/&gt;</span><br><span class="line">&lt;action android:name=&quot;android.intent.action.SEND_MULTIPLE&quot;/&gt;</span><br><span class="line">&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line">&lt;data android:mimeType=&quot;application/vnd.google.panoramsa360+jgp&quot;/&gt;</span><br><span class="line">&lt;data andriod:mimeType=&quot;image/*&quot;/&gt;</span><br><span class="line">&lt;data android:mimeType=&quot;video/*&quot;/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><p><code>MainActivity</code>app主入口，用launcher图标启动的activity。</p><ul><li><code>ACTION_MAIN</code>表明主入口，不需要data</li><li><code>CATEGORY_LAUNHCER</code>这个activity的图标应该放在系统app的launcher。如果activity没有提供图标，应该从<code>&lt;application&gt;</code>中获得。</li></ul><h1 id="4-pending-intent使用"><a href="#4-pending-intent使用" class="headerlink" title="4.pending intent使用"></a>4.pending intent使用</h1><p><code>Pending intent</code>目的是授予别的app使用intent就好像自己的app使用自己进程一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Intent&lt;/code&gt; 是一个消息传递对象，您可以使用它从其他应用组件请求操作。尽管 Intent 可以通过多种方式促进组件之间的通信.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android组件" scheme="http://yoursite.com/tags/Android%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>四大组件-综述</title>
    <link href="http://yoursite.com/2018/08/02/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-%E7%BB%BC%E8%BF%B0/"/>
    <id>http://yoursite.com/2018/08/02/四大组件-综述/</id>
    <published>2018-08-01T19:10:38.000Z</published>
    <updated>2019-02-02T11:21:31.749Z</updated>
    
    <content type="html"><![CDATA[<p>四大组件的管理者AMS。</p><a id="more"></a><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><p>组件启动后，首先需要依赖进程，那么就需要先创建进程，系统需要记录每个进程，这便产生了<code>ProcessRecord</code>。 Android中，对于进程的概念被弱化，通过抽象后的四大组件。让开发者几乎感受不到进程的存在。 当应用退出时，进程也并非马上退出，而是成为<code>cache/empty</code>进程，下次该应用再启动的时候，可以不用 再创建进程直接初始化组件即可，提高启动速度。先来说一说进程。</p><h1 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2.进程管理"></a>2.进程管理</h1><p>Android系统中用于描述进程的数据结构是ProcessRecord对象，AMS便是管理进程的核心模块。四大组件 （Activity,Service, BroadcastReceiver, ContentProvider）定义在<code>AndroidManifest.xml</code>文件， 每一项都可以用属性android:process指定所运行的进程。同一个app可以运行在通过一个进程，也可以运行在多个进程， 甚至多个app可以共享同一个进程。例如：AndroidManifest.xml中定义Service：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span> =<span class="string">".GityuanService"</span> <span class="attr">android:process</span> =<span class="string">":remote"</span> &gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span> =<span class="string">"com.action.gityuan"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><p>GityuanService这个服务运行在remote进程。</p><h2 id="2-1-进程关系图"><a href="#2-1-进程关系图" class="headerlink" title="2.1 进程关系图"></a>2.1 进程关系图</h2><p>以一幅图来展示AMS管理进程的相关成员变量以及ProcessRecord对象：</p><p><img src="/2018/08/02/四大组件-综述/process_record.jpg" alt="进程关系图"></p><h2 id="2-2进程与AMS的关联"><a href="#2-2进程与AMS的关联" class="headerlink" title="2.2进程与AMS的关联"></a>2.2进程与AMS的关联</h2><p>这里只介绍AMS的进程相关的成员变量：</p><ul><li><p><code>mProcessNames</code>：数据类型为ProcessMap，以进程名和userId为key来记录ProcessRecord;</p><ul><li>添加进程，addProcessNameLocked()</li><li>删除进程，removeProcessNameLocked()</li></ul></li><li><p><code>mPidsSelfLocked</code>:数据类型为</p><ul><li>SparseArray，以进程pid为key来记录ProcessRecord;</li><li>startProcessLocked()，移除已存在进程，增加新创建进程pid信息；</li><li>removeProcessLocked，processStartTimedOutLocked，cleanUpApplicationRecordLocked移除进程；</li></ul></li><li><p><code>mLruProcesses</code>：数据类型为ArrayList，以进程最近使用情况来排序记录ProcessRecord;</p><ul><li>其中第一个元素代表的便是最近最少使用的进程；</li><li><code>updateLruProcessLocked()</code>更新进程队列位置；</li></ul></li><li><p>mRemovedProcesses：数据类型为ArrayList，记录所有需要<strong>强制移除的进程</strong>；</p></li><li>mProcessesToGc：数据类型为ArrayList，记录系统进入idle状态<strong>需执行gc操作的进程</strong>；</li><li>mPendingPssProcesses：数据类型为ArrayList，记录将<strong>要收集内存使用数据PSS的进程</strong>；</li><li>mProcessesOnHold：数据类型为ArrayList，记录刚开机过程，系统还没与偶准备就绪的情况下， <strong>所有需要启动的进程</strong>都放入到该队列；</li><li>mPersistentStartingProcesses：数据类型ArrayList，正在启动的<strong>persistent进程</strong>；</li><li>mHomeProcess: 记录包含<strong>home Activity所在的进程</strong>；</li><li>mPreviousProcess：<strong>记录用户上一次刚访问的进程</strong>；其中mPreviousProcessVisibleTime记录上一个进程的用户访问时间；</li><li>mProcessList: 数据类型ProcessList，用于进程管理，<strong>Adj常量定义位于该文件</strong>；</li><li>其中最为常见的是<code>mProcessNames</code>，<code>mPidsSelfLocked</code>，<code>mLruProcesses</code>这3个对象；</li></ul><h2 id="2-3进程与组件的关联"><a href="#2-3进程与组件的关联" class="headerlink" title="2.3进程与组件的关联"></a>2.3进程与组件的关联</h2><p>系统AMS这边是由ProcessRecord对象记录进程，进程自身比较重要成员变量如下：</p><ul><li>processName：记录<strong>进程名</strong>，<strong>默认情况下进程名和该进程运行的第一个apk的包名是相同的</strong>，当然也可以自定义进程名；</li><li>pid: 记录进程pid，该值在由进程创建时内核所分配的。</li><li>thread：执行完<code>attachApplicationLocked()</code>方法，会把客户端进程ApplicationThread的binder服务的代理端传递到 AMS，并保持到ProcessRecord的成员变量thread；<ul><li>ProcessRecord.makeActive，赋值；</li><li>ProcessRecord.makeInactive，清空；</li></ul></li><li>info：记录运行在<strong>该进程的第一个应用</strong>；</li><li>pkgList: 记录运行在<strong>该进程中所有的包名</strong>，比如通过<code>addPackage()</code>添加；</li><li>pkgDeps：记录该<strong>进程所依赖的包名</strong>，比如通过<code>addPackageDependency()</code>添加；</li><li>lastActivityTime：每次<code>updateLruProcessLocked()</code>过程会更新该值；</li><li>killedByAm：当值为true，意味着<code>该进程是被AMS所杀</code>，<strong>而非由于内存低而被LMK所杀</strong>；</li><li>killed：当值为true，意味着该进程被杀，不论是AMS还是其他方式；</li><li>waitingToKill：比如<code>cleanUpRemovedTaskLocked()</code>过程会赋值为”remove task”，当该进程处于后台且等待被kill</li></ul><p>任一组件都运行在某个进程，再来说说ProcessRecord对象中与组件的关联关系：</p><table><thead><tr><th>成员变量</th><th>说明</th><th>组件</th></tr></thead><tbody><tr><td>activities</td><td>记录进程的ActivityRecord列表</td><td>Activity</td></tr><tr><td>services</td><td>记录进程 的ActivityRecord列表</td><td>Service</td></tr><tr><td>executingServices</td><td>记录进程的正在执行的ActivityRecord列表</td><td>Service</td></tr><tr><td>connections</td><td>记录该进程bind的ConnectionRecord集合</td><td>Service</td></tr><tr><td>receivers</td><td>动态注册的广播接收者ReceiverList集合</td><td>Broadcast</td></tr><tr><td>curReceiver</td><td>当前正在处理的一个广播BroadcastRecord</td><td>Broadcast</td></tr><tr><td>pubProviders</td><td>该进程发布的ContentProviderRecord的map表</td><td>ContentProvider</td></tr><tr><td>conProviders</td><td>该进程所请求的ContentProviderConnection列表</td><td>ContentProvider</td></tr></tbody></table><p>说明：</p><ul><li>connections：举例来说，进程A调用<code>bindService()</code>方法去bind远程进程B的Service。 此时会在进程A的ProcessRecord.connections添加一个ConnectionRecord.</li><li>pubProviders: 该进程所有对外发布的ContentProvider信息，这是是以ArrayMap形式保存，即 以provider的name为key,以ContentProviderRecord为value的键值对结构体。</li><li>conProviders: 当进程A调用query()的过程，会执行getContentProvider()方法去向进程B请求 provider的代理。此时会在进程A的ProcessRecord.conProviders添加一个ContentProviderConnection。</li></ul><h1 id="3-AMS的组件管理"><a href="#3-AMS的组件管理" class="headerlink" title="3.AMS的组件管理"></a>3.AMS的组件管理</h1><p>组件启动，先填充完进程信息，接下来还需要完善组件本身的信息，各个组件在system_server的核心信息记录如下：</p><ul><li>Service的信息记录在ActiveServices和AMS</li><li>Broadcast信息记录在BroadcastQueue和AMS</li><li>Activity信息记录在ActivityStack，ActivityStackSupervisor，以及AMS;</li><li>Provider信息记录在ProviderMap和AMS;</li></ul><p>可见，AMS是整个四大组件最为核心的对象，所有组件都或多或少依赖该对象的数据结构信息。 关系图如下：</p><p><img src="/2018/08/02/四大组件-综述/four_component.jpg" alt="数据结构信息"></p><h2 id="3-1-Activity"><a href="#3-1-Activity" class="headerlink" title="3.1 Activity"></a>3.1 Activity</h2><p>AMS对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerService</span> <span class="keyword">extends</span> ..</span>&#123;</span><br><span class="line"><span class="comment">//当前聚焦的Activity</span></span><br><span class="line">ActivityRecord mFoucusedActivity=<span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//用于管理各个Acitivity栈</span></span><br><span class="line"><span class="keyword">final</span> AcitivityStackSupervisor mStackSuptervisor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ASS对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityStackSupervisor</span> <span class="keyword">implements</span> <span class="title">DisplayListener</span> </span>&#123;</span><br><span class="line"><span class="comment">//桌面app所在栈</span></span><br><span class="line">    ActivityStack mHomeStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前可以接受Input事件，或许启动下一个Activity的栈</span></span><br><span class="line">    ActivityStack mFocusedStack;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//当该值等于mFocusedStack，代表当前栈顶的Activity已进入resumed状态；</span></span><br><span class="line">    <span class="comment">//当该值等于上一个旧栈时，代表正处理activity切换状态；</span></span><br><span class="line">    <span class="keyword">private</span> ActivityStack mLastFocusedStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在完成相应目标前，等待新的Activity成为可见的Activity列表</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ActivityRecord&gt; mWaitingVisibleActivities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待找到下一个可见Activity的等待列表</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;IActivityManager.WaitResult&gt; mWaitingActivityVisible = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待找到下一个已启动Activity的等待列表</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;IActivityManager.WaitResult&gt; mWaitingActivityLaunched = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待上一个activity安置完成，则即将进入被stopped的Activity列表</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ActivityRecord&gt; mStoppingActivities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待上一个activity安置完成，则即将进入被finished的Activity列表</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ActivityRecord&gt; mFinishingActivities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//即将进入sleep状态的进程所对应的Activity列表</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ActivityRecord&gt; mGoingToSleepActivities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AS对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityStack</span></span>&#123;</span><br><span class="line"> <span class="comment">//记录该栈中所有的task</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;TaskRecord&gt; mTaskHistory = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//按LRU方式排序的Activity列表，队尾成员是最新活动的Activity</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ActivityRecord&gt; mLRUActivities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//正在执行pausing过程的Activity</span></span><br><span class="line">    ActivityRecord mPausingActivity = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//已处于paused状态的Activity</span></span><br><span class="line">    ActivityRecord mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//已处于Resumed状态的Activity</span></span><br><span class="line">    ActivityRecord mResumedActivity = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-Service"><a href="#3-2-Service" class="headerlink" title="3.2 Service"></a>3.2 Service</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActiveServices.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveServices</span></span>&#123;</span><br><span class="line"><span class="comment">//记录不同User下所有的Service信息</span></span><br><span class="line">    <span class="keyword">final</span> SparseArray&lt;ServiceMap&gt; mServiceMap = <span class="keyword">new</span> SparseArray&lt;&gt;();</span><br><span class="line"><span class="comment">//bind service的连接信息，以IServiceConnection的Bp端作为Keys</span></span><br><span class="line">    <span class="keyword">final</span> ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt; mServiceConnections = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line"> <span class="comment">//已请求启动但尚未启动的Service列表</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ServiceRecord&gt; mPendingServices = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//crash后需要计划重启的Service列表</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ServiceRecord&gt; mRestartingServices = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//正在执行destroyed的service列表</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ServiceRecord&gt; mDestroyingServices = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-Broadcast"><a href="#3-3-Broadcast" class="headerlink" title="3.3 Broadcast"></a>3.3 Broadcast</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[-&gt; ActivityManagerService.java]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerService</span> <span class="keyword">extends</span> ...</span>&#123;</span><br><span class="line"><span class="comment">//前台广播队列</span></span><br><span class="line">    BroadcastQueue mFgBroadcastQueue;</span><br><span class="line"> <span class="comment">//后台广播队列</span></span><br><span class="line">    BroadcastQueue mBgBroadcastQueue;</span><br><span class="line"><span class="comment">//广播队列数组，也就是前台和后台广播队列</span></span><br><span class="line">    <span class="keyword">final</span> BroadcastQueue[] mBroadcastQueues = <span class="keyword">new</span> BroadcastQueue[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//粘性广播，[userId，action，ArrayList&lt;Intent&gt;]</span></span><br><span class="line">    <span class="keyword">final</span> SparseArray&lt;ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;&gt; mStickyBroadcasts;</span><br><span class="line"><span class="comment">//动态注册的广播接收者，其中key为客户端InnerReceiver的Bp端，value为ReceiverList</span></span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;IBinder, ReceiverList&gt; mRegisteredReceivers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//从广播intent到已注册接收者的解析器</span></span><br><span class="line">    <span class="keyword">final</span> IntentResolver&lt;BroadcastFilter, BroadcastFilter&gt; mReceiverResolver；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt; BroadcastQueue.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastQueue</span></span>&#123;</span><br><span class="line">    <span class="comment">//并行广播列表</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;BroadcastRecord&gt; mParallelBroadcasts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//串行广播列表</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;BroadcastRecord&gt; mOrderedBroadcasts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//即将要处理的串行广播，等待目标进程创建完成。每个广播队列只有一个，其他必须等待该广播完成。</span></span><br><span class="line">    BroadcastRecord mPendingBroadcast = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4Provider"><a href="#3-4Provider" class="headerlink" title="3.4Provider"></a>3.4Provider</h2><p>[-&gt; ActivityManagerService.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerService</span> <span class="keyword">extends</span> ...</span>&#123;</span><br><span class="line">    <span class="comment">//记录系统所有的provider信息</span></span><br><span class="line">    <span class="keyword">final</span> ProviderMap mProviderMap;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录有client正在等待的provider列表，当provider发布完成则从该队列移除</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ContentProviderRecord&gt; mLaunchingProviders;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt; ProviderMap.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">//以provider名字(auth)为key的方式所记录的provider信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ContentProviderRecord&gt; mSingletonByName;</span><br><span class="line">    <span class="comment">//以provider组件名(ComponentName)为key的方式所记录的provider信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;ComponentName, ContentProviderRecord&gt; mSingletonByClass;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录不同UserId下的，以auth为key的方式所记录的provider信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SparseArray&lt;HashMap&lt;String, ContentProviderRecord&gt;&gt; mProvidersByNamePerUser;</span><br><span class="line">    <span class="comment">//记录不同UserId下的，以ComponentName为key的方式所记录的provider信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SparseArray&lt;HashMap&lt;ComponentName, ContentProviderRecord&gt;&gt; mProvidersByClassPerUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一个provider组件名，可能对应多个provider名。</p><h1 id="4-App端的组件信息"><a href="#4-App端的组件信息" class="headerlink" title="4.App端的组件信息"></a>4.App端的组件信息</h1><p><img src="/2018/08/02/四大组件-综述/client_component.jpg" alt="App组件信息"></p><p>App端的组件信息，都保存在ActivityThread和LoadedApk这两个对象，主要保存信息：</p><ul><li><code>ActivityThread</code>：记录provider, activity, service在客户端的相关信息；</li><li><code>LoadedApk</code>: 记录动态注册的广播接收器，以及bind方式启动service在客户端的相关信息；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;四大组件的管理者AMS。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android组件" scheme="http://yoursite.com/tags/Android%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Verification</title>
    <link href="http://yoursite.com/2018/08/02/Verification/"/>
    <id>http://yoursite.com/2018/08/02/Verification/</id>
    <published>2018-08-01T17:20:43.000Z</published>
    <updated>2019-02-02T11:21:31.745Z</updated>
    
    <content type="html"><![CDATA[<p>Verification介绍.其代码在InstallParams的handleStartCopy中</p><a id="more"></a><h1 id="Verification介绍"><a href="#Verification介绍" class="headerlink" title="Verification介绍"></a>Verification介绍</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">......<span class="comment">//此处已经获得了合适的安装位置</span></span><br><span class="line">finalInstallArgs args = createInstallArgs(<span class="keyword">this</span>);</span><br><span class="line">mArgs =args;</span><br><span class="line"><span class="keyword">if</span> (ret == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> requiredUid =mRequiredVerifierPackage == <span class="keyword">null</span> ? -<span class="number">1</span></span><br><span class="line">                        :getPackageUid(mRequiredVerifierPackage);</span><br><span class="line">   <span class="keyword">if</span> (requiredUid != -<span class="number">1</span> &amp;&amp;isVerificationEnabled()) &#123;</span><br><span class="line">   <span class="comment">//创建一个Intent，用于查找满足条件的广播接收者</span></span><br><span class="line">   finalIntent verification = <span class="keyword">new</span></span><br><span class="line">                    Intent(Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);</span><br><span class="line">   verification.setDataAndType(packageURI, PACKAGE_MIME_TYPE);</span><br><span class="line">   verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">   <span class="comment">//查找满足Intent条件的广播接收者</span></span><br><span class="line">   finalList&lt;ResolveInfo&gt; receivers = queryIntentReceivers(</span><br><span class="line">               verification,<span class="keyword">null</span>,PackageManager.GET_DISABLED_COMPONENTS);</span><br><span class="line">   <span class="comment">// verificationId为当前等待Verification的安装包个数</span></span><br><span class="line">   finalint verificationId = mPendingVerificationToken++;</span><br><span class="line">   <span class="comment">//设置Intent的参数，例如要校验的包名</span></span><br><span class="line">   verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID,</span><br><span class="line">                              VerificationId);</span><br><span class="line">   verification.putExtra(</span><br><span class="line">                            PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE,</span><br><span class="line">                            installerPackageName);</span><br><span class="line">   verification.putExtra(</span><br><span class="line">                   PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS,flags);</span><br><span class="line">  <span class="keyword">if</span>(verificationURI != <span class="keyword">null</span>) &#123;</span><br><span class="line">     verification.putExtra(PackageManager.EXTRA_VERIFICATION_URI,</span><br><span class="line">                                verificationURI);</span><br><span class="line">  &#125;</span><br><span class="line">  finalPackageVerificationState verificationState = <span class="keyword">new</span></span><br><span class="line">                       PackageVerificationState(requiredUid,args);</span><br><span class="line">  <span class="comment">//将上面创建的PackageVerificationState保存到mPendingVerification中</span></span><br><span class="line">  mPendingVerification.append(verificationId, verificationState);</span><br><span class="line">  <span class="comment">//筛选符合条件的广播接收者</span></span><br><span class="line">  finalList&lt;ComponentName&gt; sufficientVerifiers =</span><br><span class="line">                   matchVerifiers(pkgLite,receivers,verificationState);</span><br><span class="line">  <span class="keyword">if</span> (sufficientVerifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">      finalint N = sufficientVerifiers.size();</span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        finalComponentName verifierComponent = sufficientVerifiers.get(i);</span><br><span class="line">        <span class="keyword">final</span> Intent sufficientIntent = newIntent(verification);</span><br><span class="line">        sufficientIntent.setComponent(verifierComponent);</span><br><span class="line">        <span class="comment">//向校验包发送广播</span></span><br><span class="line">        mContext.sendBroadcast(sufficientIntent);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//除此之外，如果在执行adb install的时候指定了校验包，则需要向其单独发送校验广播</span></span><br><span class="line"> finalComponentName requiredVerifierComponent =</span><br><span class="line">                        matchComponentForVerifier(mRequiredVerifierPackage,</span><br><span class="line">                       receivers);</span><br><span class="line"> <span class="keyword">if</span> (ret == PackageManager.INSTALL_SUCCEEDED</span><br><span class="line">        &amp;&amp;mRequiredVerifierPackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">      verification.setComponent(requiredVerifierComponent);</span><br><span class="line">      mContext.sendOrderedBroadcast(verification,</span><br><span class="line">      android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,</span><br><span class="line">           <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">           <span class="comment">//调用sendOrderdBroadcast，并传递一个BroadcastReceiver，该对象将在</span></span><br><span class="line">          <span class="comment">//广播发送的最后被调用。读者可参考sendOrderdBroadcast的文档说明</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Message msg =mHandler.obtainMessage(</span><br><span class="line">                      CHECK_PENDING_VERIFICATION);</span><br><span class="line">            msg.arg1 = verificationId;</span><br><span class="line">            <span class="comment">//设置一个超时执行时间，该值来自Settings数据库的secure表，默认为60秒</span></span><br><span class="line">            mHandler.sendMessageDelayed(msg, getVerificationTimeout());</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;,<span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">           mArgs = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;......<span class="comment">//不用做Verification的流程</span></span><br></pre></td></tr></table></figure><p>PKMS的Verification工作其实就是收集安装包的信息，然后向对应的校验者发送广播。但遗憾的是，当前Android中还没有能处理Verification的组件。</p><p>另外，该组件处理完Verification后，需要调用PKMS的verifyPendingInstall函数，以通知校验结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Verification介绍.其代码在InstallParams的handleStartCopy中&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="权限" scheme="http://yoursite.com/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>servicemanager</title>
    <link href="http://yoursite.com/2018/08/01/servicemanager/"/>
    <id>http://yoursite.com/2018/08/01/servicemanager/</id>
    <published>2018-07-31T19:14:40.000Z</published>
    <updated>2019-02-02T11:21:31.748Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;待完成。。。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android进程" scheme="http://yoursite.com/tags/Android%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>SystemServer</title>
    <link href="http://yoursite.com/2018/07/31/SystemServer/"/>
    <id>http://yoursite.com/2018/07/31/SystemServer/</id>
    <published>2018-07-30T18:56:31.000Z</published>
    <updated>2019-02-02T11:21:31.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-启动流程"><a href="#1-启动流程" class="headerlink" title="1.启动流程"></a>1.启动流程</h1><p><code>SystemServer</code>由<code>Zygote</code> fork生成的，进程名为<code>system_server</code>，该进程承载着framework的核心服务。</p><a id="more"></a><p><img src="/2018/07/31/SystemServer/system_server.jpg" alt="SystemServer"></p><p>紫色部分运行在<code>zygote</code>进程，蓝色运行在<code>system_server</code></p><h2 id="1-1-startSystemServer"><a href="#1-1-startSystemServer" class="headerlink" title="1.1 startSystemServer"></a>1.1 startSystemServer</h2><p>在zygote完成启动的过程。调用下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static int forkSystemServer(</span><br><span class="line">int uid, int gid, int[] gids, int debugFlags, int[][] rlimits, </span><br><span class="line">long permittedCapabilities, long effectiveCapabilities)&#123;</span><br><span class="line">VM_HOOKS.preFork();</span><br><span class="line">    // 调用native方法fork system_server进程</span><br><span class="line">    int pid = nativeForkSystemServer(</span><br><span class="line">            uid, gid, gids, debugFlags, </span><br><span class="line">rlimit,permittedCapabilities, effectiveCapabilities);</span><br><span class="line">    if (pid == 0) &#123;</span><br><span class="line">        Trace.setTracingEnabled(true);</span><br><span class="line">    &#125;</span><br><span class="line">    VM_HOOKS.postForkCommon();</span><br><span class="line">    return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com_android_internal_os_Zygote.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">com_android_internal_os_Zygote_nativeForkSystemServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">JNIEnv* env, jclass, <span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid, jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">  jint debug_flags, jobjectArray rlimits, jlong permittedCapabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">  jlong effectiveCapabilities</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>&#123;</span><br><span class="line"><span class="comment">//fork子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid=ForkAndSpecializeCommon(env,uid,gid,gids,</span><br><span class="line">debug_flags, rlimits,</span><br><span class="line">                                 permittedCapabilities, effectiveCapabilities,                             MOUNT_EXTERNAL_DEFAULT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">true</span>, <span class="literal">NULL</span>,                         <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//zygote进程，检测system_server进程是否创建</span></span><br><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">if</span>(waitpid(pid,&amp;status,WNOHANG)==pid)&#123;</span><br><span class="line"><span class="comment">//当system_server进程死亡后，重启zygote进程</span></span><br><span class="line">kill(getpid(),SIGKILL);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> pid_t <span class="title">ForkAndSpecializeCommon</span><span class="params">(JNIEnv* env, <span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid, jintArray javaGids, jint debug_flags, jobjectArray javaRlimits, jlong permittedCapabilities, </span></span></span><br><span class="line"><span class="function"><span class="params">jlong effectiveCapabilities, jint mount_external, jstring java_se_info, jstring java_se_name, <span class="keyword">bool</span> is_system_server, jintArray fdsToClose, jstring instructionSet, jstring dataDir)</span></span>&#123;</span><br><span class="line">SetSigChldHandler(); <span class="comment">//设置子进程的signal信号处理函数</span></span><br><span class="line">  <span class="keyword">pid_t</span> pid = fork(); <span class="comment">//fork子进程</span></span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//进入子进程</span></span><br><span class="line">    DetachDescriptors(env, fdsToClose); <span class="comment">//关闭并清除文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!is_system_server) &#123;</span><br><span class="line">        <span class="comment">//对于非system_server子进程，则创建进程组</span></span><br><span class="line">        <span class="keyword">int</span> rc = createProcessGroup(uid, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    SetGids(env, javaGids); <span class="comment">//设置设置group</span></span><br><span class="line">    SetRLimits(env, javaRlimits); <span class="comment">//设置资源limit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc = setresgid(gid, gid, gid);</span><br><span class="line">    rc = setresuid(uid, uid, uid);</span><br><span class="line"></span><br><span class="line">    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">    SetSchedulerPolicy(env); <span class="comment">//设置调度策略</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//selinux上下文</span></span><br><span class="line">    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (se_info_c_str == <span class="literal">NULL</span> &amp;&amp; is_system_server) &#123;</span><br><span class="line">      se_name_c_str = <span class="string">"system_server"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (se_info_c_str != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      SetThreadName(se_name_c_str); <span class="comment">//设置线程名为system_server，方便调试</span></span><br><span class="line">    &#125;</span><br><span class="line">    UnsetSigChldHandler(); <span class="comment">//设置子进程的signal信号处理函数为默认函数</span></span><br><span class="line">    <span class="comment">//等价于调用zygote.callPostForkChildHooks()</span></span><br><span class="line">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,</span><br><span class="line">                              is_system_server ? <span class="literal">NULL</span> : instructionSet);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//进入父进程，即zygote进程</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fork()创建进程。到此system_server进程已经创建完成所有工作，接下来开始system_server真正工作。在前面<code>startSystemServer()</code>方法中，zygote进程执行完<code>forkSystemServer()</code>后，新创建出来的<code>system_server</code>进程便进入<code>handleSystemServerProcess()</code>方法。</p><h2 id="1-2-handleSystemServerProcess"><a href="#1-2-handleSystemServerProcess" class="headerlink" title="1.2 handleSystemServerProcess"></a>1.2 handleSystemServerProcess</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ZygoteInit.java zygoteinit.java中返回执行的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleSystemServerProcess</span><span class="params">(ZygoteConnection.Arguments parsedArgs)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">closeServerSocket();<span class="comment">//关闭父进程zygote复制而来的socket</span></span><br><span class="line">Os.umask(S_IRWXG|S_IRWXO);</span><br><span class="line"><span class="keyword">if</span>(parseArgs.niceName!=<span class="keyword">null</span>)&#123;</span><br><span class="line">Process.setArgv0(parseArgs.niceName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(parseArgs.invokeWith!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//应用进程</span></span><br><span class="line"> WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                    parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                    <span class="keyword">null</span>, parsedArgs.remainingArgs);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//传递剩余参数给systemserver</span></span><br><span class="line"><span class="comment">//system进程</span></span><br><span class="line">RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//should never reach here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处<code>systemServerClasspath</code>环境变量主要有<code>/system/framework/</code>目录下的<code>services.jar，ethernet-service.jar, wifi-service.jar</code>这3个文件</p><h1 id="2-zygoteInit"><a href="#2-zygoteInit" class="headerlink" title="2. zygoteInit"></a>2. zygoteInit</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RuntimeInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">redirectLogStreams();<span class="comment">//重定向log输出</span></span><br><span class="line">commonInit();<span class="comment">//通用的一些初始化</span></span><br><span class="line">nativeZygoteInit();<span class="comment">//zygote初始化</span></span><br><span class="line">applicationInit(targetSdkVersion,argv,classLoader);<span class="comment">//应用初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-redirectLogStreams"><a href="#2-1-redirectLogStreams" class="headerlink" title="2.1 redirectLogStreams"></a>2.1 redirectLogStreams</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RuntimeInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">redirectLogStreams</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.close();</span><br><span class="line">System.setOut(<span class="keyword">new</span> AndroidPrintStream(Log.INFO,<span class="string">"System.out"</span>));</span><br><span class="line">System.err.close();</span><br><span class="line">    System.setErr(<span class="keyword">new</span> AndroidPrintStream(Log.WARN, <span class="string">"System.err"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndroidPrintStream</span> <span class="keyword">extends</span> <span class="title">LoggingPringStream</span></span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> priority;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String tag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new logging print stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priority from &#123;<span class="doctag">@link</span> android.util.Log&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tag to log</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndroidPrintStream</span><span class="params">(<span class="keyword">int</span> priority, String tag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tag == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"tag"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.priority = priority;</span><br><span class="line">        <span class="keyword">this</span>.tag = tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String line)</span> </span>&#123;</span><br><span class="line">        Log.println(priority, tag, line);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//最终调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">println_native</span><span class="params">(<span class="keyword">int</span> bufID,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> priority, String tag, String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2commonInit"><a href="#2-2commonInit" class="headerlink" title="2.2commonInit"></a>2.2commonInit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//RuntimeInit.java</span><br><span class="line">private static final void commonInit() &#123;</span><br><span class="line">    // 设置默认的未捕捉异常处理方法</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());</span><br><span class="line"></span><br><span class="line">    // 设置市区，中国时区为&quot;Asia/Shanghai&quot;</span><br><span class="line">    TimezoneGetter.setInstance(new TimezoneGetter() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String getId() &#123;</span><br><span class="line">            return SystemProperties.get(&quot;persist.sys.timezone&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    TimeZone.setDefault(null);</span><br><span class="line"></span><br><span class="line">    //重置log配置</span><br><span class="line">    LogManager.getLogManager().reset();</span><br><span class="line">    new AndroidConfig();</span><br><span class="line"></span><br><span class="line">    // 设置默认的HTTP User-agent格式,用于 HttpURLConnection。</span><br><span class="line">    String userAgent = getDefaultUserAgent();</span><br><span class="line">    System.setProperty(&quot;http.agent&quot;, userAgent);</span><br><span class="line"></span><br><span class="line">    // 设置socket的tag，用于网络流量统计</span><br><span class="line">    NetworkManagementSocketTagger.install();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3nativeZygoteInit"><a href="#2-3nativeZygoteInit" class="headerlink" title="2.3nativeZygoteInit"></a>2.3nativeZygoteInit</h2><p><code>nativeZygoteInit()</code>方法在AndroidRuntime.cpp中，进行了jni映射，对应下面的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">com_android_internal_os_RuntimeInit_nativeZygoteInit</span><span class="params">(JNIEnv* env, jobject clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此处的gCurRuntime为AppRuntime，是在AndroidRuntime.cpp中定义的</span></span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onZygoteInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    proc-&gt;startThreadPool(); <span class="comment">//启动新binder线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-applicationInit"><a href="#2-4-applicationInit" class="headerlink" title="2.4 applicationInit"></a>2.4 applicationInit</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RuntimeInit.java]</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="comment">//true代表应用程序退出时不调用AppRuntime.onExit()，否则会在退出前调用</span></span><br><span class="line">    nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置虚拟机的内存利用率参数值为0.75</span></span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.75f</span>);</span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Arguments args;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        args = <span class="keyword">new</span> Arguments(argv); <span class="comment">//解析参数</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用startClass的static方法 main() 【见小节11】</span></span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>startSystemServer()</code>方法中通过硬编码初始化参数，可知此处<code>args.startClass</code>为”com.android.server.SystemServer”。</p><h2 id="2-5invokeStaticMain"><a href="#2-5invokeStaticMain" class="headerlink" title="2.5invokeStaticMain"></a>2.5invokeStaticMain</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RuntimeInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过抛出异常，回到ZygoteInit.main()。这样做好处是能清空栈帧，提高栈帧利用率。【见小节12】</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-MethodAndArgsCaller"><a href="#2-6-MethodAndArgsCaller" class="headerlink" title="2.6 MethodAndArgsCaller"></a>2.6 MethodAndArgsCaller</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startSystemServer(abiList, socketName);<span class="comment">//启动system_server</span></span><br><span class="line">        ....</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run(); <span class="comment">//【见小节13】</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在已经很明显了，是<code>invokeStaticMain()</code>方法中抛出的异常<code>MethodAndArgsCaller</code>，从而进入<code>caller.run()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ZygoteInit.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">extends</span> <span class="title">Exception</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据传递过来的参数，可知此处通过反射机制调用的是SystemServer.main()方法</span></span><br><span class="line">            mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable cause = ex.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-启动SystemServer启动"><a href="#3-启动SystemServer启动" class="headerlink" title="3.启动SystemServer启动"></a>3.启动SystemServer启动</h1><p>从Zygote一路启动到SystemServer的过程。 简单回顾下，在RuntimeInit.java中invokeStaticMain方法通过创建并抛出异常ZygoteInit.MethodAndArgsCaller，在ZygoteInit.java中的main()方法会捕捉该异常，并调用<code>caller.run()</code>，再通过反射便会调用到<code>SystemServer.main()</code>方法，该方法主要执行流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SystemServer.main</span><br><span class="line">    SystemServer.run</span><br><span class="line">        createSystemContext</span><br><span class="line">        startBootstrapServices();</span><br><span class="line">        startCoreServices();</span><br><span class="line">        startOtherServices();</span><br><span class="line">        Looper.loop();</span><br></pre></td></tr></table></figure><h2 id="3-1-SystemServer-main"><a href="#3-1-SystemServer-main" class="headerlink" title="3.1 SystemServer.main"></a>3.1 SystemServer.main</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemServer</span></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//先初始化对象，再调用run方法</span></span><br><span class="line"><span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//当系统时间比1970年更早，就设置当前系统时间为1970年</span></span><br><span class="line"><span class="keyword">if</span>(System.currentTimeMillis()&lt;EARLIEST_SUPPORTED_TIME)&#123;</span><br><span class="line"> SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清除vm内存增长上限，由于启动过程需要较多的虚拟机内存空间</span></span><br><span class="line"> VMRuntime.getRuntime().clearGrowthLimit();</span><br><span class="line">VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.8f</span>);</span><br><span class="line">Build.ensureFingerprintProperty();</span><br><span class="line"><span class="comment">//确保当前系统进程的binder调用，总是运行在前台优先级(foreground priority)</span></span><br><span class="line">BinderInternal.disableBackgroundScheduling(<span class="keyword">true</span>);</span><br><span class="line">    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">    android.os.Process.setCanSelfBackground(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 主线程looper就在当前线程运行</span></span><br><span class="line">Looper.prepareMainLooper();</span><br><span class="line"><span class="comment">//加载android_servers.so库，该库包含的源码在frameworks/base/services/目录下</span></span><br><span class="line">System.loadLibrary(<span class="string">"android_servers"</span>);</span><br><span class="line"><span class="comment">//初始化系统上下文 </span></span><br><span class="line">createSystemContext();</span><br><span class="line"> <span class="comment">//创建系统服务管理</span></span><br><span class="line">mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line"><span class="comment">//将mSystemServiceManager添加到本地服务的成员sLocalServiceObjects</span></span><br><span class="line">LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line"><span class="comment">//启动各种系统服务</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">        startBootstrapServices(); </span><br><span class="line">        startCoreServices();      </span><br><span class="line">        startOtherServices();   </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Slog.e(<span class="string">"System"</span>, <span class="string">"************ Failure starting system services"</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//一直循环执行</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LocalServices通过用静态Map变量sLocalServiceObjects，来保存以服务类名为key，以具体服务对象为value的Map结构。</p><h2 id="3-2createSystemContext"><a href="#3-2createSystemContext" class="headerlink" title="3.2createSystemContext"></a>3.2createSystemContext</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//SystemServer.java</span><br><span class="line">private void createSystemContext()&#123;</span><br><span class="line">//创建system_server进程的上下文信息</span><br><span class="line">    ActivityThread activityThread = ActivityThread.systemMain();</span><br><span class="line">    mSystemContext = activityThread.getSystemContext();</span><br><span class="line">    //设置主题</span><br><span class="line">    mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-启动流程&quot;&gt;&lt;a href=&quot;#1-启动流程&quot; class=&quot;headerlink&quot; title=&quot;1.启动流程&quot;&gt;&lt;/a&gt;1.启动流程&lt;/h1&gt;&lt;p&gt;&lt;code&gt;SystemServer&lt;/code&gt;由&lt;code&gt;Zygote&lt;/code&gt; fork生成的，进程名为&lt;code&gt;system_server&lt;/code&gt;，该进程承载着framework的核心服务。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android进程" scheme="http://yoursite.com/tags/Android%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>zygote</title>
    <link href="http://yoursite.com/2018/07/30/zygote/"/>
    <id>http://yoursite.com/2018/07/30/zygote/</id>
    <published>2018-07-30T01:58:33.000Z</published>
    <updated>2019-02-02T11:21:31.749Z</updated>
    
    <content type="html"><![CDATA[<p>Zyote详解<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/base/cmds/app_process/App_main.cpp</span><br><span class="line">/frameworks/base/core/jni/AndroidRuntime.cpp</span><br><span class="line">/frameworks/base/core/java/com/android/internal/os/</span><br><span class="line">  - ZygoteInit.java</span><br><span class="line">  - Zygote.java</span><br><span class="line">  - ZygoteConnection.java</span><br><span class="line">/frameworks/base/core/java/android/net/LocalServerSocket.java</span><br><span class="line">/system/core/libutils/Threads.cpp</span><br></pre></td></tr></table></figure></p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>Zygote是由init.rc解析创建的，zygote所对应可执行程序<code>app_process</code>，所对应的资源文件是<code>App_main.cpp</code>,进程名为zygote。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">class main</span><br><span class="line">socket zygote stream 660 root system</span><br><span class="line">onrestart write /sys/android_power/request_state wake</span><br><span class="line">onrestart write /sys/poweer/state on</span><br><span class="line">onrestart restart media</span><br><span class="line">onrestart restart netd</span><br></pre></td></tr></table></figure><ul><li><code>app_process</code>使用:<code>Usage: app_process [java-options] cmd-dir start-class-name [options]\n</code>.有两种<code>class name</code>或者<code>--zygote</code>.<ul><li>第一种，本文具体分析</li><li>第二种，如<code>am</code>命令使用。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/system/bin/sh</span><br><span class="line">base=/system</span><br><span class="line">export CLASSPATH=$base/framework/am.jar</span><br><span class="line">exec app_process $base/bin com.android.command.am.Am &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>Zygote能够重启的地方：</p><ul><li>servicemanager进程被杀(onrestart)</li><li>surfaceflinger进程被杀(onrestart)</li><li>zygote进程自己被杀(oneshot=fasle)</li><li>system_server进程被杀(waitpid)</li></ul><p>从App_main()开始,zygote启动过程函数调用大致：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">App_main.main()--&gt;AndroidRuntime.start()---&gt;startVm()----&gt;startReg()---&gt;ZygoteInit.main()</span><br><span class="line"></span><br><span class="line">---&gt;registerZygoteSocket()---&gt;preload()---&gt;startSystemServer()---&gt;runSelectLoop()</span><br></pre></td></tr></table></figure><h1 id="2-Zygote启动过程"><a href="#2-Zygote启动过程" class="headerlink" title="2.Zygote启动过程"></a>2.Zygote启动过程</h1><h2 id="2-1-App-main-main"><a href="#2-1-App-main-main" class="headerlink" title="2.1 App_main.main"></a>2.1 App_main.main</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//App_main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*<span class="keyword">const</span> argv[])</span></span>&#123;</span><br><span class="line"><span class="comment">//参数为：--Xzygote /system/bin --zygote --start-system-server</span></span><br><span class="line"> AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));</span><br><span class="line">    argc--; argv++; <span class="comment">//忽略第一个参数</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;argc;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(argv[i][<span class="number">0</span>] !=<span class="string">'-'</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(argv[i][<span class="number">1</span>]==<span class="string">'-'</span> &amp;&amp;n argv[i][<span class="number">2</span>] ==<span class="number">0</span>)&#123;</span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">runtime.addOption(strdup(argv[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数解析</span></span><br><span class="line">boolan zygote=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> startSystemServer=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> application=<span class="literal">false</span>;</span><br><span class="line">String8 niceName;</span><br><span class="line">String8 className;</span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">while</span>(i&lt;argc)&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* arg=argv[i++];</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(arg,<span class="string">"--zygote"</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">zygote=<span class="literal">true</span>;</span><br><span class="line"><span class="comment">//对于64系统nice_name为zygote64,32位为zygote</span></span><br><span class="line">niceName=ZYGOTE_NICE_NAME;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(arg,<span class="string">"--start-system-server"</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">startSystemServer=<span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strncmp</span>(arg,<span class="string">"--nice-name"</span>,<span class="string">"12"</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">niceName.setTo(arg+<span class="number">12</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strncmp</span>(arg,<span class="string">"--"</span>,<span class="number">2</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">className.setTo(arg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">--i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Vector&lt;String8&gt; args;</span><br><span class="line"><span class="keyword">if</span>(!className.isEmpty()&#123;</span><br><span class="line"><span class="comment">//运行application或tool程序</span></span><br><span class="line">args.add(application?String8(<span class="string">"application"</span>):String8(<span class="string">"tool"</span>));</span><br><span class="line">runtime.setClassNameAndArgs(className,argc-i,argv+i);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//进入zygote模式，创建/data/dalvik-cache路径</span></span><br><span class="line">maybeCreateDalvikCache();</span><br><span class="line"><span class="keyword">if</span>(startSystemServer)&#123;</span><br><span class="line">args.add(String8(<span class="string">"start-system-server"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> prop[PROP_VALUE_MAX];</span><br><span class="line">        <span class="keyword">if</span> (property_get(ABI_LIST_PROPERTY, prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String8 abiFlag(<span class="string">"--abi-list="</span>);</span><br><span class="line">        abiFlag.append(prop);</span><br><span class="line">        args.add(abiFlag);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置进程名</span></span><br><span class="line"><span class="keyword">if</span>(!niceName.isEmpty())&#123;</span><br><span class="line">runtime.setArgv0(niceName.<span class="built_in">string</span>());]</span><br><span class="line">set_process_name(niceName.<span class="built_in">string</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(zygote)&#123;</span><br><span class="line">runtime.start(<span class="string">"com.android.internal.as.ZygoteInit"</span>,args,zygote);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(className)&#123;</span><br><span class="line">runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>,args,zygote);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//没有定义类名或zygote</span></span><br><span class="line">retrun <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-start"><a href="#2-2-start" class="headerlink" title="2.2 start"></a>2.2 start</h2><p>启动Android runtime(JNI层，本质是cpp，调用java需要JNI接口实现)。包含启动一个虚拟机，并调用类名中的<code>main()</code>方法.进入java世界<strong>启动虚拟机</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AndroidRuntime.cpp</span></span><br><span class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>*className,<span class="keyword">const</span> Vector&lt;String8&gt;&amp; options,<span class="keyword">bool</span> zygote)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> String8 <span class="title">startSystemServer</span><span class="params">(<span class="string">"start-system-server"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;options.size();++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(options[i]==startSystemServer)&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LOG_BOOT_PROGRESS_START=<span class="number">3000</span>；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ANDROID_ROOT=/system</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* rootDir=getenv(<span class="string">"ANDROID_ROOT"</span>);</span><br><span class="line"><span class="keyword">if</span>(rootDir==<span class="literal">NULL</span>)&#123;</span><br><span class="line">rootDir=<span class="string">"/system"</span>;</span><br><span class="line"><span class="keyword">if</span>(!hasDir(<span class="string">"/system"</span>))&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">setenv(<span class="string">"ANDROID_ROOT"</span>,rootDir,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">JniInvocation jni_invocation;</span><br><span class="line">Jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">JNIEnv *env;</span><br><span class="line"><span class="comment">//虚拟机创建</span></span><br><span class="line"><span class="keyword">if</span>(startVm(&amp;mJavaVM,&amp;env,zygote)!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">onVmCreated(env);</span><br><span class="line"><span class="comment">//JNI方法注册</span></span><br><span class="line"><span class="keyword">if</span>(startReg(env)&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">jclass stringClass;</span><br><span class="line">jobjectArray strArray;</span><br><span class="line">jstring classNameStr;</span><br><span class="line"><span class="comment">//等价strArray=new String[options.size()+1];</span></span><br><span class="line">stringClass=env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</span><br><span class="line">strArray=env-&gt;NewObjectArray(options.size()+<span class="number">1</span>,stringClass,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//等价strArray[0]="com.android.internal.os.ZygoteInit";</span></span><br><span class="line">classNameStr=env-&gt;NewStringUTF(className);</span><br><span class="line">env-&gt;SetObjectArrayElement(strArray,<span class="number">0</span>,classNameStr);</span><br><span class="line"><span class="comment">//等价strArray[1]="start-system-server"</span></span><br><span class="line"><span class="comment">//strArray[2]="--abi-list=xxx"</span></span><br><span class="line"><span class="comment">//其中xxx是体系架构</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;options.size();++i)&#123;</span><br><span class="line">jstring optionsStr=env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</span><br><span class="line">env-&gt;SetObjectArrayElement(strArray,i+<span class="number">1</span>,optionStr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将"com.android.internal.os.ZygoteInit"转换为"com/android/internal/os/ZygoteInit"</span></span><br><span class="line"><span class="comment">//启动VM，该线程变为VM的主线程，直到VM退出返回</span></span><br><span class="line"><span class="keyword">char</span>* slashClassName=toSlashClassName(className);</span><br><span class="line">jclass startClass=env-&gt;FindClass(slashClassName);</span><br><span class="line"><span class="keyword">if</span>(startClass==<span class="literal">NULL</span>)&#123;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">jmethodID startMeth=env-&gt;GetStaticMethodID(startClass,<span class="string">"main"</span>,<span class="string">"([Ljava/lang/String;)V"</span>);</span><br><span class="line"><span class="comment">//调用ZygoteInit.main()方法</span></span><br><span class="line">env-&gt;CallStaticVoidMethod(startClass,startMeth,strArray);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放相应对象空间，意味main不返回，直到主动退出？</span></span><br><span class="line">ALOGD(<span class="string">"Shutting down VM\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(slashClassName);</span><br><span class="line">mJavaVM-&gt;deleteCurrentThread();</span><br><span class="line">mJavaVM-&gt;DestoryJavaVM();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-3-startVM"><a href="#2-3-startVM" class="headerlink" title="2.3 startVM"></a>2.3 startVM</h2><p>创建Java虚拟机方法的主要关于虚拟机参数设置，下面调优过程中常用参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AndroidRuntime.cpp</span></span><br><span class="line"><span class="keyword">int</span> AndroidRuntime::startVM(JavaVM** pJavaVM,JNIEnv **pEnv,<span class="keyword">bool</span> zygote)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//JNI检测功能，用于native层调用jni函数进程常规检测，比较如字符串格式是否符合要求</span></span><br><span class="line"><span class="keyword">bool</span> checkJni=<span class="literal">false</span>;</span><br><span class="line">property_get(<span class="string">"dalvik.vm.checkjni"</span>,propBuf,<span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(propBuf,<span class="string">"true"</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">checkJni=<span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(propBuf,<span class="string">"false"</span>)dalvik.vm.checkjni<span class="string">",propBuf)!=0)&#123;</span></span><br><span class="line"><span class="string">property_get("</span>ro.kernel.android.checkjni<span class="string">",propBuf,"</span><span class="string">");</span></span><br><span class="line"><span class="string">if(propBuf[0]=="</span><span class="number">1</span><span class="string">")&#123;</span></span><br><span class="line"><span class="string">checkJni=true;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">if(checkJni)&#123;</span></span><br><span class="line"><span class="string">addOption("</span>-Xcheck:jni<span class="string">");</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//虚拟机产生的trace文件，主要分析系统问题</span></span><br><span class="line"><span class="string">parseRuntimeOption("</span>dalvik.vm.<span class="built_in">stack</span>-trace-file<span class="string">",stackTraceFileBuf,"</span>-Xstacktracefile:<span class="string">");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//对于不同的软硬件环境，这些参数需要调整，优化，从而使系统达到最佳性能</span></span><br><span class="line"><span class="string">parseRuntimeOption("</span>dalvik.vm.heapstartsize<span class="string">", heapstartsizeOptsBuf, "</span>-Xms<span class="string">", "</span><span class="number">4</span>m<span class="string">");</span></span><br><span class="line"><span class="string">    parseRuntimeOption("</span>dalvik.vm.heapsize<span class="string">", heapsizeOptsBuf, "</span>-Xmx<span class="string">", "</span><span class="number">16</span>m<span class="string">");</span></span><br><span class="line"><span class="string">    parseRuntimeOption("</span>dalvik.vm.heapgrowthlimit<span class="string">", heapgrowthlimitOptsBuf, "</span>-XX:HeapGrowthLimit=<span class="string">");</span></span><br><span class="line"><span class="string">    parseRuntimeOption("</span>dalvik.vm.heapminfree<span class="string">", heapminfreeOptsBuf, "</span>-XX:HeapMinFree=<span class="string">");</span></span><br><span class="line"><span class="string">    parseRuntimeOption("</span>dalvik.vm.heapmaxfree<span class="string">", heapmaxfreeOptsBuf, "</span>-XX:HeapMaxFree=<span class="string">");</span></span><br><span class="line"><span class="string">    parseRuntimeOption("</span>dalvik.vm.heaptargetutilization<span class="string">",</span></span><br><span class="line"><span class="string">                       heaptargetutilizationOptsBuf, "</span>-XX:HeapTargetUtilization=<span class="string">");</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">//preload-classes文件内容手WritePreloadedClassFile.java生成的</span></span><br><span class="line"><span class="string">//ZygoteInit类中会预加载工作将其classes提前加载到内存，提高性能</span></span><br><span class="line"><span class="string">if(!hasFile("</span>/system/etc/preload-classes<span class="string">"))&#123;</span></span><br><span class="line"><span class="string">return -1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//初始化虚拟机</span></span><br><span class="line"><span class="string">//JavaVM对每个进程，JNIEnv是对每个线程。启动完成，可以调用JNI。</span></span><br><span class="line"><span class="string">if(JNI_CreateJavaVM(pJavaVM,pEnv,&amp;initArgs)&lt;0)&#123;</span></span><br><span class="line"><span class="string">ALOGE("</span>JNI_CreateJavaVM failed\n<span class="string">");</span></span><br><span class="line"><span class="string">return -1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>dalvik.vm.checkjni</code>和<code>ro.kernel.android.checkjni</code>检查属性设置</li></ul><h2 id="2-4-startReg"><a href="#2-4-startReg" class="headerlink" title="2.4 startReg"></a>2.4 startReg</h2><p>增加自己的JNI接口。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> AndroidRuntime::startReg(JNIEnv* env)&#123;</span><br><span class="line"><span class="comment">//设置线程创建方法为javaCreateThreadEtc</span></span><br><span class="line">androidSetCreateThreadFunc((android_create_thread_fn)javaCreateThreadEtc);</span><br><span class="line">env-&gt;PushLocalFrame(<span class="number">200</span>);</span><br><span class="line"><span class="comment">//进程JNI方法的注册</span></span><br><span class="line"><span class="keyword">if</span>(register_jni_procs(gRegJNI,NELEM(gRegJNI),env)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">env-&gt;PopLocalFrame(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">env-&gt;PopLocalFrame(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Threads.cpp</span></span><br><span class="line"><span class="comment">//gCreateThreadFn--&gt;javaCreateThreadEtc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">androidSetCreateThreadFunc</span><span class="params">(android_create_thread_fn func)</span></span>&#123;</span><br><span class="line">gCreateThreadFn=func;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">register_jni_procs</span><span class="params">(<span class="keyword">const</span> RegJNIRec <span class="built_in">array</span>[],<span class="keyword">size_t</span> count,JNIEnv*env)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">array</span>[i].mProc(env)&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> RegJNIRec gRegJNI[]=&#123;</span><br><span class="line">REG_JNI(register_com_android_internal_os_RuntimeInit),</span><br><span class="line">    REG_JNI(register_android_os_Binder)，</span><br><span class="line"><span class="comment">//相当于,结构体数组</span></span><br><span class="line"><span class="comment">//&#123;register_com_android_internal_os_RuntimeInit&#125;,</span></span><br><span class="line"><span class="comment">//&#123;register_android_os_Binder&#125;，</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG_JNI(name) &#123;name&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RegJNIRec</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> (*mProc)(JNIEnv*);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-进入Java层"><a href="#3-进入Java层" class="headerlink" title="3.进入Java层"></a>3.进入Java层</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//ZygoteInit.java</span><br><span class="line">public static void main(String argv[])&#123;</span><br><span class="line">try&#123;</span><br><span class="line">RuntimeInit.enableDdms();//开启DDMS功能</span><br><span class="line">SamplingProfilerIntegeration.start();</span><br><span class="line">boolean startSystemServer=false;</span><br><span class="line">String socketName=&quot;zygote&quot;;</span><br><span class="line">String abiList=null;</span><br><span class="line">for(int i=1;i&lt;argv.lenght;i++)&#123;</span><br><span class="line">if(&quot;start-system-server&quot;.equals(argv[i]))&#123;</span><br><span class="line">startSystemServer=true;</span><br><span class="line">&#125;else if(argv[i].startsWith(ABI_LIST_ARGS))&#123;</span><br><span class="line">abiList=argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">&#125;else if(argv[i].startsWith(SOCKET_NAME_ARG))&#123;</span><br><span class="line">socketName=argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">&#125;else&#123;</span><br><span class="line">throw new RuntimeException(&quot;unknown command line argument:&quot;+argv[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">registerZygoteSocket(socketName);</span><br><span class="line">//这里可考虑进行快速启动</span><br><span class="line">preload();//预加载类和资源</span><br><span class="line">SamplingProfilerIntergration.writeZygoteSnapshot();</span><br><span class="line">gcAndFinalize();//GC操作</span><br><span class="line">if(startSystemServer)&#123;</span><br><span class="line">startSystemServer(abiList,socketName);//启动system_server</span><br><span class="line">&#125;</span><br><span class="line">runSelectLoop(abiList);</span><br><span class="line">closeServerSocket();</span><br><span class="line">&#125; catch (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run(); //启动system_server中会讲到。</span><br><span class="line">    &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1-registerZygoteSocket"><a href="#3-1-registerZygoteSocket" class="headerlink" title="3.1 registerZygoteSocket"></a>3.1 registerZygoteSocket</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ZygoteInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerZygoteSocket</span><span class="params">(String socketName)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sServerSocket == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> fileDesc;</span><br><span class="line"><span class="keyword">final</span> String fullSocketName=ANDROID_SOCKET_PREFIX+socketName;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">String env=System.getenv(fullSocketName);</span><br><span class="line">fileDesc=Integer.parseInt(env);</span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">FileDescriptor fd=<span class="keyword">new</span> FileDescriptor();</span><br><span class="line">fd.setInt$(fileDesc);</span><br><span class="line">sServerSocket=<span class="keyword">new</span> LocalServerSocket(fd);<span class="comment">//创建Socket的本地服务端</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-preload"><a href="#3-2-preload" class="headerlink" title="3.2 preload"></a>3.2 preload</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ZygoteInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preload</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//预加载位于preloaded-classes文件中的类（framework/base）在framework.jar打包</span></span><br><span class="line">preloadClasses();</span><br><span class="line"><span class="comment">//预加载资源，包含drawable和color资源</span></span><br><span class="line">preloadResource();</span><br><span class="line"><span class="comment">//预加载OpenGL</span></span><br><span class="line">preloadOpenGL();</span><br><span class="line"><span class="comment">//通过System.loadLibrary()方法,预加载android compile_rt,jnigraphics</span></span><br><span class="line">preloadSharedLibraries();</span><br><span class="line"><span class="comment">//预加载 文本连接符资源</span></span><br><span class="line">prelaodTextResources();</span><br><span class="line"><span class="comment">//仅用于zygote进程，用于内存共享进程</span></span><br><span class="line">WebViewFactory.prepareWebViewInZygote();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-1-加载类"><a href="#3-2-1-加载类" class="headerlink" title="3.2.1 加载类"></a>3.2.1 加载类</h3><p>zygote进程初始化，加载和初始化通用classes，大部分类分配几百字节，有的类几百k<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preloadClasses</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//单例模式</span></span><br><span class="line"><span class="keyword">final</span> VMRuntime runtime=VMRuntime.getRuntime();</span><br><span class="line">InputStream is=ClassLoader.getSystemClassLoader().getResourceAsStream(PRELOADED_CLASSES);</span><br><span class="line">Log.i(<span class="string">"Preloading classes..."</span>);</span><br><span class="line"><span class="keyword">long</span> startTime=SystemClock.uptimeMillis();</span><br><span class="line"><span class="comment">//运行静态初始化，放弃root权限</span></span><br><span class="line"> setEffectiveGroup(UNPRIVILEGED_GID);</span><br><span class="line">     setEffectiveUser(UNPRIVILEGED_UID);</span><br><span class="line"><span class="comment">//通过目标heap利用率(utilization)，明确GC，不会有其他影响</span></span><br><span class="line"><span class="keyword">float</span> defaultUtiliziton=runtime.getTargetHeapUtilization();</span><br><span class="line">runtime.setTargetHeapUtilization(<span class="number">0.8f</span>);</span><br><span class="line"><span class="comment">//开始一个干净的面板（slate)</span></span><br><span class="line">System.gc();</span><br><span class="line">runtime.runFinalizationSync();</span><br><span class="line">Debug.startAllocCounting();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">BufferReader br=<span class="keyword">new</span> BufferReader(<span class="keyword">new</span> InputStreamReader(is),<span class="number">256</span>);</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//跳过注释和空行</span></span><br><span class="line">line =line.trim();</span><br><span class="line"><span class="keyword">if</span>(line.startsWith(<span class="string">"#"</span>) || line.equal(<span class="string">""</span>))&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">false</span>)&#123;</span><br><span class="line">Log.v(TAG,<span class="string">"preloading"</span>+line+<span class="string">"..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个加载类</span></span><br><span class="line">Class.forName(line);</span><br><span class="line"><span class="comment">//PRELOAD_GC_THRESHOLD=50000；超过这个GC</span></span><br><span class="line"><span class="keyword">if</span>(Debug.getGlobalAllocSize()&gt;PRELOAD_GC_THRESHOLD)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">false</span>)&#123;</span><br><span class="line">Log.v(TAG,<span class="string">"GC at"</span>+Debug.getGlobalAllocSize());</span><br><span class="line">&#125;</span><br><span class="line">System.gc();</span><br><span class="line">runtime.runFinalizationSync();</span><br><span class="line">Debug.resetGlobalAllocSize();</span><br><span class="line">&#125;</span><br><span class="line">count++;</span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Log.i(TAG, <span class="string">"...preloaded "</span> + count + <span class="string">" classes in "</span></span><br><span class="line">+ (SystemClock.uptimeMillis()-startTime) + <span class="string">"ms."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">IoUtils.closeQuitely(is);</span><br><span class="line"><span class="comment">// Restore default.</span></span><br><span class="line">        runtime.setTargetHeapUtilization(defaultUtilization);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fill in dex caches with classes, fields, and methods brought in by preloading.</span></span><br><span class="line">        runtime.preloadDexCaches();</span><br><span class="line"></span><br><span class="line">        Debug.stopAllocCounting();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bring back root. We'll need it later.</span></span><br><span class="line">        setEffectiveUser(ROOT_UID);</span><br><span class="line">        setEffectiveGroup(ROOT_GID);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-2-2-加载资源"><a href="#3-2-2-加载资源" class="headerlink" title="3.2.2 加载资源"></a>3.2.2 加载资源</h3><p>加载常用资源，能够进行多进程共享。通常是几k，大多数在20k-40k，有时候更大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preloadResoures</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">final</span> VMRuntime runtime=VMRuntime.getRuntime();</span><br><span class="line">Debug.startAllocCounting();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">System.gc();</span><br><span class="line">runtime.runFinalizationSync();</span><br><span class="line">mResources=Resouces.getSystem();</span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行Zygote进程的初始化,对于类加载，采用反射机制<code>Class.forName()</code>方法来加载。对于资源加载，主要是 <code>com.android.internal.R.array.preloaded_drawables</code>和<code>com.android.internal.R.array.preloaded_color_state_lists</code>，在应用程序中以<code>com.android.internal.R.xxx</code>开头的资源，便是此时由<code>Zygote</code>加载到内存的。</p><p>zygote进程内加载了<code>preload()</code>方法中的所有资源，当需要fork新进程时，采用<code>copy on write</code>技术，如下：</p><p><img src="/2018/07/30/zygote/zygote_fork.jpg" alt="zygote"></p><h2 id="3-3-startSystemServer"><a href="#3-3-startSystemServer" class="headerlink" title="3.3 startSystemServer"></a>3.3 startSystemServer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ZygoteInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startSystemServer</span><span class="params">(String abiList, String socketName)</span>throw MethodAndArgsCaller,RuntimeException</span>&#123;</span><br><span class="line"><span class="keyword">long</span> capabilities=posixCapabilitiesAsBits(</span><br><span class="line">OsConstants.CAP_BLOCK_SUSPEND,</span><br><span class="line">OsConstants.CAP_KILL,</span><br><span class="line">OsConstants.CAP_NET_ADMIN,</span><br><span class="line">OsConstants.CAP_NET_BIND_SERVICE,</span><br><span class="line">OsConstants.CAP_NET_BROADCAST,</span><br><span class="line">OsConstants.CAP_NET_RAW,</span><br><span class="line">OsConstants.CAP_SYS_MODULE,</span><br><span class="line">OsConstants.CAP_SYS_NICE,</span><br><span class="line">OsConstants.CAP_SYS_RESOURCE,</span><br><span class="line">OsConstants.CAP_SYS_TIME,</span><br><span class="line">OsConstants.CAP_SYS_TTY_CONFIG</span><br><span class="line">);</span><br><span class="line"><span class="comment">//参数准备</span></span><br><span class="line">String args[]=&#123;</span><br><span class="line"><span class="string">"--setuid=1000"</span>,</span><br><span class="line"><span class="string">"--setgid=1000"</span>,</span><br><span class="line"><span class="string">"--setgroups=1001,1002,1003,1004,1005,1006,10071008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007"</span>,</span><br><span class="line"> <span class="string">"--capabilities="</span> + capabilities + <span class="string">","</span> + capabilities,</span><br><span class="line">        <span class="string">"--nice-name=system_server"</span>,</span><br><span class="line">        <span class="string">"--runtime-args"</span>,</span><br><span class="line">        <span class="string">"com.android.server.SystemServer"</span>,</span><br><span class="line">&#125;;</span><br><span class="line">ZygoteConnection.Arguments parsedArgs=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//用于解析参数，生成目标格式</span></span><br><span class="line">parseArgs=<span class="keyword">new</span> ZygoteConnection.Arguments(args);</span><br><span class="line">ZygoteConnection.applyDebuggerSystemProperty(parseArgs);</span><br><span class="line">ZygoteConneciton.applyInvokeWithSystemProperty(parseArgs);</span><br><span class="line"><span class="comment">//fork 子进程,用于运行system_server</span></span><br><span class="line">pid=Zygote.forkSystemServer(</span><br><span class="line">parseArgs.uid,parsedArgs.gid,</span><br><span class="line">parseArgs.gids,</span><br><span class="line">parseArgs.debugFlags,</span><br><span class="line"><span class="keyword">null</span>,</span><br><span class="line">parseArgs.permittedCapabilities,</span><br><span class="line">parseArgs.effectiveCapabilities</span><br><span class="line">);</span><br><span class="line">&#125;<span class="keyword">catch</span>(IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进入子进程system_server</span></span><br><span class="line"><span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(hasSecondZygote(abiList))&#123;</span><br><span class="line">waitForSecondaryZygote(socketName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完成system_server进程剩余的工作</span></span><br><span class="line">handleSystemServerProcess(parsedArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-runSelectLoop"><a href="#3-4-runSelectLoop" class="headerlink" title="3.4 runSelectLoop"></a>3.4 runSelectLoop</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZygoteInit.java</span><br></pre></td></tr></table></figure><p>在app进程中分析。</p><h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h1><ul><li>1.解析<code>init.zygote.rc</code>中的参数，创建<code>AppRuntime</code>并调用<code>AppRuntime.start()</code>方法；</li><li>2.调用<code>AndroidRuntime</code>的<code>startVM()</code>方法创建虚拟机，再调用<code>startReg()</code>注册JNI函数；</li><li>3.通过JNI方式调用<code>ZygoteInit.main()</code>，第一次进入<code>Java世界</code>；</li><li>4.<code>registerZygoteSocket()</code>建立socket通道，zygote作为通信的服务端，用于响应客户端请求；</li><li>5.<code>preload()</code>预加载通用类、<code>drawable</code>和<code>color</code>资源、<code>openGL</code>以及共享库以及WebView，用于提高app启动效率；</li><li>6.<code>zygote</code>完毕大部分工作，接下来再通过<code>startSystemServer()</code>，fork得力帮手<code>system_server</code>进程，也是上层framework的运行载体。</li><li>7.<code>zygote</code>功成身退，调用<code>runSelectLoop()</code>，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Zyote详解&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android进程" scheme="http://yoursite.com/tags/Android%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>内存分析</title>
    <link href="http://yoursite.com/2018/07/29/%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/07/29/内存分析/</id>
    <published>2018-07-29T02:33:15.000Z</published>
    <updated>2019-02-02T11:21:31.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>主要介绍Android 几个内存分析命令的使用.<br><a id="more"></a></p><h2 id="1-1-内存指标概念"><a href="#1-1-内存指标概念" class="headerlink" title="1.1 内存指标概念"></a>1.1 内存指标概念</h2><table><thead><tr><th>Item</th><th>全称</th><th>含义</th><th>等价</th></tr></thead><tbody><tr><td>USS</td><td>Unique Set Size</td><td>物理内存</td><td>进程独占的内存</td></tr><tr><td>PSS</td><td>Proportional Set Size</td><td>物理内存</td><td>PSS=USS+按比例包含共享库</td></tr><tr><td>RSS</td><td>Resident Set Size</td><td>物理内存</td><td>RSS=USS+包含共享库</td></tr><tr><td>VSS</td><td>Virtual Set Size</td><td>虚拟内存</td><td>VSS=RSS+未分配实际物理内存</td></tr></tbody></table><p>内存大小关系：<code>VSS&gt;=RSS&gt;=PSS&gt;=USS</code></p><p>内存分析命令：</p><ul><li>1.<code>dumpsys meminfo</code></li><li>2.<code>procrank</code></li><li>3.<code>cat /proc/meminfo</code></li><li>4.<code>free</code></li><li>5.<code>showmap</code></li><li>6.<code>vmshat</code></li></ul><h1 id="2-命令使用"><a href="#2-命令使用" class="headerlink" title="2.命令使用"></a>2.命令使用</h1><h2 id="2-1-dumpsys-meminfo"><a href="#2-1-dumpsys-meminfo" class="headerlink" title="2.1 dumpsys meminfo"></a>2.1 <code>dumpsys meminfo</code></h2><p><code>dumpsys meminfo</code>适用场景： 查看进程的<code>oom adj</code>，或者<code>dalvik/native</code>等区域内存情况，或者某个进程或<code>apk的内存</code>情况，功能非常强大；<br>输出结果分为以下4个部分：</p><table><thead><tr><th>序列</th><th>划分类型</th><th>排序</th><th>解释</th></tr></thead><tbody><tr><td>1</td><td>Process</td><td>PSS</td><td>进程的PSS从大到小排序显示，每行显示一个进程</td></tr><tr><td>2</td><td>OOM adj</td><td>PSS</td><td><code>Native/system/peristent/Foreground/visible/perceptible/A services/home/B services/cached</code>.分别显示进程情况</td></tr><tr><td>3</td><td>category</td><td>PSS</td><td>以<code>Dalvik/native/.art mmap/.dex map</code>等划分的各类进程的总PSS情况</td></tr><tr><td>4</td><td>total</td><td>-</td><td>总内存，剩余内存，可用内存，其他内存</td></tr></tbody></table><p>宁外，可指定输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dumpsys memeinfo &lt;pid&gt;</span><br><span class="line">dumpsys meminfo --package &lt;packagename&gt;//可指定多个进程</span><br></pre></td></tr></table></figure><h2 id="2-2-procrank"><a href="#2-2-procrank" class="headerlink" title="2.2 procrank"></a>2.2 <code>procrank</code></h2><p>功能： 获取所有进程的内存使用的排行榜，排行是以Pss的大小而排序。procrank命令比<code>dumpsys meminfo</code>命令，能输出更详细的<code>VSS/RSS/PSS/USS</code>内存指标。</p><h2 id="2-3-cat-proc-meminfo"><a href="#2-3-cat-proc-meminfo" class="headerlink" title="2.3 cat /proc/meminfo"></a>2.3 <code>cat /proc/meminfo</code></h2><p>功能：能否查看更加详细的内存信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">root@phone:/ # cat /proc/meminfo</span><br><span class="line">MemTotal:        2857.032 kB  //RAM可用的总大小 (即物理总内存减去系统预留和内核二进制代码大小)</span><br><span class="line">MemFree:         1020.708 kB  //RAM未使用的大小</span><br><span class="line">Buffers:           75.104 kB  //用于文件缓冲</span><br><span class="line">Cached:           448.244 kB  //用于高速缓存</span><br><span class="line">SwapCached:             0 kB  //用于swap缓存</span><br><span class="line"></span><br><span class="line">Active:           832.900 kB  //活跃使用状态，记录最近使用过的内存，通常不回收用于其它目的</span><br><span class="line">Inactive:         391.128 kB  //非活跃使用状态，记录最近并没有使用过的内存，能够被回收用于其他目的</span><br><span class="line">Active(anon):     700.744 kB  //Active = Active(anon) + Active(file)</span><br><span class="line">Inactive(anon):       228 kB  //Inactive = Inactive(anon) + Inactive(file)</span><br><span class="line">Active(file):     132.156 kB</span><br><span class="line">Inactive(file):   390.900 kB</span><br><span class="line"></span><br><span class="line">Unevictable:            0 kB</span><br><span class="line">Mlocked:                0 kB</span><br><span class="line"></span><br><span class="line">SwapTotal:        524.284 kB  //swap总大小</span><br><span class="line">SwapFree:         524.284 kB  //swap可用大小</span><br><span class="line">Dirty:                  0 kB  //等待往磁盘回写的大小</span><br><span class="line">Writeback:              0 kB  //正在往磁盘回写的大小</span><br><span class="line"></span><br><span class="line">AnonPages:        700.700 kB  //匿名页，用户空间的页表，没有对应的文件</span><br><span class="line">Mapped:           187.096 kB  //文件通过mmap分配的内存，用于map设备、文件或者库</span><br><span class="line">Shmem:               .312 kB</span><br><span class="line"></span><br><span class="line">Slab:              91.276 kB  //kernel数据结构的缓存大小，Slab=SReclaimable+SUnreclaim</span><br><span class="line">SReclaimable:      32.484 kB  //可回收的slab的大小</span><br><span class="line">SUnreclaim:        58.792 kB  //不可回收slab的大小</span><br><span class="line"></span><br><span class="line">KernelStack:       25.024 kB</span><br><span class="line">PageTables:        23.752 kB  //以最低的页表级</span><br><span class="line">NFS_Unstable:           0 kB  //不稳定页表的大小</span><br><span class="line">Bounce:                 0 kB</span><br><span class="line">WritebackTmp:           0 kB</span><br><span class="line">CommitLimit:     1952.800 kB</span><br><span class="line">Committed_AS:   82204.348 kB   //评估完成的工作量，代表最糟糕case下的值，该值也包含swap内存</span><br><span class="line"></span><br><span class="line">VmallocTotal:  251658.176 kB  //总分配的虚拟地址空间</span><br><span class="line">VmallocUsed:      166.648 kB  //已使用的虚拟地址空间</span><br><span class="line">VmallocChunk:  251398.700 kB  //虚拟地址空间可用的最大连续内存块</span><br></pre></td></tr></table></figure><p>对于<code>cache</code>和<code>buffer</code>也是系统可以使用的内存。所以系统总的可用内存为 <code>MemFree+Buffers+Cached</code></p><h2 id="2-4-free"><a href="#2-4-free" class="headerlink" title="2.4 free"></a>2.4 <code>free</code></h2><p>主功能：查看可用内存，缺省单位KB。该命令比较简单、轻量，专注于查看剩余内存情况。数据来源于<code>/proc/meminfo</code>.</p><h2 id="2-5-showmap"><a href="#2-5-showmap" class="headerlink" title="2.5 showmap"></a>2.5 <code>showmap</code></h2><p>主功能：用于查看虚拟地址区域的内存情况<code>showmap -a [pid]</code></p><p>该命令的输出每一行代表一个虚拟地址区域(vm area)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@phone:/ # showmap -a 10901</span><br><span class="line">   start    end      virtual                   shared   shared  private  private</span><br><span class="line">    addr     addr     size      RSS      PSS    clean    dirty    clean    dirty object</span><br><span class="line">-------- -------- -------- -------- -------- -------- -------- -------- -------- ------------------------------</span><br><span class="line">f3b87000 f3d85000     2040        4        4        0        0        4        0 /dev/binder</span><br></pre></td></tr></table></figure><ul><li><code>start addr</code>和<code>end addr</code>:分别代表进程空间的起止虚拟地址；</li><li><code>virtual size/ RSS /PSS</code>这些前面介绍过；</li><li><code>shared clean</code>：代表多个进程的虚拟地址可指向这块物理空间，即有多少个进程共享这个库；</li><li><code>shared</code>: 共享数据</li><li><code>private</code>: 该进程私有数据</li><li><code>clean</code>: 干净数据，是指该内存数据与disk数据一致，当内存紧张时，可直接释放内存，不需要回写到disk</li><li><code>dirty</code>: 脏数据，与disk数据不一致，需要先回写到disk，才能被释放。<br>功能与<code>cat /proc/[pid]/maps</code>基本一致。</li></ul><h2 id="2-6-vmshat"><a href="#2-6-vmshat" class="headerlink" title="2.6 vmshat"></a>2.6 <code>vmshat</code></h2><p><strong>主功能</strong>：不仅可以查看内存情况，还可以查看<code>进程运行队列</code>、<code>系统切换</code>、<code>CPU时间占比</code>等情况，另外该指令还是<code>周期性地动态</code>输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage: vmstat [ -n iterations ] [ -d delay ] [ -r header_repeat ]</span><br><span class="line">    -n iterations     数据循环输出的次数</span><br><span class="line">    -d delay          两次数据间的延迟时长(单位：S)</span><br><span class="line">    -r header_repeat  循环多少次，再输出一次头信息行</span><br></pre></td></tr></table></figure><p>输入结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@phone:/ # vmstat</span><br><span class="line">procs  memory                       system          cpu</span><br><span class="line"> r  b   free  mapped   anon   slab    in   cs  flt  us ni sy id wa ir</span><br><span class="line"> 2  0  663436 232836 915192 113960   196  274    0   8  0  2 99  0  0</span><br><span class="line"> 0  0  663444 232836 915108 113960   180  260    0   7  0  3 99  0  0</span><br><span class="line"> 0  0  663476 232836 915216 113960   154  224    0   2  0  5 99  0  0</span><br><span class="line"> 1  0  663132 232836 915304 113960   179  259    0  11  0  3 99  0  0</span><br><span class="line"> 2  0  663124 232836 915096 113960   110  175    0   4  0  3 99  0  0</span><br></pre></td></tr></table></figure><p>参数列总共15个参数，分为4大类：</p><ul><li><p>procs(进程)</p><ul><li><code>r</code>: Running队列中进程数量</li><li><code>b</code>: IO wait的进程数量</li></ul></li><li><p>memory(内存) </p><ul><li><code>free</code>: 可用内存大小</li><li><code>mapped</code>：mmap映射的内存大小</li><li><code>anon</code>: 匿名内存大小</li><li><code>slab</code>: slab的内存大小</li></ul></li><li><p>system(系统) </p><ul><li><code>in</code>: 每秒的中断次数(包括时钟中断)</li><li><code>cs</code>: 每秒上下文切换的次数</li></ul></li><li><p>cpu(处理器) </p><ul><li><code>us</code>:user time</li><li><code>ni</code>:nice time</li><li><code>sy</code>:system time</li><li><code>id</code>:idle time</li><li><code>wa</code>:iowait tie</li><li><code>ir</code>:interruppt time</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h1&gt;&lt;p&gt;主要介绍Android 几个内存分析命令的使用.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android 内存管理" scheme="http://yoursite.com/tags/Android-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>服务自动启动</title>
    <link href="http://yoursite.com/2018/07/22/%E6%9C%8D%E5%8A%A1%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8/"/>
    <id>http://yoursite.com/2018/07/22/服务自动启动/</id>
    <published>2018-07-22T14:29:29.000Z</published>
    <updated>2019-02-02T11:21:31.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Linux的启动流程"><a href="#1-Linux的启动流程" class="headerlink" title="1.Linux的启动流程"></a>1.Linux的启动流程</h1><p>启动过程:5个步骤分解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通电---&gt; BIOS ---&gt; 主引导记录 -----&gt;操作系统--①--&gt;/boot--②--&gt;init进程--</span><br><span class="line">-③---&gt; 运行级别--④--&gt;/etc/init.d--⑤--&gt;用户登录---&gt;LoginShell(Non-login shell)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-1加载内核"><a href="#1-1加载内核" class="headerlink" title="1.1加载内核"></a>1.1加载内核</h2><p>操作系统接管硬件以后,首先读入<code>/boot</code>目录下的内核文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ls /boot</span><br><span class="line">initramfs-2.6.32-696.20.1.el6.x86_64.img    System.map-2.6.32-696.23.1.el6.x86_64</span><br><span class="line">initramfs-2.6.32-696.23.1.el6.x86_64.img    vmlinuz-2.6.32-431.el6.x86_64</span><br><span class="line">initrd-2.6.32-431.el6.x86_64kdump.img       vmlinuz-2.6.32-696.20.1.el6.x86_64</span><br><span class="line">initrd-2.6.32-696.20.1.el6.x86_64kdump.img  vmlinuz-2.6.32-696.23.1.el6.x86_64</span><br><span class="line">grub</span><br></pre></td></tr></table></figure><h2 id="1-2启动初始化程序"><a href="#1-2启动初始化程序" class="headerlink" title="1.2启动初始化程序"></a>1.2启动初始化程序</h2><p>内核文件加载以后，就开始运行第一个程序<code>/sbin/init</code>，它的作用是初始化系统环境。<br>由于init是第一个运行的程序，它的进程编号（pid）就是1。其他所有进程都从它衍生，都是它的子进程。</p><h2 id="1-3确定运行级别"><a href="#1-3确定运行级别" class="headerlink" title="1.3确定运行级别"></a>1.3确定运行级别</h2><p>许多开机在Window叫做服务，在Linux叫做守护进程(daemon).init进程的一大任务，就是去运行这些开机启动的程序.但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。Linux允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（runlevel）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。<br>nux预置七种运行级别（0-6）。一般来说，0是关机，1是单用户模式（也就是维护模式），6是重启。运行级别2-5，各个发行版不太一样，对于Debian来说，都是同样的多用户模式（也就是正常模式）。</p><p>init进程首先读取文件 /etc/inittab，它是运行级别的设置文件。如果你打开它，可以看到第一行是这样的：<code>id:5:initdefault:</code></p><p><code>initdefault</code>的值是2，表明系统启动时运行级别为2.需要制定其他界别可手动修改.每个运行级别都在<code>/etc/</code>下有对应的目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//rc表示run command(运行程序),d表示directory目录</span><br><span class="line">rc0.d</span><br><span class="line">rc1.d</span><br><span class="line">rc2.d</span><br><span class="line">rc3.d</span><br><span class="line">rc4.d</span><br><span class="line">rc5.d</span><br><span class="line">rc6.d</span><br></pre></td></tr></table></figure><p>查看<code>rc2.d</code>的目录下文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ll /etc/rc2.d</span><br><span class="line">lrwxrwxrwx. 1 root root 20 Dec 30  2016 K01certmonger -&gt; ../init.d/certmonger</span><br><span class="line">lrwxrwxrwx. 1 root root 13 Mar  2 11:07 K01lxc -&gt; ../init.d/lxc</span><br><span class="line">lrwxrwxrwx. 1 root root 15 Dec 30  2016 K01numad -&gt; ../init.d/numad</span><br></pre></td></tr></table></figure><p>都是链接文件到<code>init.d</code>目录下执行程序。命名格式为<code>字母K+两位数字，程序名</code>.字母K表示Kill(关闭)，表示从其他运行级别切过来要关闭的程序(启动脚本的参数为stop).如果S表示启动(启动运行参数为start)。数字越小启动越早，数字相同按照字母顺序启动。<br>建议用命令修改，不建议手动修改。</p><h2 id="1-4加载开机启动程序"><a href="#1-4加载开机启动程序" class="headerlink" title="1.4加载开机启动程序"></a>1.4加载开机启动程序</h2><p>不同运行级别，但是会指向同一个运行程序，避免不同步问题。 见上面<code>/etc/init.d/certmonger</code></p><h2 id="1-5用户登录"><a href="#1-5用户登录" class="headerlink" title="1.5用户登录"></a>1.5用户登录</h2><p>开机启动程序加载完毕以后，就要让用户登录了。一般来说，用户的登录方式有三种：</p><ul><li>(1)命令行登录<ul><li>init进程调用<code>getty</code>程序(get teletype),让用户输入用户名和密码。输入完成后，再调用login程序，核对密码（Debian还会再多运行一个身份核对程序<code>/etc/pam.d/login</code>）。如果密码正确，就从文件<code>/etc/passwd</code>读取该用户指定的shell，然后启动这个shell。</li></ul></li><li>(2)ssh登录<ul><li>这时系统调用sshd程序（Debian还会再运行<code>/etc/pam.d/ssh</code>），取代<code>getty</code>和<code>login</code>，然后启动shell。</li></ul></li><li>(3)图形界面登录<ul><li>init进程调用显示管理器，Gnome图形界面对应的显示管理器为gdm（GNOME Display Manager），然后用户输入用户名和密码。如果密码正确，就读取<code>/etc/gdm3/Xsession</code>，启动用户的会话。</li></ul></li></ul><h2 id="1-6-进入-login-shell"><a href="#1-6-进入-login-shell" class="headerlink" title="1.6 进入 login shell"></a>1.6 进入 login shell</h2><p>所谓shell，简单说就是命令行界面，让用户可以直接与操作系统对话。用户登录时打开的shell，就叫做<code>login shell</code>。</p><p>Debian默认的shell是<code>Bash</code>，它会读入一系列的配置文件。上一步的三种情况，在这一步的处理，也存在差异。</p><p>（1）命令行登录：首先读入 <code>/etc/profile</code>，这是对所有用户都有效的配置；然后依次寻找下面三个文件，这是针对当前用户的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/.bash_profile</span><br><span class="line">~/.bash_login</span><br><span class="line">~/.profile</span><br></pre></td></tr></table></figure><p>需要注意的是，这三个文件只要有一个存在，就不再读入后面的文件了。比如，要是 <code>~/.bash_profile</code> 存在，就不会再读入后面两个文件了。</p><p>（2）ssh登录：与第一种情况完全相同。<br>（3）图形界面登录：只加载 <code>/etc/profile</code> 和 <code>~/.profile</code>。也就是说，<code>~/.bash_profile</code> 不管有没有，都不会运行。</p><h1 id="2-Linux中设置服务启动三种方式"><a href="#2-Linux中设置服务启动三种方式" class="headerlink" title="2.Linux中设置服务启动三种方式"></a>2.Linux中设置服务启动三种方式</h1><p>主要用三种方式进行这一操作：</p><ul><li><code>ln -s</code>:在/etc/rc.d/rc<em>.d目录中建立/etc/init.d/服务的软链接(</em>代表0～6七个运行级别之一）</li><li><code>chkonfig</code>:命令行运行级别设置</li><li><code>ntsysv</code>: 伪图形运行级别设置</li></ul><h2 id="2-1-ln-s"><a href="#2-1-ln-s" class="headerlink" title="2.1 ln -s"></a>2.1 <code>ln -s</code></h2><p>只需要将可执行脚本丢在/etc/init.d目录下，然后在<code>/etc/rc.d/rc*.d</code>中建立软链接即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ln -s /etc/init.d/sshd /etc/rc.d/rc3.d/S100ssh</span><br></pre></td></tr></table></figure><p>提示：还可以修改<code>/etc/rc.local</code>.这个脚本最后执行init脚本.直接进行修改即可。</p><p><strong>注意</strong>：有的脚本会阻塞导致，后面程序一直等待无法执行。解决办法<code>&amp;</code>添加后台运行。</p><h2 id="2-2-chkconfig"><a href="#2-2-chkconfig" class="headerlink" title="2.2 chkconfig"></a>2.2 <code>chkconfig</code></h2><p>chkconfig 有五项功能：<br>  添加服务，删除服务，列表服务，改变启动信息以及检查特定服务的启动状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//不加name可列出所有的信息</span><br><span class="line">chkconfig --list [name]</span><br><span class="line"></span><br><span class="line">chkconfig --add name</span><br><span class="line"></span><br><span class="line">chkconfig --del name</span><br><span class="line"></span><br><span class="line">chkconfig [--level levels] name</span><br><span class="line"></span><br><span class="line">chkconfig [--level levels] name</span><br></pre></td></tr></table></figure><p>使用1.<code>chkconfig --list</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$chkconfig --list</span><br><span class="line">NetworkManager  0:off1:off2:on3:on4:on5:on6:off</span><br><span class="line">abrt-ccpp       0:off1:off2:off3:on4:off5:on6:off</span><br><span class="line">abrtd           0:off1:off2:off3:on4:off5:on6:off</span><br></pre></td></tr></table></figure><p>添加新脚本步骤：</p><ul><li>1:把上面的脚本放在/etc/init.d/文件夹下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s ./supervisord  /etc/init.d/supervisord</span><br></pre></td></tr></table></figure><ul><li>2.将启动脚本权限改为可执行。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x /etc/init.d/supervisord</span><br></pre></td></tr></table></figure><ul><li>3.添加启动项。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --add supervisord</span><br><span class="line">chkconfig supervisord on</span><br></pre></td></tr></table></figure><ul><li>4.检查是否设置成功。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list | grep supervisord</span><br></pre></td></tr></table></figure><h2 id="2-3-ntsysv"><a href="#2-3-ntsysv" class="headerlink" title="2.3 ntsysv"></a>2.3 <code>ntsysv</code></h2><p>图形界面运行级别设置.上下键操作，Tab键切换。<br>命令<code>setup</code>有的支持，显示会更多操作功能</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Linux的启动流程&quot;&gt;&lt;a href=&quot;#1-Linux的启动流程&quot; class=&quot;headerlink&quot; title=&quot;1.Linux的启动流程&quot;&gt;&lt;/a&gt;1.Linux的启动流程&lt;/h1&gt;&lt;p&gt;启动过程:5个步骤分解&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;通电---&amp;gt; BIOS ---&amp;gt; 主引导记录 -----&amp;gt;操作系统--①--&amp;gt;/boot--②--&amp;gt;init进程--&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-③---&amp;gt; 运行级别--④--&amp;gt;/etc/init.d--⑤--&amp;gt;用户登录---&amp;gt;LoginShell(Non-login shell)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="环境配置" scheme="http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>test_file</title>
    <link href="http://yoursite.com/2018/07/21/test-file/"/>
    <id>http://yoursite.com/2018/07/21/test-file/</id>
    <published>2018-07-21T15:35:50.000Z</published>
    <updated>2019-02-02T11:21:31.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p><img src="/2018/07/21/test-file/avatar.jpg" alt="头像"></p><h2 id="图片-1"><a href="#图片-1" class="headerlink" title="图片"></a>图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](目录名/文件名)</span><br></pre></td></tr></table></figure><h1 id="章分类menu"><a href="#章分类menu" class="headerlink" title="章分类menu"></a>章分类menu</h1><ul><li><code>tags</code>:在public建立相应文件目录，如test</li></ul><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图片&quot;&gt;&lt;a href=&quot;#图片&quot; class=&quot;headerlink&quot; title=&quot;图片&quot;&gt;&lt;/a&gt;图片&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2018/07/21/test-file/avatar.jpg&quot; alt=&quot;头像&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;图片-1
      
    
    </summary>
    
      <category term="测试样例" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E6%A0%B7%E4%BE%8B/"/>
    
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>lowmemorykiller</title>
    <link href="http://yoursite.com/2017/10/27/lowmemorykiller/"/>
    <id>http://yoursite.com/2017/10/27/lowmemorykiller/</id>
    <published>2017-10-26T20:27:54.000Z</published>
    <updated>2019-02-02T11:21:31.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>Android为了快速响应，应用程序退出，还需继续存在系统以再次启动时提高响应时间。太多后台进程，需要进行管理，根据一定策略进行释放进程，有了<code>lmk</code>,<code>lmkd</code>来决定什么时间杀掉什么进程.来决定什么时间杀掉什么进程.</p><a id="more"></a><p>Linux有类似内存管理策略–OOM killer(Out of Memory Killer).OOM策略更多的是用于分配内存不足时触发，<code>将得分最高的进程杀掉</code>。而<code>lmk</code>则会每隔一段时间检查一次，当系统剩余可用内存较低时，便会触发进程的策略，根据不同的剩余内存档位来选择杀不同的优先级的进程，而不是等到OOM时再来杀进程，真正OOM时系统可能已经处于异常状态，系统更希望的是未雨绸缪，在内存很低的时候杀掉一些优先级较低的进程来保障后续操作的顺利进行。</p><p>涉及到java层：<code>ProcessList.java</code>,native层：<code>system/core/lmkd</code>,driver：<code>staging/lowmemroykiller.c</code>.主要通过三个命令来完成调动操作：</p><table><thead><tr><th>功能</th><th>命令</th><th>对应方法</th></tr></thead><tbody><tr><td>LMK_PROCPRIO</td><td>设置进程adj</td><td><code>PL.setOomAdj()</code></td></tr><tr><td>LMK_TARGET</td><td>更新oom_adj</td><td><code>PL.updateOomLevels()</code></td></tr><tr><td>LMK_PROCREMOVE</td><td>移除进程<code>PL.remove()</code></td></tr></tbody></table><h1 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h1><p><code>lmkd</code>通过socket将framework层与native层联系起来，native层通过init解析服务信息与driver内核进程通信。</p><h2 id="2-1-framwork层"><a href="#2-1-framwork层" class="headerlink" title="2.1 framwork层"></a>2.1 framwork层</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> final boolean <span class="title">aplyOomAdjLocked</span><span class="params">(Process add,boolean doingAll,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">long</span> now,<span class="keyword">long</span> nowEllaped)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(app.curAdj!=app.setAdj)&#123;</span><br><span class="line">        ProcessList.setOomAdj(app.id,app.info.uid,app.curAdj);</span><br><span class="line">        app.setAdj=app.curAdj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///ProcessList.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">void</span> <span class="title">setoomAdj</span><span class="params">(<span class="keyword">int</span> pid,<span class="keyword">int</span> uid,<span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="comment">//当adj=16,则直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(amt==UNKOWN_ADJ) </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">long</span> start=SysteClock.elapsedRealTime();</span><br><span class="line">    ByteBuffer buf=ByteBuffer.allocate(<span class="number">4</span>*<span class="number">4</span>);</span><br><span class="line">    buf.putInt(LMK_PROCPRIO);</span><br><span class="line">    buf.putInt(pid);</span><br><span class="line">    buf.putInt(uid);</span><br><span class="line">    buf.putInt(amt);<span class="comment">//目标adj</span></span><br><span class="line">    <span class="comment">//将16字节写入socket,</span></span><br><span class="line">    writeLmkd(buf);</span><br><span class="line">    <span class="keyword">long</span> now =SystemClock.elapedRealtime();</span><br><span class="line">    <span class="keyword">if</span>((now-start)&gt;<span class="number">250</span>)&#123;</span><br><span class="line">        Slog.w(<span class="string">"ActivityManage"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeLmkd</span><span class="params">(ByteBuffer buf)</span></span>&#123;</span><br><span class="line">    <span class="comment">//当socket打开失败会尝试3次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sLmdSocket ==null)&#123;</span><br><span class="line">            <span class="comment">//打开socket</span></span><br><span class="line">            <span class="keyword">if</span>(openLmkdSocket() == <span class="literal">false</span>)&#123; </span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//将buf信息写入lmkd socket</span></span><br><span class="line">            sLmkdOututStream.write(buf.arry(),<span class="number">0</span>,buf.position());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                sLmkdSocket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException ex2)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            sLmkdSocket=null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> boolean <span class="title">openLmkdSocket</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        sLmkdSocket=<span class="keyword">new</span> LocalSocket(LocalSocket.SOCKET_SEQPACKET);</span><br><span class="line">        <span class="comment">//远程lmkd守护进程建立socket连接</span></span><br><span class="line">        sLmkdSocket.connect(<span class="keyword">new</span> LocalSocketAddress(<span class="string">"lmkd"</span>,LocalSocketAddress.Namespace.RESERVED));</span><br><span class="line">        sLmkdOutputStream=sLmkdSocket.getOutputStream();</span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sLmkdSocket</code>采用的是<code>SOCK_SEQPACKET</code>，这是类型socket提供顺序确定的可靠的，双向基于连接的socket endpoint。与<code>SOCK_STREAM</code>很相似，唯一不同的是SEQPACEKET保留消息边界，而SOCK_STREAM是基于字节流，并不会记录边界。 read端能够知道要读取数据大小。</p><h2 id="2-2-native层"><a href="#2-2-native层" class="headerlink" title="2.2 native层"></a>2.2 native层</h2><p>lmkd是由init进程，通过解析init.rc文件启动的Lmkd守护进程，lmkd会创建名为<code>lmkd</code>的socket，节点位于<code>/dev/socket/lmkd</code>,该socket用于跟上层framework交互。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service lmkd /system/bin/lmkd</span><br><span class="line">    class core</span><br><span class="line">    critical</span><br><span class="line">    socket lmkd seqpacket 0660 system system</span><br><span class="line">    writepid /dev/cpuset/system-backgroud/tasks</span><br></pre></td></tr></table></figure><p>lmkd启动，执行可制成程序<code>lmkd</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused,<span class="keyword">char</span> **argv __unused)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shed_param</span> <span class="title">param</span>=&#123;</span></span><br><span class="line">        .sched_priority=<span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    mLockall(MCL_FUTURE);</span><br><span class="line">    shed_setscheduler(<span class="number">0</span>,SCHED_FIFO,&amp;param);</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">if</span>(!init())&#123;</span><br><span class="line">        mainloop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i,ret;</span><br><span class="line">    page_k =sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="keyword">if</span>(page_k==<span class="number">-1</span>)</span><br><span class="line">        page_k=PAGE_SIZE;</span><br><span class="line">    page_k/=<span class="number">1024</span>;</span><br><span class="line">    <span class="comment">//创建epoll监听文件句柄</span></span><br><span class="line">    epollfd=epoll_create(MAX_EPOLL_EVENTS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得lmkd控制描述符</span></span><br><span class="line">    ctrl_lfd=android_get_control_socket(<span class="string">"lmkd"</span>);</span><br><span class="line">    <span class="comment">//监听lmkd socket</span></span><br><span class="line">    ret=listen(ctrl_fd,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    epev.events=EPOLLIN;</span><br><span class="line">    epev.data.ptr=(<span class="keyword">void</span>*)ctrl_connect_handler;</span><br><span class="line">    <span class="comment">//将文件句柄ctrl_lfd,加入epoll句柄</span></span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_ADD,ctrl_lfd,&amp;epev);</span><br><span class="line">    maxevents++;</span><br><span class="line">    <span class="comment">//该路径是否具有可写的权限</span></span><br><span class="line">    use_inkernel_interface=!access(INKERNEL_MINFREE_PATH,W_OK);</span><br><span class="line">    <span class="keyword">if</span>(use_inkernel_interface)&#123;</span><br><span class="line">        ALOGI(<span class="string">"Using inkernel low memory killer interface"</span>):</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ret=init_mp(MEMPERSSURE_WATH_LEVEL,(<span class="keyword">void</span>*)&amp;mp_event);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">            ALOGE(<span class="string">"kernel does not support memeory pressure events or in-kernlr low memory"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=ADJTOSLOT(OOM_SCORE_ADJ_MAX);i++)&#123;</span><br><span class="line">        procadjslot_list[i].next=&amp;procadjslot_list[i];</span><br><span class="line">        procadjslog_list[i].prev=&amp;procadjslog_list[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过检查<code>/sys/module/lowmemorykiller/parameters/minfree</code>节点是否具有可写权限来判断是否使用kernel来管理Lmk事件。默认该节点具有系统可写权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mainloop</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">maxevents</span>];</span></span><br><span class="line">        <span class="keyword">int</span> events,i;</span><br><span class="line">        ctrl_dfd_reopened=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//等待epollfd上的事件</span></span><br><span class="line">        nevents=epoll_wait(epollfd,events,maxevents,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(events==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errono==EINTR)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nevents;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(events[i].events &amp; EPOLLERR)&#123;</span><br><span class="line">                ALOGD(<span class="string">"EPOLLERR on events #%d"</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当事件到来，则盗用ctrl_connects_handler方法</span></span><br><span class="line">            <span class="keyword">if</span>(events[i].data.ptr)&#123;</span><br><span class="line">                (*(*<span class="keyword">void</span>(*))events[i].data.ptr)(events[i].events);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主循环调动<code>epoll_wait()</code>，等待epollfd的事件，当接收到中断或者不存在事件，则执行continue操作。当事件到来，则调用的ctr_connect_handler方法，该方法是由<code>init()</code>过程中设定的方法.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ctrl_connet_handler</span><span class="params">(<span class="keyword">uint32_t</span> events __unused)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(ctrl_dfd &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        ctrl_data_close();</span><br><span class="line">        ctrl_dfd_reopened=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ctrl_dfd=accept(ctrl_lfd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    ALOGI(<span class="string">"ActivityManager connected"</span>);</span><br><span class="line">    maxevents ++;</span><br><span class="line">    epev.events=EPOLLIN;</span><br><span class="line">    epev.data.ptr=(<span class="keyword">void</span>*)ctrl_data_handler;</span><br><span class="line">    <span class="comment">//将ctrl_lfd添加到epollfd</span></span><br><span class="line">    <span class="keyword">if</span>(epoll_ctrl(epollfd,EPOLL_CTL_ADD,ctrl_dfd,&amp;epev)==<span class="number">-1</span>)&#123;</span><br><span class="line">        ctrl_data_close();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-1-处理事件"><a href="#2-2-1-处理事件" class="headerlink" title="2.2.1 处理事件"></a>2.2.1 处理事件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ctrl_data_handler</span><span class="params">(<span class="keyword">uint32_t</span> events)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(events &amp; EPOLLHUP)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ctrl_dfd_reopned)</span><br><span class="line">            ctrl_data_close();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(events &amp; EPOLLIN)&#123;</span><br><span class="line">        ctrl_command_handler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">ctrl_comand_handler</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ibuf[CTRL_PACKET_NAX /<span class="keyword">sizeof</span>(<span class="keyword">int</span>)];</span><br><span class="line">    <span class="keyword">int</span> len,cmd=<span class="number">-1</span>,nargs,targets;</span><br><span class="line">    le=ctr_data_read((<span class="keyword">char</span>*)ibuf,CTRL_PACKET_MAX);</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    nargs=len/<span class="keyword">sizeof</span>(<span class="keyword">int</span>)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nargs&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> wronglen;</span><br><span class="line">    <span class="comment">//将网络字节顺序转化为主机字节顺序</span></span><br><span class="line">    cmd=ntohl(ibuf[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> LMK_TARGET:</span><br><span class="line">            targets=nargs/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nargs &amp; <span class="number">0x01</span> || targets &gt;(<span class="keyword">int</span>)ARRAY_SIZE(lowmem_adj))&#123;</span><br><span class="line">                <span class="keyword">goto</span> wronglen;</span><br><span class="line">            &#125;</span><br><span class="line">            cmd_target(targets,&amp;ibuf[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LMK_PROCPRIO:</span><br><span class="line">            <span class="keyword">if</span>(args !=<span class="number">3</span>)</span><br><span class="line">                <span class="keyword">goto</span> wronglen;</span><br><span class="line">            <span class="comment">//设置进程adj</span></span><br><span class="line">            cmd_proprio(ntohl(ibuf[i]),ntohl(ibuf[<span class="number">2</span>]),ntohl(ibuf[<span class="number">3</span>]));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LMK_PROCREMOVE:</span><br><span class="line">            <span class="keyword">if</span>(nargs !=<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">goto</span> wronglen;</span><br><span class="line">            cmd_procremove(ntohl(ibuf[<span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOGE(<span class="string">"Received unkown command code %d"</span>,cmd);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">wronglen:</span><br><span class="line">    ALOGE(<span class="string">"Wrong control socket read length cmd=%d, len=%d"</span>,cmd,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的分支,进入相应的分支.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cmd_procprio</span><span class="params">(<span class="keyword">int</span> pid,<span class="keyword">int</span> uid,<span class="keyword">int</span> oomadj)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">procp</span>;</span></span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">800</span>],val[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(path,<span class="keyword">sizeof</span>(path),<span class="string">"/proc/%d/oom_scorre_adj"</span>,pid);</span><br><span class="line">    <span class="built_in">snprintf</span>(val,<span class="keyword">sizeof</span>(val),<span class="string">"%d"</span>,oomadj);</span><br><span class="line">    <span class="comment">//向节点/proc/&lt;pid&gt;/oom_score_adj写入oomadj</span></span><br><span class="line">    writefilestring(path,val);</span><br><span class="line">    <span class="comment">//当使用kernel方式则直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(use_ikernel_interface)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    procp=pid_lookup(pid);</span><br><span class="line">    <span class="keyword">if</span>(!procp)&#123;</span><br><span class="line">        procp=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct proc));</span><br><span class="line">        <span class="keyword">if</span>(!procp)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        procp-&gt;pid=pid;</span><br><span class="line">        procp-&gt;uid=uid;</span><br><span class="line">        procp-&gt;oomadj=oomadj;</span><br><span class="line">        proc_insert(procp);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        procp_unslot(procp);</span><br><span class="line">        procp-&gt;oomadj=oomadj;</span><br><span class="line">        procp-&gt;slot(procp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h2><p>use_kernel_interface该值后续应该会逐渐采用用户空间策略。不过目前仍然use_inkernel_interface=1:</p><ul><li>LMK_TARGET:<code>AMS.updateConfiguation()</code>的过程中调用<code>updateOomLevels()</code>方法，分别向<code>/sys/module/lowmemorykiller/parameters</code>的<code>minfree</code> 和 <code>adj</code>节点写入相应信息.</li><li>LMK_PROCPRIO:<code>AMS.applyOomAdjLocked()</code>的过程中调动的<code>setOoAdj()</code>，向<code>/proc/&lt;pid&gt;/oom_score_adj</code>写入omadj,则直接返回。</li><li>LMK_PROCREMOTE:<code>AMS.handleAppDieLocked</code>或者<code>AMS.cleanUpApplicationRecordLocked()</code>的过程,调用<code>remove()</code>,目前不做任何事，直接返回.</li></ul><h1 id="3-Kernel层"><a href="#3-Kernel层" class="headerlink" title="3.Kernel层"></a>3.Kernel层</h1><p>位于<code>/drivers/staging/Android/lowmemorykiller.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">shrinker</span> <span class="title">lowmem_shrinker</span> =&#123;</span></span><br><span class="line">    .scan_objects =lowmem_scan;</span><br><span class="line">.count_objects=lowmeme_count;</span><br><span class="line">.seeks=DEFAULT_SEEKS * <span class="number">16</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">lowmem_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">register_shrinker(&amp;lowmem_shrinker);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">lowmem_exit</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">unregister_shrinker(&amp;lowmem_shrinker);</span><br><span class="line">&#125;</span><br><span class="line">module_init(lowmem_init);</span><br><span class="line">module_exit(lowmem_exit);</span><br></pre></td></tr></table></figure><p>LMK驱动通过注册shrinker实现的，shrinker是linux kernel标准的回收内存page的机制，由内核线程kswapd负责控制。</p><p>当内存不足时kswapd线程会边里一张shrinker链表，并回调已注册的shrinker函数来回收内存page,kswpad还会周期性唤醒来执行内存操作。每个zone维护<code>active_list</code>和<code>inactive_list</code>，内核根据页面活动状态将page在这两个链表之间移动，最后通过shrink_slab和shrink_zone来回收内存页。</p><h2 id="3-1-Lowmem-count"><a href="#3-1-Lowmem-count" class="headerlink" title="3.1 Lowmem_count"></a>3.1 Lowmem_count</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">lowmem_count</span><span class="params">(struct shrinker* s,struct shrink_control *sc)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> global_page_state(NR_ACTIVE_ANON)+</span><br><span class="line">global_page_state(BR_ACTIVE_FILE)+</span><br><span class="line">global_page_state(NR+INACTIVE+ANON)+</span><br><span class="line">global_page_state(NR_INACTIVE_FILE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ANON</code>代表匿名映射，没有后备存储器；<code>FILE</code>代表文件映射；<code>内存映射</code>计算公式=<code>活动匿名内存</code>+<code>活动文件内存</code>+<code>不活动匿名内存</code>+<code>不活动文件内存</code>.</p><h2 id="3-2-lowmem-scan"><a href="#3-2-lowmem-scan" class="headerlink" title="3.2 lowmem_scan"></a>3.2 lowmem_scan</h2><p>当触发lmkd，则先杀<code>oom_score_adj</code>最大的进程，当oom_adj相等时，则选择rss最大的进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">lowmem_scan</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">struct shrinker*s,struck shrinker_control *sc</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>,*<span class="title">selected</span>=<span class="title">NULL</span>;</span></span><br><span class="line">unsigne <span class="keyword">long</span> rem=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tasksize,i,minfree=<span class="number">0</span>,selected_tasksize=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">short</span> min_score_ajd=OOM_SCORE_ADJ_MAX+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> array_size=ARRAT_SIZE(lowmem_adj);</span><br><span class="line"><span class="comment">//获取当前剩余内存大小</span></span><br><span class="line"><span class="keyword">int</span> other_free=global_page_state(NR_FREE_PAGES)-totalreserve_pages;</span><br><span class="line"><span class="keyword">int</span> other_file=global_page_state(NR_FILE_PAGES)-global_page_state(NR_SHMEM)-</span><br><span class="line">total_swapcache_pages();</span><br><span class="line"><span class="comment">//获取数组大小</span></span><br><span class="line"><span class="keyword">if</span>(lowmem_adj_size&lt;array_size)&#123;</span><br><span class="line">array_size=lowmem_adj_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lowmem_minfree_size&lt;array_size)</span><br><span class="line">array_size=lowmem_minfree_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历lowmem_minfree数组找出</span></span><br><span class="line"><span class="keyword">for</span>(i =<span class="number">0</span>;i&lt;array_size;i++)&#123;</span><br><span class="line">minfree=lowmem_minfree[i];</span><br><span class="line"><span class="keyword">if</span>(other_free&lt;minfree &amp;&amp; other_file&lt;minfree)&#123;</span><br><span class="line">min_score_adj=lowmem_adj[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(min_score_adj ==OOM_SCORE_ADJ_MAX+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">selected_oom_score_adj =min_score_adj;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">for_each_process(tsk)&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>*<span class="title">p</span>;</span></span><br><span class="line"><span class="keyword">short</span> oom_score_adj;</span><br><span class="line"><span class="keyword">if</span>(tsk-&gt;flags&amp; PF_KTHREAD)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">p=find_lock_task_mm(tsk);</span><br><span class="line"><span class="keyword">if</span>(!p)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(task_tsk_thread_flag(p,TIF_MEMDIE)&amp;&amp;</span><br><span class="line">time_before_eq(jiffies,lowmem_deathpending_timeout))&#123;</span><br><span class="line">task_unlock(p);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">oom_score_adj=p-&gt;signal-&gt;oom_score_adj;</span><br><span class="line"><span class="comment">//小于目标adj进程，则忽略</span></span><br><span class="line"><span class="keyword">if</span>(oom_score_adj&lt;min_score_adj)&#123;</span><br><span class="line">task_unlock(p);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//算法关键，选择oom_score_adj最大的进程中，并且rss内存最大的进程</span></span><br><span class="line"><span class="keyword">if</span>(selected)&#123;</span><br><span class="line"><span class="keyword">if</span>(oom_score_adj&lt;selected_oom_score_adj)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(oom_score_adj==selected_oom_score_ajd&amp;&amp; tasksize&lt;=selected_tasksize)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">selected=p;</span><br><span class="line">secleted_tasksize=tasksize;</span><br><span class="line">selected_oom_score_adj=oom_score_adj;</span><br><span class="line">lowmem_print(<span class="number">2</span>,<span class="string">"selected ‘%s’ adj %hd ,size %d ,to kill\n"</span>,,</span><br><span class="line">p-&gt;comm,p-&gt;pid,oom_score_adj,tasksize);</span><br><span class="line"><span class="keyword">if</span>(selected)&#123;</span><br><span class="line"><span class="keyword">long</span> cache_size=other_file*(<span class="keyword">long</span>)(PAGE_SIZE/<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">long</span> cache_limit=minfree*(<span class="keyword">long</span>)(PAGE_SIZE/<span class="number">10324</span>);</span><br><span class="line"><span class="keyword">long</span> <span class="built_in">free</span>=other_free*(<span class="keyword">long</span>)(PAGE_SIZE/<span class="number">1024</span>);</span><br><span class="line"><span class="comment">//输出kill 的log</span></span><br><span class="line">lowmem_print(<span class="number">1</span>,<span class="string">"killing %s %d ,adj %hd,\n"</span>);</span><br><span class="line">lowmem_deathpending_timeout=jiffies+HZ;</span><br><span class="line">set_tsk_thread_flag(secleted,TIG_MEMDIE);</span><br><span class="line"><span class="comment">//向选中的目标进程发送signal 9 来杀掉目标进程</span></span><br><span class="line">send_sig(SIGKILL,selceted,<span class="number">0</span>);</span><br><span class="line">rem+=selceted_tasksize;</span><br><span class="line">&#125;</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">return</span> rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lowmem_minfree</code>和<code>lowmem_adj[]</code>数组大小个数为6,通过如下两条命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_param_named(debug_level,lowmem_debug_level,uint,S_IRUGO|S_IWUSE)</span><br><span class="line">module_param_array_named(adj,lowmem_adj,short,&amp;lowmem_adj_size,S_IRUGO|S_IWUSE)</span><br></pre></td></tr></table></figure><p>当如下节点变化，通过修改<code>lowmem_minfree[]</code>和<code>lowmem_adj[]</code>数组.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/sys/<span class="keyword">module</span>/lowmemorykiller/parameters/minfree</span><br><span class="line">/sys/<span class="keyword">module</span>/lowmemorykiller/parameters/adj</span><br></pre></td></tr></table></figure><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><p>从framework的ProcessList调整adj,通过socket通信将时间发送给native的守护进程lmkd；lmkd再根据具体的命令来执行相应的操作</p><ul><li>更新进程<code>oom_score_adj</code>的值和lowmemorykiller驱动参数<code>minfree</code>和<code>adj</code></li></ul><p>最后讲到了lowmemorykiller驱动，通过注册shrinker，借助linux标准的内存回收机制，根据当前系统可用内存以及参数配置(adj,minfree)来选取合适的selected_oom_score_adj，再从所有进程中选择adj大于该目标取值并占用rss内存最大的进程，将其杀掉，从而释放出内存。</p><h2 id="4-1-lmkd参数"><a href="#4-1-lmkd参数" class="headerlink" title="4.1 lmkd参数"></a>4.1 lmkd参数</h2><ul><li>oom_adj:代表进程的优先级，数值越大，优先级越低，越容易被杀，取值范围<code>[-16,15]</code><ul><li><code>/proc/&lt;pid&gt;/oom_adj</code></li></ul></li><li>oom_score_adj:取值范围<code>[-1000,1000]</code><ul><li><code>/proc/&lt;pid&gt;om_score_adj</code></li></ul></li><li>oom_score:lmkd策略中貌似并没有看下用的地方，应该是oom才会调用<ul><li><code>/proc/&lt;pid&gt;/oom_score</code></li></ul></li></ul><p>对于<code>oom_adj</code>与<code>oom_score_adj</code>通过方法<code>lowmem_oom_adj_to_oom_score_adj()</code>建立一定映射关系:</p><ul><li>当<code>oom_adj=15</code>,则<code>oom_score_adj=1000；</code></li><li>当<code>oom_adj&lt;15</code>,则<code>oom_score_adj=oo_adj*1000/17</code></li></ul><h2 id="4-2-driver参数"><a href="#4-2-driver参数" class="headerlink" title="4.2 driver参数"></a>4.2 driver参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/sys/module/lowmemorykiller/parameters/minfree(代表page个数)</span><br><span class="line">/sys/module/lowmemorykiller/parameters/adj(代表oom_score_adj)</span><br></pre></td></tr></table></figure><p>举例说明：</p><ul><li>参数设置：<ul><li><code>1,6</code>写入节点<code>/sys/module/lowmemorykiller/parameters/adj</code></li><li><code>1024,8192</code>写入节点<code>/sys/module/lowmemorykiller/parameters/minfree</code></li></ul></li><li>策略解读:<ul><li>当系统可用内存低语8192个pages时，则会杀掉<code>oom_score_adj&gt;=6</code>的进程</li><li>当系统可用内存低于1024个pages时，会杀掉<code>oom_score_adj&gt;=1</code>的进程。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h1&gt;&lt;p&gt;Android为了快速响应，应用程序退出，还需继续存在系统以再次启动时提高响应时间。太多后台进程，需要进行管理，根据一定策略进行释放进程，有了&lt;code&gt;lmk&lt;/code&gt;,&lt;code&gt;lmkd&lt;/code&gt;来决定什么时间杀掉什么进程.来决定什么时间杀掉什么进程.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android 内存管理" scheme="http://yoursite.com/tags/Android-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>pm</title>
    <link href="http://yoursite.com/2017/08/10/pm/"/>
    <id>http://yoursite.com/2017/08/10/pm/</id>
    <published>2017-08-10T14:47:42.000Z</published>
    <updated>2019-02-02T11:21:31.747Z</updated>
    
    <content type="html"><![CDATA[<p>APK的安装及相关处理流程.</p><a id="more"></a><h1 id="1-adb-install分析"><a href="#1-adb-install分析" class="headerlink" title="1.adb install分析"></a>1.adb install分析</h1><p><code>adb install</code>有多个参数，这里仅考虑最简单的，如<code>adb install frameworktest.apk</code>。adb是一个命令，install是它的参数。此处直接跳到处理install参数的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//commandline.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">adb_commandline</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">   ...... </span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"install"</span>)) &#123;</span><br><span class="line">    ......<span class="comment">//调用install_app函数处理</span></span><br><span class="line">    <span class="keyword">return</span> install_app(ttype, serial, argc, argv);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">install_app</span><span class="params">(transport_type transport, <span class="keyword">char</span>*serial, <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//要安装的APK现在还在Host机器上，要先把APK复制到手机中。</span></span><br><span class="line">   <span class="comment">//这里需要设置复制目标的目录，如果安装在内部存储中，则目标目录为/data/local/tmp；</span></span><br><span class="line">   <span class="comment">//如果安装在SD卡上，则目标目录为/sdcard/tmp。</span></span><br><span class="line">    staticconst <span class="keyword">char</span> *<span class="keyword">const</span> DATA_DEST = <span class="string">"/data/local/tmp/%s"</span>;</span><br><span class="line">    staticconst <span class="keyword">char</span> *<span class="keyword">const</span> SD_DEST = <span class="string">"/sdcard/tmp/%s"</span>;</span><br><span class="line">    constchar* where = DATA_DEST;</span><br><span class="line">    charapk_dest[PATH_MAX];</span><br><span class="line">    charverification_dest[PATH_MAX];</span><br><span class="line">    <span class="keyword">char</span>*apk_file;</span><br><span class="line">    <span class="keyword">char</span>*verification_file = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> file_arg = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(*argv[i] != <span class="string">'-'</span>) &#123;</span><br><span class="line">           file_arg = i;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">"-i"</span>)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">"-s"</span>)) &#123;</span><br><span class="line">           where = SD_DEST; <span class="comment">//-s参数指明该APK安装到SD卡上</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    apk_file= argv[file_arg];</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//获取目标文件的全路径，如果安装在内部存储中，则目标全路径为/data/local/tmp/安装包名，</span></span><br><span class="line">    <span class="comment">//调用do_sync_push将此APK传送到手机的目标路径</span></span><br><span class="line">    err =do_sync_push(apk_file, apk_dest, <span class="number">1</span> <span class="comment">/* verify APK */</span>);</span><br><span class="line">    ...... <span class="comment">//1. 4.0新增了一个安装包Verification功能，相关知识稍后分析</span></span><br><span class="line">    <span class="comment">//2.执行pm命令，这个函数很有意思</span></span><br><span class="line">    pm_command(transport,serial, argc, argv);</span><br><span class="line">......</span><br><span class="line">   cleanup_apk:</span><br><span class="line">   <span class="comment">//3.在手机中执行shell rm 命令，删除刚才传送过去的目标APK文件。为什么要删除呢</span></span><br><span class="line">   delete_file(transport, serial, apk_dest);</span><br><span class="line">   returnerr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中共有三个关键点，分别是：</p><ul><li>4.0新增了APK安装过程中的Verification的功能。其实就是在安装时，把相关信息发送给指定的<code>Verification程序</code>（另外一个APK），由它对要安装的APK进行检查（Verify）。这部分内容在后面分析APK 安装时会介绍。目前，标准代码中还没有从事Verification工作的APK。</li><li>调用pm_command进行安装，这是一个比较有意思的函数，稍后对其进行分析。</li><li>安装完后，执行shell rm删除刚才传送给手机的APK文件。为什么会删除呢？因为PKMS在安装过程中会将该APK复制一份到<code>/data/app</code>目录下，所以<code>/data/local/tmp</code>下的对应文件就可以删除了。这部分代码在后面也能见到。</li></ul><h1 id="2-pm分析"><a href="#2-pm分析" class="headerlink" title="2.pm分析"></a>2.pm分析</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//commandline.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pm_command</span><span class="params">(transport_type transport,<span class="keyword">char</span>* serial,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">  <span class="built_in">snprintf</span>(buf,<span class="keyword">sizeof</span>(buf), <span class="string">"shell:pm"</span>);</span><br><span class="line">  ......<span class="comment">//准备参数</span></span><br><span class="line">  <span class="comment">//发送"shell:pm install 参数"给手机端的adbd</span></span><br><span class="line">  send_shellcommand(transport, serial, buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手机端的adbd在收到客户端发来的shell <code>pm命令</code>时会启动一个shell，然后在其中执行pm。<br>pm实际上是一个脚本，其内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Script to start &quot;pm&quot; on the device,which has a very rudimentary</span><br><span class="line"># shell.</span><br><span class="line">#</span><br><span class="line">base=/system</span><br><span class="line">export CLASSPATH=$base/frameworks/pm.jar</span><br><span class="line">exec app_process $base/bin com.android.commands.pm.Pm &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>在编译system.image时，Android.mk中会将该脚本复制到system/bin目录下。从pm脚本的内容来看，它就是通过app_process执行pm.jar包的main函数。分析Zygote时，已经介绍了app_process是一个Native进程，它通过创建虚拟机启动了Zygote，从而转变为一个Java进程。实际上，app_process还可以通过类似的方法（即先创建Dalvik虚拟机，然后执行某个类的main函数）来转变成其他Java程序。</p><p><strong>注意</strong>:Android系统中常用的monkeytest、pm、am等（这些都是脚本文件）都是以这种方式启动的，所以严格地说，app_process才是Android Java进程的老祖宗。</p><p>pm.java，app_process执行的就是它定义的main函数，它相当于Java进程的入口函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Pm.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Pm().run(args);<span class="comment">//创建一个Pm对象，并执行它的run函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接分析run函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> validCommand = <span class="keyword">false</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//获取PKMS的binder客户端</span></span><br><span class="line">    mPm= IPackageManager.Stub.asInterface(ServiceManager.getService(<span class="string">"package"</span>))</span><br><span class="line">    ......</span><br><span class="line">    mArgs = args;</span><br><span class="line">    String op = args[<span class="number">0</span>];</span><br><span class="line">    mNextArg = <span class="number">1</span>;</span><br><span class="line">    ......<span class="comment">//处理其他命令，这里仅考虑install的处理</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"install"</span>.equals(op)) &#123;</span><br><span class="line">      runInstall();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来分析pm.java的runInstall函数，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runInstall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> installFlags = <span class="number">0</span>;</span><br><span class="line">   String installerPackageName = <span class="keyword">null</span>;</span><br><span class="line">   String opt;</span><br><span class="line">   <span class="keyword">while</span> ((opt=nextOption()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (opt.equals(<span class="string">"-l"</span>)) &#123;</span><br><span class="line">          installFlags |= PackageManager.INSTALL_FORWARD_LOCK;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt.equals(<span class="string">"-r"</span>)) &#123;</span><br><span class="line">          installFlags |= PackageManager.INSTALL_REPLACE_EXISTING;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt.equals(<span class="string">"-i"</span>)) &#123;</span><br><span class="line">          installerPackageName = nextOptionData();</span><br><span class="line">          ...... <span class="comment">//参数解析</span></span><br><span class="line">       &#125; ......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> Uri apkURI;</span><br><span class="line">  <span class="keyword">final</span> Uri verificationURI;</span><br><span class="line">  <span class="keyword">final</span> String apkFilePath = nextArg();</span><br><span class="line">  System.err.println(<span class="string">"/tpkg: "</span> + apkFilePath);</span><br><span class="line">  <span class="keyword">if</span>(apkFilePath != <span class="keyword">null</span>) &#123;</span><br><span class="line">    apkURI = Uri.fromFile(<span class="keyword">new</span> File(apkFilePath));</span><br><span class="line">  &#125;......</span><br><span class="line">  <span class="comment">//获取Verification Package的文件位置</span></span><br><span class="line">  <span class="keyword">final</span> String verificationFilePath = nextArg();</span><br><span class="line">  <span class="keyword">if</span>(verificationFilePath != <span class="keyword">null</span>) &#123;</span><br><span class="line">    verificationURI = Uri.fromFile(<span class="keyword">new</span> File(verificationFilePath));</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    verificationURI = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//创建PackageInstallObserver，用于接收PKMS的安装结果</span></span><br><span class="line">  PackageInstallObserver obs = <span class="keyword">new</span> PackageInstallObserver();</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">     <span class="comment">//1.调用PKMS的installPackageWithVerification完成安装</span></span><br><span class="line">     mPm.installPackageWithVerification(apkURI, obs,</span><br><span class="line">                                  installFlags,installerPackageName,</span><br><span class="line">                                  verificationURI,<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (obs) &#123;</span><br><span class="line">      <span class="keyword">while</span>(!obs.finished) &#123;</span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line">              obs.wait();<span class="comment">//等待安装结果</span></span><br><span class="line">         &#125; ......</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(obs.result == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">             System.out.println(<span class="string">"Success"</span>);<span class="comment">//安装成功，打印Success</span></span><br><span class="line">         &#125;......<span class="comment">//安装失败，打印失败原因</span></span><br><span class="line">      &#125; ......</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Pm解析参数后，最终通过PKMS的Binder客户端调用<code>installPackageWithVerification</code>以完成后续的安装工作，所以，下面进入PKMS看看安装到底是怎么一回事。</p><h2 id="2-1installPackageWithVerification"><a href="#2-1installPackageWithVerification" class="headerlink" title="2.1installPackageWithVerification"></a>2.1installPackageWithVerification</h2><p>installPackageWithVerification的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PackageManagerService.java::installPackageWithVerification</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installPackageWithVerification</span><span class="params">(UripackageURI,</span></span></span><br><span class="line"><span class="function"><span class="params">            IPackageInstallObserverobserver,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> flags, String installerPackageName, Uri verificationURI,</span></span></span><br><span class="line"><span class="function"><span class="params">           ManifestDigest manifestDigest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查客户端进程是否具有安装Package的权限。在本例中，该客户端进程是shell</span></span><br><span class="line">    mContext.enforceCallingOrSelfPermission(</span><br><span class="line">               android.Manifest.permission.INSTALL_PACKAGES,<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> uid = Binder.getCallingUid();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> filteredFlags;</span><br><span class="line">    <span class="keyword">if</span>(uid == Process.SHELL_UID || uid == <span class="number">0</span>) &#123;</span><br><span class="line">        ......<span class="comment">//如果通过shell pm的方式安装，则增加INSTALL_FROM_ADB标志</span></span><br><span class="line">        filteredFlags = flags | PackageManager.INSTALL_FROM_ADB;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           filteredFlags = flags &amp; ~PackageManager.INSTALL_FROM_ADB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个Message，code为INIT_COPY，将该消息发送给之前在PKMS构造函数中</span></span><br><span class="line">    <span class="comment">//创建的mHandler对象，将在另外一个工作线程中处理此消息</span></span><br><span class="line">    <span class="keyword">final</span> Message msg = mHandler.obtainMessage(INIT_COPY);</span><br><span class="line">    <span class="comment">//创建一个InstallParams，其基类是HandlerParams</span></span><br><span class="line">    msg.obj = <span class="keyword">new</span> InstallParams(packageURI, observer,</span><br><span class="line">                   filteredFlags,installerPackageName,</span><br><span class="line">                  verificationURI,manifestDigest);</span><br><span class="line">    mHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>installPackageWithVerification函数倒是蛮清闲，简简单单创建几个对象，然后发送INIT_COPY消息给mHandler，就甩手退出了。根据之前在PKMS构造函数中介绍的知识可知，mHandler被绑定到另外一个工作线程（借助ThreadHandler对象的Looper）中，所以该INIT_COPY消息也将在那个工作线程中进行处理。</p><h2 id="2-2INIT-COPY处理"><a href="#2-2INIT-COPY处理" class="headerlink" title="2.2INIT_COPY处理"></a>2.2INIT_COPY处理</h2><p>INIT_COPY只是安装流程的第一步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">        doHandleMessage(msg);<span class="comment">//调用doHandleMessage函数</span></span><br><span class="line">  &#125; ......</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doHandleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">switch</span>(msg.what) &#123;</span><br><span class="line">    caseINIT_COPY: &#123;</span><br><span class="line">      <span class="comment">//1.这里记录的是params的基类类型HandlerParams，实际类型为InstallParams</span></span><br><span class="line">     HandlerParams params = (HandlerParams) msg.obj;</span><br><span class="line">     <span class="comment">//idx为当前等待处理的安装请求的个数</span></span><br><span class="line">     intidx = mPendingInstalls.size();</span><br><span class="line">     <span class="keyword">if</span>(!mBound) &#123;</span><br><span class="line">        <span class="comment">/*很多读者可能想不到，APK的安装居然需要使用另外一个APK提供的服务，该服务就是</span></span><br><span class="line"><span class="comment">         DefaultContainerService，由DefaultCotainerService.apk提供，</span></span><br><span class="line"><span class="comment">         下面的connectToService函数将调用bindService来启动该服务*/</span></span><br><span class="line">        <span class="keyword">if</span>(!connectToService()) &#123;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//如果已经连上，则以idx为索引，将params保存到mPendingInstalls中</span></span><br><span class="line">           mPendingInstalls.add(idx, params);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           mPendingInstalls.add(idx, params);</span><br><span class="line">           <span class="keyword">if</span>(idx == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">//如果安装请求队列之前的状态为空，则表明要启动安装</span></span><br><span class="line">             mHandler.sendEmptyMessage(MCS_BOUND);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">......<span class="comment">//后续再分析</span></span><br></pre></td></tr></table></figure><p>这里假设之前已经成功启动了DefaultContainerService（以后简称DCS），并且idx为零，所以这是PKMS首次处理安装请求，也就是说，下一个将要处理的是MCS_BOUND消息。</p><p><strong>注意</strong>connectToService在调用bindService时会传递一个DefaultContainerConnection类型的对象，以接收服务启动的结果。当该服务成功启动后，此对象的onServiceConnected被调用，其内部也将发送<code>MCS_BOUND消息</code>给mHandler。</p><h2 id="2-3MCS-BOUND"><a href="#2-3MCS-BOUND" class="headerlink" title="2.3MCS_BOUND"></a>2.3MCS_BOUND</h2><p>安装请求的状态从INIT_COPY变成MCS_BOUND了,依然在doHandleMessage函数中，直接从对应的case开始，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">......<span class="comment">//接doHandleMesage中的switch/case</span></span><br><span class="line"><span class="keyword">case</span> MCS_BOUND: &#123;</span><br><span class="line">  <span class="keyword">if</span>(msg.obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">     mContainerService= (IMediaContainerService) msg.obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(mContainerService == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ......<span class="comment">//如果没法启动该service，则不能安装程序</span></span><br><span class="line">     mPendingInstalls.clear();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(mPendingInstalls.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     HandlerParamsparams = mPendingInstalls.get(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">if</span>(params != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//调用params对象的startCopy函数，该函数由基类HandlerParams定义</span></span><br><span class="line">        <span class="keyword">if</span>(params.startCopy()) &#123;</span><br><span class="line">           ......</span><br><span class="line">            <span class="keyword">if</span>(mPendingInstalls.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               mPendingInstalls.remove(<span class="number">0</span>);<span class="comment">//删除队列头</span></span><br><span class="line">             &#125;</span><br><span class="line">            <span class="keyword">if</span> (mPendingInstalls.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mBound) &#123;</span><br><span class="line">               ......<span class="comment">//如果安装请求都处理完了，则需要和Service断绝联系,</span></span><br><span class="line">              <span class="comment">//通过发送MSC_UNB消息处理断交请求。读者可自行研究此情况的处理流程</span></span><br><span class="line">               removeMessages(MCS_UNBIND);</span><br><span class="line">               Message ubmsg = obtainMessage(MCS_UNBIND);</span><br><span class="line">               sendMessageDelayed(ubmsg, <span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//如果还有未处理的请求，则继续发送MCS_BOUND消息。</span></span><br><span class="line">              <span class="comment">//为什么不通过一个循环来处理所有请求呢</span></span><br><span class="line">              mHandler.sendEmptyMessage(MCS_BOUND);</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125; ......</span><br><span class="line">   <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>MCS_BOUND的处理还算简单，就是调用HandlerParams的startCopy函数。</p><p><strong>HandlerParams和InstallArgs介绍</strong><br>除了HandlerParams家族外，这里提前请出另外一个家族InstallArgs及其成员</p><p><img src="/2017/08/10/pm/20150803110954000.png" alt="参数"></p><ul><li>HandlerParams和InstallArgs均为抽象类。</li><li><p>HandlerParams有三个子类，分别是InstallParams、MoveParams和MeasureParams。</p><ul><li><code>InstallParams</code>用于处理APK的安装</li><li><code>MoveParams</code>用于处理某个已安装APK的搬家请求（例如从内部存储移动到SD卡上）</li><li><code>MeasureParams</code>用于查询某个已安装的APK占据存储空间的大小（例如在设置程序中得到的某个APK使用的缓存文件的大小）。</li></ul></li><li><p>对于InstallParams来说，它还有两个伴儿，即InstallArgs的派生类FileInstallArgs和SdInstallArgs。</p><ul><li><code>FileInstallArgs</code>针对的是安装在内部存储的APK</li><li><code>SdInstallArgs</code>针对的是那些安装在SD卡上的APK。</li></ul></li></ul><p>将讨论用于内部存储安装的FileInstallArgs。在前面MCS_BOUND的处理中，首先调用InstallParams的startCopy函数，该函数由其基类HandlerParams实现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[--&gt;PackageManagerService.java::HandlerParams.startCopy函数]</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> res;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//MAX_RETIRES目前为4，表示尝试4次安装，如果还不成功，则认为安装失败</span></span><br><span class="line">    <span class="keyword">if</span>(++mRetries &gt; MAX_RETRIES) &#123;</span><br><span class="line">        mHandler.sendEmptyMessage(MCS_GIVE_UP);</span><br><span class="line">        handleServiceError();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         handleStartCopy();<span class="comment">//1.调用派生类的handleStartCopy函数</span></span><br><span class="line">         res= <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125; ......</span><br><span class="line">   handleReturnCode();<span class="comment">//2.调用派生类的handleReturnCode，返回处理结果</span></span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基类的startCopy将调用子类实现的handleStartCopy和handleReturnCode函数。下面来看InstallParams是如何实现这两个函数的。</p><p><strong>InstallParams分析</strong><br>先来看派生类InstallParams的handleStartCopy函数，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[--&gt;PackageManagerService::InstallParams.handleStartCopy]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStartCopy</span><span class="params">()</span> throwsRemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret= PackageManager.INSTALL_SUCCEEDED;</span><br><span class="line">    finalboolean fwdLocked = <span class="comment">//不考虑fwdLocked的情况</span></span><br><span class="line">        (flags &amp;PackageManager.INSTALL_FORWARD_LOCK) != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//根据adb install的参数，判断安装位置</span></span><br><span class="line">    finalboolean onSd = (flags &amp; PackageManager.INSTALL_EXTERNAL) != <span class="number">0</span>;</span><br><span class="line">    finalboolean onInt = (flags &amp; PackageManager.INSTALL_INTERNAL) != <span class="number">0</span>;</span><br><span class="line">    PackageInfoLite pkgLite = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(onInt &amp;&amp; onSd) &#123;</span><br><span class="line">        <span class="comment">//APK不能同时安装在内部存储和SD卡上</span></span><br><span class="line">       ret =PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;</span><br><span class="line">    &#125; elseif (fwdLocked &amp;&amp; onSd) &#123;</span><br><span class="line">      <span class="comment">//fwdLocked的应用不能安装在SD卡上</span></span><br><span class="line">      ret =PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       finallong lowThreshold;</span><br><span class="line">       <span class="comment">//获取DeviceStorageMonitorService的binder客户端</span></span><br><span class="line">       finalDeviceStorageMonitorService dsm =                           </span><br><span class="line">             (DeviceStorageMonitorService) ServiceManager.getService(</span><br><span class="line">                                  DeviceStorageMonitorService.SERVICE);</span><br><span class="line">       <span class="keyword">if</span>(dsm == <span class="keyword">null</span>) &#123;</span><br><span class="line">         lowThreshold = <span class="number">0L</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//从DSMS查询内部空间最小余量，默认是总空间的10%</span></span><br><span class="line">         lowThreshold = dsm.getMemoryLowThreshold();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//授权DefContainerService URI读权限</span></span><br><span class="line">        mContext.grantUriPermission(DEFAULT_CONTAINER_PACKAGE,</span><br><span class="line">                  packageURI,Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">       <span class="comment">//1.调用DCS的getMinimalPackageInfo函数，得到一个PackageLite对象</span></span><br><span class="line">       pkgLite =mContainerService.getMinimalPackageInfo(packageURI,</span><br><span class="line">                                   flags,lowThreshold);</span><br><span class="line">     &#125;<span class="keyword">finally</span> ......<span class="comment">//撤销URI授权</span></span><br><span class="line">    <span class="comment">//PacakgeLite的recommendedInstallLocation成员变量保存该APK推荐的安装路径</span></span><br><span class="line">   <span class="keyword">int</span> loc =pkgLite.recommendedInstallLocation;</span><br><span class="line">   <span class="keyword">if</span> (loc== PackageHelper.RECOMMEND_FAILED_INVALID_LOCATION) &#123;</span><br><span class="line">         ret= PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;</span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span>......&#123;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//2.根据DCS返回的安装路径，还需要调用installLocationPolicy进行检查</span></span><br><span class="line">       loc =installLocationPolicy(pkgLite, flags);</span><br><span class="line">       <span class="keyword">if</span>(!onSd &amp;&amp; !onInt) &#123;</span><br><span class="line">          <span class="keyword">if</span>(loc == PackageHelper.RECOMMEND_INSTALL_EXTERNAL) &#123;</span><br><span class="line">              flags |= PackageManager.INSTALL_EXTERNAL;</span><br><span class="line">              flags &amp;=~PackageManager.INSTALL_INTERNAL;</span><br><span class="line">           &#125; ......<span class="comment">//处理安装位置为内部存储的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.创建一个安装参数对象，对于安装位置为内部存储的情况，args的真实类型为FileInstallArgs</span></span><br><span class="line">   <span class="keyword">final</span> InstallArgs args = createInstallArgs(<span class="keyword">this</span>);</span><br><span class="line">   mArgs =args;</span><br><span class="line">   <span class="keyword">if</span> (ret== PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> requiredUid = mRequiredVerifierPackage == <span class="keyword">null</span> ? -<span class="number">1</span></span><br><span class="line">                      :getPackageUid(mRequiredVerifierPackage);</span><br><span class="line">        <span class="keyword">if</span>(requiredUid != -<span class="number">1</span> &amp;&amp; isVerificationEnabled()) &#123;</span><br><span class="line">            ......<span class="comment">//④待会再讨论verification的处理</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//5.调用args的copyApk函数</span></span><br><span class="line">         ret= args.copyApk(mContainerService, <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   mRet =ret;<span class="comment">//确定返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，一共列出了五个关键点，总结如下：</p><ul><li>调用DCS的<code>getMinimalPackageInfo</code>函数，将得到一个<code>PackageLite</code>对象，该对象是一个轻量级的用于描述APK的结构（相比PackageParser.Package来说）。在这段代码逻辑中，主要想取得其recommendedInstallLocation的值。此值表示该APK推荐的安装路径。</li><li>调用installLocationPolicy检查推荐的安装路径。例如<code>系统Package不允许安装在SD卡上</code>。</li><li>createInstallArgs将根据安装位置创建不同的InstallArgs。如果是内部存储，则返回FileInstallArgs，否则为SdInstallArgs。</li><li>在正式安装前，应先对该APK进行必要的检查。这部分代码后续再介绍。</li><li>调用InstallArgs的copyApk。对本例来说，将调用FileInstallArgs的copyApk函数。<br>下面围绕这五个基本关键点展开分析，其中installLocationPolicy和createInstallArgs比较简单</li></ul><p>(1) DefaultContainerService分析<br>首先分析DCS的getMinimalPackageInfo函数，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[--&gt;DefaultContainerService.java::getMinimalPackageInfo函数]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PackageInfoLite <span class="title">getMinimalPackageInfo</span><span class="params">(finalUri fileUri, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      longthreshold)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//注意该函数的参数：fileUri指向该APK的文件路径（此时还在/data/local/tmp下）</span></span><br><span class="line">  PackageInfoLite ret = <span class="keyword">new</span> PackageInfoLite();</span><br><span class="line">  ......</span><br><span class="line">  String scheme = fileUri.getScheme();</span><br><span class="line">  ......</span><br><span class="line">  String archiveFilePath = fileUri.getPath();</span><br><span class="line">  DisplayMetrics metrics = <span class="keyword">new</span> DisplayMetrics();</span><br><span class="line">  metrics.setToDefaults();</span><br><span class="line">  <span class="comment">//调用PackageParser的parsePackageLite解析该APK文件</span></span><br><span class="line">  PackageParser.PackageLite pkg =</span><br><span class="line">         PackageParser.parsePackageLite(archiveFilePath,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (pkg== <span class="keyword">null</span>) &#123;<span class="comment">//解析失败</span></span><br><span class="line">   ......<span class="comment">//设置错误值</span></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  ret.packageName = pkg.packageName;</span><br><span class="line">  ret.installLocation = pkg.installLocation;</span><br><span class="line">  ret.verifiers = pkg.verifiers;</span><br><span class="line">  <span class="comment">//调用recommendAppInstallLocation，取得一个合理的安装位置</span></span><br><span class="line">  ret.recommendedInstallLocation =</span><br><span class="line">          recommendAppInstallLocation(pkg.installLocation,archiveFilePath,</span><br><span class="line">                                          flags, threshold);</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>APK可在AndroidManifest.xml中声明一个安装位置</strong>，不过DCS除了解析该位置外，还需要做进一步检查，这个工作由recommendAppInstallLocation函数完成，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[--&gt;DefaultContainerService.java::recommendAppInstallLocation函数]</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">recommendAppInstallLocation</span><span class="params">(intinstallLocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                               StringarchiveFilePath, <span class="keyword">int</span> flags,<span class="keyword">long</span> threshold)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> prefer;</span><br><span class="line"> booleancheckBoth = <span class="keyword">false</span>;</span><br><span class="line"> check_inner: &#123;</span><br><span class="line">   <span class="keyword">if</span>((flags &amp; PackageManager.INSTALL_FORWARD_LOCK) != <span class="number">0</span>) &#123;</span><br><span class="line">        prefer = PREFER_INTERNAL;</span><br><span class="line">        <span class="keyword">break</span> check_inner; <span class="comment">//根据FOWRAD_LOCK的情况，只能安装在内部存储</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; PackageManager.INSTALL_INTERNAL) != <span class="number">0</span>) &#123;</span><br><span class="line">        prefer = PREFER_INTERNAL;</span><br><span class="line">        <span class="keyword">break</span> check_inner;</span><br><span class="line">   &#125;</span><br><span class="line">   ......<span class="comment">//检查各种情况</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(installLocation == PackageInfo.INSTALL_LOCATION_AUTO) &#123;</span><br><span class="line">     prefer= PREFER_INTERNAL;<span class="comment">//一般设定的位置为AUTO，默认是内部空间</span></span><br><span class="line">     checkBoth = <span class="keyword">true</span>; <span class="comment">//设置checkBoth为true</span></span><br><span class="line">     breakcheck_inner;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">//查询settings数据库中的secure表，获取用户设置的安装路径</span></span><br><span class="line">  intinstallPreference =</span><br><span class="line">        Settings.System.getInt(getApplicationContext()</span><br><span class="line">            .getContentResolver(),</span><br><span class="line">             Settings.Secure.DEFAULT_INSTALL_LOCATION,</span><br><span class="line">             PackageHelper.APP_INSTALL_AUTO);</span><br><span class="line">   <span class="keyword">if</span>(installPreference == PackageHelper.APP_INSTALL_INTERNAL) &#123;</span><br><span class="line">       prefer = PREFER_INTERNAL;</span><br><span class="line">       <span class="keyword">break</span> check_inner;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span>(installPreference == PackageHelper.APP_INSTALL_EXTERNAL) &#123;</span><br><span class="line">      prefer= PREFER_EXTERNAL;</span><br><span class="line">      breakcheck_inner;</span><br><span class="line">   &#125;</span><br><span class="line">   prefer =PREFER_INTERNAL;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">//判断外部存储空间是否为模拟的，这部分内容我们以后再介绍</span></span><br><span class="line">  finalboolean emulated = Environment.isExternalStorageEmulated();</span><br><span class="line">  <span class="keyword">final</span> FileapkFile = <span class="keyword">new</span> File(archiveFilePath);</span><br><span class="line">  booleanfitsOnInternal = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(checkBoth || prefer == PREFER_INTERNAL) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;<span class="comment">//检查内部存储空间是否足够大</span></span><br><span class="line">         fitsOnInternal = isUnderInternalThreshold(apkFile, threshold);</span><br><span class="line">      &#125; ......</span><br><span class="line">  &#125;</span><br><span class="line">  booleanfitsOnSd = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(!emulated &amp;&amp; (checkBoth || prefer == PREFER_EXTERNAL)) &#123;</span><br><span class="line">      <span class="keyword">try</span>&#123; <span class="comment">//检查外部存储空间是否足够大</span></span><br><span class="line">         fitsOnSd = isUnderExternalThreshold(apkFile);</span><br><span class="line">       &#125; ......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (prefer== PREFER_INTERNAL) &#123;</span><br><span class="line">      <span class="keyword">if</span>(fitsOnInternal) &#123;<span class="comment">//返回推荐安装路径为内部空间</span></span><br><span class="line">        <span class="keyword">return</span> PackageHelper.RECOMMEND_INSTALL_INTERNAL;</span><br><span class="line">      &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!emulated &amp;&amp; prefer == PREFER_EXTERNAL) &#123;</span><br><span class="line">      <span class="keyword">if</span>(fitsOnSd) &#123;<span class="comment">//返回推荐安装路径为外部空间</span></span><br><span class="line">        <span class="keyword">return</span> PackageHelper.RECOMMEND_INSTALL_EXTERNAL;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">if</span>(checkBoth) &#123;</span><br><span class="line">   <span class="keyword">if</span>(fitsOnInternal) &#123;<span class="comment">//如果内部存储满足条件，先返回内部空间</span></span><br><span class="line">       <span class="keyword">return</span> PackageHelper.RECOMMEND_INSTALL_INTERNAL;</span><br><span class="line">   &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!emulated &amp;&amp; fitsOnSd) &#123;</span><br><span class="line">         <span class="keyword">return</span> PackageHelper.RECOMMEND_INSTALL_EXTERNAL;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">...... <span class="comment">//到此，前几个条件都不满足，此处将根据情况返回一个明确的错误值</span></span><br><span class="line">     <span class="keyword">return</span> PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DCS的getMinimalPackageInfo函数为了得到一个推荐的安装路径做了不少工作，其中，各种安装策略交叉影响。这里总结一下相关的知识点：</p><ul><li>APK在AndroidManifest.xml中设置的安装点默认为AUTO，在具体对应时倾向内部空间。</li><li>用户在Settings数据库中设置的安装位置。</li><li>检查外部存储或内部存储是否有足够空间。</li></ul><p>(2)InstallArgs的copyApk函数分析<br>至此，我们已经得到了一个合适的安装位置（先略过Verification这一步）。下一步工作就由copyApk来完成。根据函数名可知该函数将完成APK文件的复制工作，此中会有蹊跷吗？来看下面的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[--&gt;PackageManagerService.java::InstallArgs.copyApk函数]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copyApk</span><span class="params">(IMediaContainerService imcs, booleantemp)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (temp)&#123;</span><br><span class="line">    <span class="comment">/*本例中temp参数为true，createCopyFile将在/data/app下创建一个临时文件。</span></span><br><span class="line"><span class="comment">    临时文件名为vmdl-随机数.tmp。为什么会用这样的文件名呢？</span></span><br><span class="line"><span class="comment">    因为PKMS通过Linux的inotify机制监控了/data/app,目录，如果新复制生成的文件名后缀</span></span><br><span class="line"><span class="comment">    为apk，将触发PKMS扫描。为了防止发生这种情况，这里复制生成的文件才有了</span></span><br><span class="line"><span class="comment">    如此奇怪的名字</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">   createCopyFile();</span><br><span class="line">  &#125;</span><br><span class="line">   FilecodeFile = <span class="keyword">new</span> File(codeFileName);</span><br><span class="line">   ......</span><br><span class="line">   ParcelFileDescriptor out = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     out =ParcelFileDescriptor.open(codeFile,</span><br><span class="line">                            ParcelFileDescriptor.MODE_READ_WRITE);</span><br><span class="line">     &#125;......</span><br><span class="line">     <span class="keyword">int</span> ret= PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       mContext.grantUriPermission(DEFAULT_CONTAINER_PACKAGE,</span><br><span class="line">                   packageURI,Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">       <span class="comment">//调用DCS的copyResource，该函数将执行复制操作，最终结果是/data/local/tmp</span></span><br><span class="line">       <span class="comment">//下的APK文件被复制到/data/app下，文件名也被换成vmdl-随机数.tmp</span></span><br><span class="line">       ret= imcs.copyResource(packageURI, out);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      ......<span class="comment">//关闭out，撤销URI授权</span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于临时文件，这里提供一个示例</p><p><img src="/2017/08/10/pm/20150803111034657.jpg" alt="临时文件"></p><p><code>/data/app</code>下有两个文件，第一个是正常的APK文件，第二个是<code>createCopyFile</code>生成的临时文件。</p><h2 id="2-4handleReturnCode分析"><a href="#2-4handleReturnCode分析" class="headerlink" title="2.4handleReturnCode分析"></a>2.4handleReturnCode分析</h2><p>在HandlerParams的startCopy函数中，handleStartCopy执行完之后，将调用handleReturnCode开展后续工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[--&gt;PackageManagerService.java::InstallParams.HandleParams]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleReturnCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//调用processPendingInstall函数，mArgs指向之前创建的FileInstallArgs对象</span></span><br><span class="line">        processPendingInstall(mArgs, mRet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processPendingInstall</span><span class="params">(finalInstallArgs args,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> intcurrentStatus)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//向mHandler中抛一个Runnable对象</span></span><br><span class="line">  mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mHandler.removeCallbacks(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//创建一个PackageInstalledInfo对象，</span></span><br><span class="line">        PackageInstalledInfo res = <span class="keyword">new</span> PackageInstalledInfo();</span><br><span class="line">        res.returnCode = currentStatus;</span><br><span class="line">        res.uid = -<span class="number">1</span>;</span><br><span class="line">        res.pkg = <span class="keyword">null</span>;</span><br><span class="line">        res.removedInfo = <span class="keyword">new</span> PackageRemovedInfo();</span><br><span class="line">        <span class="keyword">if</span>(res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">           <span class="comment">//1.调用FileInstallArgs的doPreInstall</span></span><br><span class="line">           args.doPreInstall(res.returnCode);</span><br><span class="line">           <span class="keyword">synchronized</span> (mInstallLock) &#123;</span><br><span class="line">               <span class="comment">//2.调用installPackageLI进行安装</span></span><br><span class="line">               installPackageLI(args, <span class="keyword">true</span>, res);</span><br><span class="line">           &#125;</span><br><span class="line">          <span class="comment">//3.调用FileInstallArgs的doPostInstall</span></span><br><span class="line">          args.doPostInstall(res.returnCode);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> update = res.removedInfo.removedPackage != <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">boolean</span> doRestore = (!update&amp;&amp; res.pkg != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    res.pkg.applicationInfo.backupAgentName!= <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">int</span> token;<span class="comment">//计算一个ID号</span></span><br><span class="line">        <span class="keyword">if</span>(mNextInstallToken &lt; <span class="number">0</span>) mNextInstallToken = <span class="number">1</span>;</span><br><span class="line">            token = mNextInstallToken++;</span><br><span class="line">            <span class="comment">//创建一个PostInstallData对象</span></span><br><span class="line">            PostInstallData data = <span class="keyword">new</span> PostInstallData(args, res);</span><br><span class="line">           <span class="comment">//保存到mRunningInstalls结构中，以token为key</span></span><br><span class="line">           mRunningInstalls.put(token, data);</span><br><span class="line">           <span class="keyword">if</span> (res.returnCode ==PackageManager.INSTALL_SUCCEEDED &amp;&amp; doRestore)</span><br><span class="line">           &#123;</span><br><span class="line">                  ......<span class="comment">//备份恢复的情况暂时不考虑</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(!doRestore) &#123;</span><br><span class="line">            <span class="comment">//5.抛一个POST_INSTALL消息给mHandler进行处理</span></span><br><span class="line">            Message msg = mHandler.obtainMessage(POST_INSTALL, token, <span class="number">0</span>);</span><br><span class="line">            mHandler.sendMessage(msg);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面代码可知，handleReturnCode主要做了4件事情：</p><ul><li>调用InstallArgs的doPreInstall函数，在本例中是FileInstallArgs的doPreInstall函数。</li><li>调用PKMS的installPackageLI函数进行APK安装，该函数内部将调用InstallArgs的doRename对临时文件进行改名。另外，还需要扫描此APK文件。此过程和之前介绍的“扫描系统Package”一节的内容类似。至此，该APK中的私有财产就全部被登记到PKMS内部进行保存了。</li><li>调用InstallArgs的doPostInstall函数，在本例中是FileInstallArgs的doPostInstall函数。</li><li>此时，该APK已经安装完成（不论失败还是成功），继续向mHandler抛送一个<code>POST_INSTALL</code>消息，该消息携带一个token，通过它可从mRunningInstalls数组中取得一个PostInstallData对象。<br><strong>提示</strong>对于FileInstallArgs来说，其doPreInstall和doPostInstall都比较简单</li></ul><p>这里介绍一下FileInstallArgs的doRename函数，它的功能是将临时文件改名，最终的文件的名称一般为“包名-数字.apk”。其中，数字是一个index，从1开始。<code>/data/app</code>目录下第一个文件的文件名。</p><h2 id="2-4-POST-INSTALL处理"><a href="#2-4-POST-INSTALL处理" class="headerlink" title="2.4 POST_INSTALL处理"></a>2.4 POST_INSTALL处理</h2><p>现在需要处理POST_INSTALL消息，因为adb install还等着安装结果.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[--&gt;PackageManagerService.java::doHandleMessage函数]</span></span><br><span class="line">......<span class="comment">//接前面的switch/case</span></span><br><span class="line"><span class="keyword">case</span> POST_INSTALL: &#123;</span><br><span class="line">  PostInstallData data = mRunningInstalls.get(msg.arg1);</span><br><span class="line">  mRunningInstalls.delete(msg.arg1);</span><br><span class="line">  booleandeleteOld = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (data!= <span class="keyword">null</span>) &#123;</span><br><span class="line">      InstallArgs args = data.args;</span><br><span class="line">      PackageInstalledInfo res = data.res;</span><br><span class="line">      <span class="keyword">if</span>(res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">           res.removedInfo.sendBroadcast(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">           Bundle extras = <span class="keyword">new</span> Bundle(<span class="number">1</span>);</span><br><span class="line">           extras.putInt(Intent.EXTRA_UID, res.uid);</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">boolean</span> update = res.removedInfo.removedPackage != <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">if</span> (update) &#123;</span><br><span class="line">                extras.putBoolean(Intent.EXTRA_REPLACING, <span class="keyword">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//发送PACKAGE_ADDED广播</span></span><br><span class="line">           sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,</span><br><span class="line">                    res.pkg.applicationInfo.packageName,extras, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">if</span> (update) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果是APK升级，那么发送PACKAGE_REPLACE和MY_PACKAGE_REPLACED广播。</span></span><br><span class="line"><span class="comment">            二者不同之处在于PACKAGE_REPLACE将携带一个extra信息</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">      &#125;</span><br><span class="line">      Runtime.getRuntime().gc();</span><br><span class="line">      <span class="keyword">if</span>(deleteOld) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mInstallLock) &#123;</span><br><span class="line">          <span class="comment">//调用FileInstallArgs的doPostDeleteLI进行资源清理</span></span><br><span class="line">          res.removedInfo.args.doPostDeleteLI(<span class="keyword">true</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(args.observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 向pm通知安装的结果</span></span><br><span class="line">        args.observer.packageInstalled(res.name, res.returnCode);</span><br><span class="line">      &#125; ......</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h1 id="3-APK-安装流程总结"><a href="#3-APK-安装流程总结" class="headerlink" title="3.APK 安装流程总结"></a>3.APK 安装流程总结</h1><p>没想到APK的安装流程竟然如此复杂，其目的无非<strong>是让APK中的私人财产公有化</strong>。相比之下，在PKMS构造函数中进行公有化改造就非常简单。另外，如果考虑安装到SD卡的处理流程，那么APK的安装将会更加复杂。</p><p>这里要总结APK安装过程中的几个重要步骤</p><p><img src="/2017/08/10/pm/20150803111058786.png" alt="apk install"><br>列出以下内容：</p><ul><li>安装APK到内部存储空间这一工作流程涉及的主要对象包括：PKMS、DCS、InstallParams和FileInstallArgs。</li><li>此工作流程中每个对象涉及到的关键函数。</li><li>对象之间的调用通过虚线表达，调用顺序通过①②③等标明。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;APK的安装及相关处理流程.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android组件" scheme="http://yoursite.com/tags/Android%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>gradle任务和插件</title>
    <link href="http://yoursite.com/2017/08/04/gradle2/"/>
    <id>http://yoursite.com/2017/08/04/gradle2/</id>
    <published>2017-08-04T01:59:34.000Z</published>
    <updated>2019-02-02T11:21:31.746Z</updated>
    
    <content type="html"><![CDATA[<p>多种任务创建方式，如何访问任务的方法和属性等信息，对任务进行分组、排序，以及任务一些规则性知识。</p><a id="more"></a><h1 id="1-gradle任务"><a href="#1-gradle任务" class="headerlink" title="1.gradle任务"></a>1.gradle任务</h1><h2 id="1-1多种创建方式"><a href="#1-1多种创建方式" class="headerlink" title="1.1多种创建方式"></a>1.1多种创建方式</h2><p>各种方式都依赖于Project提供快捷方法以及TaskContainer提供相关的create方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//第一种任务名方式创建任务</span><br><span class="line">def Task createTask1=task(createTask1) //task(一个对象？)</span><br><span class="line"></span><br><span class="line">createTask1.doLast&#123;</span><br><span class="line">println &quot;原型：Task task(String name)&quot;</span><br><span class="line">&#125;</span><br><span class="line">//第二种任务名+配置该任务Map对象创建</span><br><span class="line">def task createTask2=task(createTask,group:BasePlugin.BUILD_GROUP)</span><br><span class="line">createTask2.doLast &#123;</span><br><span class="line">println &quot;原型：Task task(Map&lt;String,?&gt;args,String name)&quot;</span><br><span class="line">&#125;</span><br><span class="line">//第三种，闭包方式创建</span><br><span class="line">task createTask3&#123;</span><br><span class="line">description &apos;演示任务创建&apos;</span><br><span class="line">doLast&#123;</span><br><span class="line">println &quot;任务描述$&#123;description&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//第四种</span><br><span class="line">tasks.create(&apos;createTask4&apos;)&#123;</span><br><span class="line">description &apos;演示任务创建&apos;</span><br><span class="line">doLast&#123;</span><br><span class="line">println &quot;任务描述$&#123;description&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式Map起到配置作用：</p><p>Task参数Map的可用配置</p><table><thead><tr><th>配置项</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>type</td><td>基于存在Task创建，类似继承</td><td>DefaultTask</td></tr><tr><td>override</td><td>是否替换存在Task，和type结合使用</td><td>false</td></tr><tr><td>dependsOn</td><td>用于配置任务的依赖</td><td>[]</td></tr><tr><td>action</td><td>添加任务中一个Action或者一个闭包</td><td>null</td></tr><tr><td>description</td><td>配置任务的描述</td><td>null</td></tr><tr><td>group</td><td>配置任务分组</td><td>null</td></tr></tbody></table><h2 id="1-2多种访问的方式"><a href="#1-2多种访问的方式" class="headerlink" title="1.2多种访问的方式"></a>1.2多种访问的方式</h2><p>1.将任务分配给一个变量，然后用该变量进行操作。任务容器可以这样访问：<code>tasks[&#39;createTask4&#39;].doLast{}</code></p><h2 id="1-3任务分组和描述"><a href="#1-3任务分组和描述" class="headerlink" title="1.3任务分组和描述"></a>1.3任务分组和描述</h2><p>任务分组可以更明确分类任务.<code>myTask.group=BasePlugin.BUILD_GROUP</code>,这样在查看<code>gradle tasks</code>更清晰。</p><p>描述，<code>description</code>前面已经说明过。</p><h2 id="1-4-lt-lt-操作符"><a href="#1-4-lt-lt-操作符" class="headerlink" title="1.4 &lt;&lt;操作符"></a>1.4 <code>&lt;&lt;</code>操作符</h2><p><code>&lt;&lt;</code>操作符在Gradle的Task是doLast方法短标记形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task(hello)&lt;&lt;&#123;</span><br><span class="line">println &apos;helloTask do last&apos;</span><br><span class="line">&#125;</span><br><span class="line">task(hello).doLast&#123;</span><br><span class="line">println &apos;hello doLast&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5任务执行"><a href="#1-5任务执行" class="headerlink" title="1.5任务执行"></a>1.5任务执行</h2><p>Task执行任务可分为：Task之前执行(doFirst)、Task本身执行(doSelf)以及Task之后执行(doLast)</p><h2 id="1-6任务排序"><a href="#1-6任务排序" class="headerlink" title="1.6任务排序"></a>1.6任务排序</h2><p>通过设置任务的<code>shouldRunAfter</code>和<code>mustRunAfter</code>两个方法。有用的，比如先执行单元测试，再执行打包，保证APP质量。</p><ul><li>taskB.shouldRunAfter(taskA)应该B是在A之后执行，但不一定。</li><li>taskB.mustRunAfter(taskA)必须这样顺序。</li></ul><h2 id="1-7任务启动和禁用"><a href="#1-7任务启动和禁用" class="headerlink" title="1.7任务启动和禁用"></a>1.7任务启动和禁用</h2><p>Task的enable属性控制，默认为true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task hello2&#123;</span><br><span class="line">&#125;</span><br><span class="line">hello2.enabled=false</span><br></pre></td></tr></table></figure><h2 id="1-8任务onlyIf断言"><a href="#1-8任务onlyIf断言" class="headerlink" title="1.8任务onlyIf断言"></a>1.8任务onlyIf断言</h2><p>断言就是一个条件表达式。接受一个闭包作为参数，闭包返回true则该任务执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">final String BUILD_APPS_ALL=&quot;all&quot;</span><br><span class="line">final String BUILD_APPS_SHOUFA =&quot;shoufa&quot;</span><br><span class="line">final String BUILD_APPS_EXCLUDE_SHOUFA=&quot;exclude_shoufa&quot;</span><br><span class="line">task release1&lt;&lt;&#123;</span><br><span class="line">println &quot;release1&quot;</span><br><span class="line">&#125;</span><br><span class="line">task release2&lt;&lt;&#123;</span><br><span class="line">println &quot;release2&quot;</span><br><span class="line">&#125;</span><br><span class="line">task release3&lt;&lt;&#123;</span><br><span class="line">println &quot;release3&quot;</span><br><span class="line">&#125;</span><br><span class="line">task build&#123;</span><br><span class="line">group BasePlugin.BUILD_GROUP</span><br><span class="line">description &quot;打包渠道&quot;</span><br><span class="line">&#125;</span><br><span class="line">build.dependsOn release1 release2 release3 </span><br><span class="line">release1.onlyIf&#123;</span><br><span class="line">def execute =false</span><br><span class="line">if(project.hasProperty(&quot;build_apps&quot;))&#123;</span><br><span class="line">Object buildApps=project.property(&quot;build_apps&quot;)</span><br><span class="line">if(BUILD_APPS_SHOUFA.equals(buildApps)||BUILD_APPS_ALL.equals(buildApps))&#123;</span><br><span class="line">execute=true</span><br><span class="line">&#125;else&#123;</span><br><span class="line">execute=false</span><br><span class="line">&#125;</span><br><span class="line">execute</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//每个release都可以这样判断</span><br></pre></td></tr></table></figure><p>通过<code>build_apps</code>属性来控制打包渠道包：</p><p>1.打包所有渠道包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew -Pbuild_apps=all :example48:build</span><br></pre></td></tr></table></figure><p>命令行中<code>-P</code>意思为project指定属性值。</p><h1 id="2-Gradle插件"><a href="#2-Gradle插件" class="headerlink" title="2.Gradle插件"></a>2.Gradle插件</h1><p>Gradle本身提供一个基本概念和整体核心的框架，其他用于描述使用真实场景逻辑的都以插件扩展的方式实现。</p><h2 id="2-1插件的作用"><a href="#2-1插件的作用" class="headerlink" title="2.1插件的作用"></a>2.1插件的作用</h2><p>插件应用到项目中，会扩展很多功能。</p><ul><li>1.可以添加任务到你项目中完成比如测试、编译、打包</li><li>2.可以添加依赖配置到项目中，比如第三方库等</li><li>3.向项目中添加扩展属性、方法等。比如android{}配置块就是AndroidGradle插件一个扩展。</li><li>4.对项目进行进一步约束。约定<code>src/main/java</code>目录下是我们源码存放位置。</li></ul><h2 id="2-2应用一个插件"><a href="#2-2应用一个插件" class="headerlink" title="2.2应用一个插件"></a>2.2应用一个插件</h2><p>插件应用都是通过<code>Project.apply()</code>方法完成的，apply方法有几种，插件也分为二进制插件和脚本插件。</p><h3 id="2-2-1二进制插件"><a href="#2-2-1二进制插件" class="headerlink" title="2.2.1二进制插件"></a>2.2.1二进制插件</h3><p>二进制插件实现了<code>org.gralde.api.Plugin</code>接口插件，可以有<code>plugin id</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//应用一个java插件,其中java就是plugin id(唯一的)</span><br><span class="line">apply plugin:&apos;java&apos;</span><br><span class="line"></span><br><span class="line">//java是一个短名称，对应类型org.gradle.api.plugins.JavaPlugin</span><br><span class="line">apply plugin:org.gradle.api.Plugin.JavaPlugin</span><br><span class="line"></span><br><span class="line">//一般org.gradle.api.Plugins默认的导入</span><br><span class="line">apply plugin:JavaPlugin</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>二进制插件一般打包到一个jar包独立发布的，比如我们自定义插件，plugin id最好用权限定名称，这个plugin id不会重复</p><h3 id="2-2-2应用脚本插件"><a href="#2-2-2应用脚本插件" class="headerlink" title="2.2.2应用脚本插件"></a>2.2.2应用脚本插件</h3><p><strong>就是把另一个脚本文件加载过来</strong>。from可以是一个脚本文件或者HTTP URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//build.gradle文件</span><br><span class="line">apply from:&apos;version.gradle&apos;</span><br><span class="line">task helloT&lt;&lt;&#123;</span><br><span class="line">println &quot;$&#123;versionName&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//version.gradle文件</span><br><span class="line">ext &#123;</span><br><span class="line">versionName =&apos;1.0.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-apply其他用法"><a href="#2-2-3-apply其他用法" class="headerlink" title="2.2.3 apply其他用法"></a>2.2.3 apply其他用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//闭包形式</span><br><span class="line">apply &#123;</span><br><span class="line">plugin &apos;java&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Action方式</span><br><span class="line">apply(new Action&lt;ObjectConfigurationAction&gt;()&#123;</span><br><span class="line">@override</span><br><span class="line">void execute(ObjectConfigurationActio action)&#123;</span><br><span class="line">objectConfigureAction.plugin(&apos;java&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-3使用第三方插件"><a href="#2-3使用第三方插件" class="headerlink" title="2.3使用第三方插件"></a>2.3使用第三方插件</h2><p>第三方发布的作为jar的二进制插件，必须在<code>buildscript{}</code>里配置其classpath才能使用，这个不像Gradle提供内置插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//Android Gradle插件</span><br><span class="line">buildscript&#123;</span><br><span class="line">respositories &#123;</span><br><span class="line">jcenter()</span><br><span class="line">&#125;</span><br><span class="line">dependncies&#123;</span><br><span class="line">classpath &apos;com.android.tools.build:gradle:1.5.0&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>buildscript{}</code>块是构建项目之前，为项目进行前期准备和初始化相关配置依赖地方，配置所需要依赖，就可以使用应用插件了<code>apply plugin: &#39;com.android.application&#39;</code></p><h2 id="2-4自定义插件"><a href="#2-4自定义插件" class="headerlink" title="2.4自定义插件"></a>2.4自定义插件</h2><p>自定义插件涉及知识点很多，比如创建任务、创建方法、进行约定等。<br>下面介绍创建一个任务为例，进行自定义插件介绍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apply plugin:MyPlugin</span><br><span class="line">class MyPlugin implements Plugin&lt;Project&gt;&#123;</span><br><span class="line">void apply(Project project)&#123;</span><br><span class="line">project.task(&apos;myTask&apos;)&lt;&lt;&#123;</span><br><span class="line">println &quot;自定义插件创建的任务&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以执行<code>./gralew myTask</code>来执行任务(这个任务通过自定义插件创建的)</p><h2 id="2-5发布插件"><a href="#2-5发布插件" class="headerlink" title="2.5发布插件"></a>2.5发布插件</h2><p>1.创建一个Groovy工程，然后配置插件开发所需的依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apply plugin:&apos;groovy&apos;</span><br><span class="line">dependencies &#123;</span><br><span class="line">compile gradleApi()</span><br><span class="line">compile localGroovy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.然后实现插件类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.githubb.rujews.plugins</span><br><span class="line"></span><br><span class="line">import org.gradle.api.Plugin</span><br><span class="line">import org.gradle.api.Project</span><br><span class="line"></span><br><span class="line">class MyPlugin implements Plugin&lt;Project&gt;&#123;</span><br><span class="line">@override</span><br><span class="line">void apply(Project target)&#123;</span><br><span class="line">target.task(&apos;myTask&apos;)&lt;&lt;&#123;</span><br><span class="line">println &quot;这是自定义插件创建的任务&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Gradle通过META-INF里properties文件来发现对应插件实现类的。首先确定一个在src/main/resource/META-INF/gradle-plugins/目录先建立properties文件<code>com.github.rujews.plugins.myTask.properties</code>添加一行内容<code>implementation-class=com.github.rujews.plugins.MyTask</code></p><p>配置好久可以给其他人使用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多种任务创建方式，如何访问任务的方法和属性等信息，对任务进行分组、排序，以及任务一些规则性知识。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android脚本" scheme="http://yoursite.com/tags/Android%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>gradle-入门</title>
    <link href="http://yoursite.com/2017/08/03/gradle1/"/>
    <id>http://yoursite.com/2017/08/03/gradle1/</id>
    <published>2017-08-03T01:06:31.000Z</published>
    <updated>2019-02-02T11:21:31.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-介绍"><a href="#0-介绍" class="headerlink" title="0 介绍"></a>0 介绍</h1><p>Gradle是一个构建系统工具，DSL基于Groovy实现。Gradle构建大部分通过插件方式来实现，内置插件不能满足，可以自己自定义插件。DSL（Domain Specific Language）领域特定语言。java是一种通用语言。软件开发大师Martin Flower&lt;&lt;领域特定语言&gt;&gt;介绍。<br><a id="more"></a></p><h2 id="1-Gradle简介"><a href="#1-Gradle简介" class="headerlink" title="1.Gradle简介"></a>1.Gradle简介</h2><h2 id="1-1-Hello-world"><a href="#1-1-Hello-world" class="headerlink" title="1.1 Hello world"></a>1.1 Hello world</h2><p>建立文件build.gradle，内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//build.gradle</span><br><span class="line">task hello&#123;</span><br><span class="line">doLast&#123;</span><br><span class="line">println &apos;hello world&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终端在该文件目录下执行,gradle未指定文件<code>-d</code>默认执行文件是build.gradle：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$gradle -q hello</span><br><span class="line">输出：hello world</span><br></pre></td></tr></table></figure><ul><li>其中hello是一个task</li><li>doLast是一个Action(task会执行会完毕，回调doLast)</li><li><code>-q</code>控制gradle输出日志级别。</li></ul><h2 id="1-2Graddle-Wrapper"><a href="#1-2Graddle-Wrapper" class="headerlink" title="1.2Graddle Wrapper"></a>1.2Graddle Wrapper</h2><p><code>Wrapper</code>就是对Graddle进行一层包装，便于统一Gradle构建的版本，避免版本不同冲突。项目开发都是以wrapper方式开发的(windows 下面批处理脚本，linux就是一个shell)。</p><p>当Wapper启动Graddle时候，Wapper会检查Gradle有么有被下载关联，没有下载，则从配置地址从官方库下载(一般是Gradle官方库)，这样不需要手动配置，很方便。wapper需要添加到git中的，这样统一开发环境配置。</p><h3 id="1-2-1生成Wapper"><a href="#1-2-1生成Wapper" class="headerlink" title="1.2.1生成Wapper"></a>1.2.1生成Wapper</h3><p>Gradle提供了一个<code>Wapper task</code>帮助生成Wapper所需要目录文件。(利用task来建立，这个task叫wapper).<code>$graddle wrapper</code></p><p>生成目录如下：</p><p><img src="/2017/08/03/gradle1/01.png" alt="wapper目录"></p><ul><li>gradlew和gradlew.bat分别是Linux和Window脚本，和gradle一样。</li><li>gradle-wrapper.jar具体业务逻辑实现的jar包，gradlew最终使用java执行这个jar包执行相关操作。</li><li>graddle-wrapper.properties是配置文件，用于配置哪个版本的Gradle等。<ul><li>其中distributionUrl是Gradle发行版压缩包的下载地址(看能否下载，避免卡主)</li></ul></li></ul><h3 id="1-2-2自定义Wapper"><a href="#1-2-2自定义Wapper" class="headerlink" title="1.2.2自定义Wapper"></a>1.2.2自定义Wapper</h3><p>指定自己需要的一些信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//继承Wrapper</span><br><span class="line">task wrapper(type:Wrapper)&#123;</span><br><span class="line">gradleVersion=&apos;2.4&apos;</span><br><span class="line">distributionUrl=&quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3日志"><a href="#1-3日志" class="headerlink" title="1.3日志"></a>1.3日志</h2><p>日志也分几个级别：ERROR,QUIET,WARNING,LIFECYCLE,INFO,DEBUG.可以通过命令行来控制输出级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//输出QUITE级别及之上日志信息-i -d</span><br><span class="line">$gradle -q tasks</span><br></pre></td></tr></table></figure><p>打开堆栈信息可通过：<code>-s</code>输出关键字堆栈信息。<code>-S</code>输出所有的堆栈信息。</p><p>使用日志调试信息。Project的getLogger()方法获得的Logger对象实例logger来输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">logger.quiet();</span><br><span class="line">logger.error();</span><br><span class="line">logger.warn();</span><br><span class="line">logger.lifecycle();</span><br><span class="line">logger.info();</span><br><span class="line">logger.debug();</span><br></pre></td></tr></table></figure><h2 id="1-4命令行"><a href="#1-4命令行" class="headerlink" title="1.4命令行"></a>1.4命令行</h2><p>AndrodStudio中双击Task就可以执行了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//帮助</span><br><span class="line">./gradlew ? </span><br><span class="line">./gradlew -h</span><br><span class="line">./gradlew -help</span><br><span class="line">//查看所有可执行的task</span><br><span class="line">./gradlew tasks</span><br><span class="line"></span><br><span class="line">//help task</span><br><span class="line">./gradlew help --task</span><br><span class="line"></span><br><span class="line">//强制刷新依赖</span><br><span class="line">./gradlew --refresh-dependencies assemable</span><br><span class="line"></span><br><span class="line">//执行多任务.任务之间空格隔开即可</span><br><span class="line">./gradlew clean jar</span><br></pre></td></tr></table></figure><p><strong>通过任务名字缩写执行</strong>任务用驼峰书写：比如connectCheck，执行时使用<code>./gradlew connectCheck</code>,可简单写成<code>./graddle cc</code></p><h1 id="2-Groovy基础"><a href="#2-Groovy基础" class="headerlink" title="2.Groovy基础"></a>2.Groovy基础</h1><p>Groovy基于JVM虚拟机的一种动态语言，完全兼容java，基础增加很多动态类型和灵活特性，<code>支持闭包</code>，支持DSL，<strong>是一个灵活动态脚本语言</strong>.</p><h2 id="2-1字符串"><a href="#2-1字符串" class="headerlink" title="2.1字符串"></a>2.1字符串</h2><p>分号不是必须的，单引号和双引号都可以表示字符串。类型为<code>java.lang.String</code>.单引号没有运算能力，双引号有运算能力。</p><h2 id="2-2集合"><a href="#2-2集合" class="headerlink" title="2.2集合"></a>2.2集合</h2><p>常见集合List，Set，Map和Queue。</p><h3 id="2-2-1List"><a href="#2-2-1List" class="headerlink" title="2.2.1List"></a>2.2.1List</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">task printList&lt;&lt;&#123;</span><br><span class="line">def numList=[1,2,3,4,5];</span><br><span class="line">println numList.getClass().name</span><br><span class="line">//访问最后一个元素</span><br><span class="line">println numList[-1]</span><br><span class="line">//访问2到4</span><br><span class="line">println numList[1..3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>List方便的迭代操作，each方法。接受一个闭包作为参数，访问List每个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task printList&lt;&lt;&#123;</span><br><span class="line">numList.each&#123;</span><br><span class="line">println it;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>it变量是正在迭代的元素。</p><h3 id="2-2-2Map"><a href="#2-2-2Map" class="headerlink" title="2.2.2Map"></a>2.2.2Map</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">task printlnMap&lt;&lt;&#123;</span><br><span class="line">def map1=&#123;&apos;width&apos;:1024,&apos;height&apos;:768&#125;</span><br><span class="line">println map1.height</span><br><span class="line">println map1[&apos;width&apos;]</span><br><span class="line">map1.each&#123;</span><br><span class="line">println&quot;Key:$&#123;it.key&#125;,Value:$&#123;it.value&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-方法-闭包演变"><a href="#2-3-方法-闭包演变" class="headerlink" title="2.3.方法(闭包演变)"></a>2.3.方法(闭包演变)</h2><ul><li>括号可以省略。<code>invokeMethod(parm1,parm2)</code>变成<code>invokeMethod parm2,parm2</code></li><li>return可以不写。当没有return，最后一句作为返回值。</li><li>代码块作为参数传递。</li></ul><p>代码块(<strong>一段被花括号包围的代码</strong>)，其实就是<code>闭包</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//呆板写法其实就是</span><br><span class="line">numList.each(&#123;println it&#125;)</span><br><span class="line"></span><br><span class="line">//格式化一下代码</span><br><span class="line">numList.each(&#123;</span><br><span class="line">println it</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//Groovy规定，如果方法最后一个参数是闭包，可以将放到方法外面</span><br><span class="line">numList.each()&#123;</span><br><span class="line">println</span><br><span class="line">&#125;</span><br><span class="line">//然后方法可以省略变成这个样子</span><br><span class="line">numList.each&#123;</span><br><span class="line">println it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-JavaBean"><a href="#2-4-JavaBean" class="headerlink" title="2.4 JavaBean"></a>2.4 JavaBean</h2><p>JavaBean不得不使用setter/getter方法，使用繁琐。Groovy很大改善。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">task helloJavaBean&#123;</span><br><span class="line">Person p=new Persion();</span><br><span class="line">println &quot;名字是 $&#123;p.name&#125;&quot;</span><br><span class="line">p.name=&quot;张三&quot;</span><br><span class="line">println &quot;名字是 $&#123;p.name&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">class Person&#123;</span><br><span class="line">private String name</span><br><span class="line">public int getAge()&#123;</span><br><span class="line">12</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没赋值输出是null，赋值后输出为张三。</p><h2 id="2-5闭包"><a href="#2-5闭包" class="headerlink" title="2.5闭包"></a>2.5闭包</h2><h3 id="2-5-1初始闭包"><a href="#2-5-1初始闭包" class="headerlink" title="2.5.1初始闭包"></a>2.5.1初始闭包</h3><p><code>it</code>变量的由来.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">task helloClosure&lt;&lt;&#123;</span><br><span class="line">//使用我们自定义的闭包</span><br><span class="line">customEach&#123;</span><br><span class="line">println it</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">def customEach(closure)&#123;</span><br><span class="line">//模拟一个有10个元素集合</span><br><span class="line">for(int i in 1..10)&#123;</span><br><span class="line">closure(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果close只有一个参数就是我们的<code>it</code>变量。</p><h3 id="2-5-2向闭包传递参数"><a href="#2-5-2向闭包传递参数" class="headerlink" title="2.5.2向闭包传递参数"></a>2.5.2向闭包传递参数</h3><p>当一个参数默认参数就是it，当多个参数时，it不能表示了，我们需要一一列举出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">task helloClosure&lt;&lt;&#123;</span><br><span class="line">//多个参数</span><br><span class="line">eachMap&#123;k,v-&gt;</span><br><span class="line">println &quot;$&#123;k&#125; is $&#123;v&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">def eachMap(closure)&#123;</span><br><span class="line">def map1=&#123;&apos;name&apos;:&quot;张三&quot;,&apos;age&apos;:&quot;18&quot;&#125;</span><br><span class="line">map1.each&#123;</span><br><span class="line">//两个参数，为一个map。则相当于一个参数</span><br><span class="line">closure&#123;it.key,it.value&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-3闭包委托"><a href="#2-5-3闭包委托" class="headerlink" title="2.5.3闭包委托"></a>2.5.3闭包委托</h3><p>Groovy闭包强大在于支持闭包方法的委托。Groovy闭包有<code>thisObject</code>，<code>owner</code>，<code>delegate</code>三个属性。当在闭包调用的方法时候，用来决定哪个对象来处理，默认情况下delegate和owner是相等的，但是delage是可以被修改的。闭包很多功能通过修改delegate实现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">task helloDelegate&lt;&lt;&#123;</span><br><span class="line">new Delegate().test&#123;</span><br><span class="line">println &quot;$&#123;thisObeject.getClass()&#125;&quot;</span><br><span class="line">println &quot;$&#123;owner.getClass()&#125;&quot;</span><br><span class="line">println &quot;$&#123;delegate.getClass()&#125;&quot;</span><br><span class="line">method1()</span><br><span class="line">it.methods1()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">def method1()&#123;</span><br><span class="line">println &quot;$&#123;this.getClass()&#125; in root&quot;</span><br><span class="line">println &quot;method1 in root&quot;</span><br><span class="line">&#125;</span><br><span class="line">class Delegate&#123;</span><br><span class="line">def method1()&#123;</span><br><span class="line">println &quot;delegate this $&#123;this.getClass()&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">def test(Closure&lt;Delegate&gt; closure)&#123;</span><br><span class="line">closure(this)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包内方法处理顺序是:<code>thisObject</code>&gt;<code>owner</code>&gt;<code>delegate</code>.</p><p>在DSL，中一般指定delegate为当前的it，闭包内就可以对该it进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">task configClosure&lt;&lt;&#123;</span><br><span class="line">person&#123;</span><br><span class="line">personName=&quot;张三&quot;</span><br><span class="line">personAge=20</span><br><span class="line">dumpPerson()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class person&#123;</span><br><span class="line">String personName</span><br><span class="line">int personAge</span><br><span class="line">def dumpPerson()&#123;</span><br><span class="line">println &quot; name:$&#123;personName&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">def person(Closure&lt;Person&gt; closure)&#123;</span><br><span class="line">Person p=new Person()</span><br><span class="line">closure.delegate=p</span><br><span class="line">//委托模式优先</span><br><span class="line">closure.setResolveStragegy(Closure.DELEGATE_FIRST)</span><br><span class="line">closure(p)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>委托对象为当前创建的Person实例，设置委托模式优先。在使用person方法创建一个Person实例时，闭包里可以直接对Person实例配置。我们Gralde中task创建一个Task用法很像。</p><p>Gradle也基本使用delegate方式使用闭包进行配置和操作。</p><h1 id="3-Gradle构建脚本"><a href="#3-Gradle构建脚本" class="headerlink" title="3.Gradle构建脚本"></a>3.Gradle构建脚本</h1><h2 id="3-1Setting文件"><a href="#3-1Setting文件" class="headerlink" title="3.1Setting文件"></a>3.1Setting文件</h2><p>默认名字<code>settings.gradle</code>是一个设置文件，初始化以及<code>工程树的配置</code>，在根目录中。project和module的概念。一个module只有在settings文件中配置才被gradle构建识别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rootProject.name=&quot;book&quot;</span><br><span class="line">include &apos;:example02&apos;</span><br><span class="line">project().projectDir=new File(rootDir,&apos;chapter01/example02&apos;)</span><br></pre></td></tr></table></figure><ul><li>配置子项目<code>include &#39;:example02&#39;</code></li><li>指定子项目路径<code>project().projectDir</code>，不执行默认是当前目录。</li></ul><h2 id="3-2Build文件"><a href="#3-2Build文件" class="headerlink" title="3.2Build文件"></a>3.2Build文件</h2><p>每个project都有一个build文件(子项目也是)，该文件为<code>project入口</code>,可以针对Project进行配置，比如，<code>配置版本</code>，<code>需要哪些插件</code>，<code>依赖哪些库</code>等.</p><p>在root Project可以对child Project进行统一配置。比如应用插件，依赖Maven中心库等。可进行下面配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//配置所有child project仓库为jcenter</span><br><span class="line">subprojects&#123;</span><br><span class="line">repositories&#123;</span><br><span class="line">jcenter()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发java工程，很多小模块，每个模块也都是一个java工程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">subprojects&#123;</span><br><span class="line">apply plugin: &apos;java&apos;</span><br><span class="line">repositories&#123;</span><br><span class="line">jcenter()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>allprojects方法对所有的项目进行配置。<strong>subprojects和allprojects其实是两个方法</strong>，接受一个<code>闭包</code>作为参数，对所有工程进行遍历，遍历过程中调用我们自定义的闭包，闭包里配置、打印、输出或修改Project属性都可以。<strong>闭包</strong>就是个函数?将整个函数整体进行声明一个函数指针进行传递。这个函数指针模板类<code>Closure&lt;&gt;</code>，调用该函数指针方法<code>closure(parm1,parm2)</code> </p><h2 id="3-3Project及tasks"><a href="#3-3Project及tasks" class="headerlink" title="3.3Project及tasks"></a>3.3Project及tasks</h2><p><strong>project</strong>可以有很多，一个project用于生成jar包，定义另一个用于生成war包，可以定义一个发布上传war包等。最后一个个project组成整个Gradle构建。</p><p>一个project又包含多个task。<strong>task</strong>就是一个操作，一个原子性操作，比如打个jar包，复制一个文件，编译一次java代码，上传一个jar到Maven中心库。</p><h3 id="3-3-1建一个任务"><a href="#3-3-1建一个任务" class="headerlink" title="3.3.1建一个任务"></a>3.3.1建一个任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">task customTask1&#123;</span><br><span class="line">doFirst&#123;</span><br><span class="line">println &apos;customTask1:doFirst&apos;</span><br><span class="line">&#125; </span><br><span class="line">doLast&#123;</span><br><span class="line">println &apos;customTaks1:doLast&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Task其实是Project对象一个函数，原型<code>create(String name,Closure configureClosure)</code></li><li>customTask1是一个任务名字，可以自定义</li><li>第二个参数是一个闭包，最后一个参数是闭包，可以省略放外面。</li></ul><p>还可以通过TaskContainer创建任务。Project对象已经帮我们定义好了一个TaskContainer,就是<code>tasks</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tasks.create(&quot;customTask2&quot;)&#123;</span><br><span class="line">doFirst&#123;</span><br><span class="line">println &apos;customTask2:doFirst&apos;</span><br><span class="line">&#125; </span><br><span class="line">doLast&#123;</span><br><span class="line">println &apos;customTaks2:doLast&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前创建<code>customTask1</code>效果一样，只是创建方式不同。</p><h3 id="3-3-2任务依赖"><a href="#3-3-2任务依赖" class="headerlink" title="3.3.2任务依赖"></a>3.3.2任务依赖</h3><p>任务由依赖关系。哪些执行完成后，其他任务才能执行。jar任务依赖于compile，install任务依赖于package任务进行打包生成apk。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">task ex35Hello&lt;&lt;&#123;</span><br><span class="line">println &apos;hello&apos;</span><br><span class="line">&#125;</span><br><span class="line">task ex35Main(dependsOn:ex35Hello)&#123;</span><br><span class="line">doLast&#123;</span><br><span class="line">println &apos;main&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先执行hello，后执行main。</p><p>还可以写多个依赖关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task ex35MultiTask&#123;</span><br><span class="line">dependsOn ex35Hello,ex35World</span><br><span class="line">doLast&#123;</span><br><span class="line">printl &apos;multiTask&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-3任务间交互"><a href="#3-3-3任务间交互" class="headerlink" title="3.3.3任务间交互"></a>3.3.3任务间交互</h3><p>和变量一样，要使用任务名操作任务，必须先声明，因为脚本是顺序执行的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">task ex36Hello&lt;&lt;&#123;</span><br><span class="line">println &apos;doLast1&apos;</span><br><span class="line">&#125;</span><br><span class="line">ex36Hello.doFirst&#123;</span><br><span class="line">println &apos;doFirst1&apos;</span><br><span class="line">&#125;</span><br><span class="line">ex36Hello.doLast&#123;</span><br><span class="line">println &apos;dowLast2&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以验证是否具有某个属性：<code>project.hasProperty(&#39;ex36Hello&#39;)</code></p><h2 id="3-4自定义属性"><a href="#3-4自定义属性" class="headerlink" title="3.4自定义属性"></a>3.4自定义属性</h2><p>Project和Task都允许用户添加额外的自定义属性，添加额外的属性，<code>ext</code>属性来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//自定义一个Project属性</span><br><span class="line">ext.age=16</span><br><span class="line"></span><br><span class="line">//通过代码块project属性</span><br><span class="line">ext&#123;</span><br><span class="line">phone=13345</span><br><span class="line">address=&apos;&apos;</span><br><span class="line">&#125;</span><br><span class="line">task ex37CustomProperty&lt;&lt;&#123;</span><br><span class="line">println &quot;年龄：$&#123;age&#125;&quot;</span><br><span class="line">println &quot;电话是:$&#123;phone&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义属性比局部变量有更广泛的作用域，可以跨Project，跨Task访问这些自定义属性。<strong>只要能访问属性所属对象就能访问这些属性</strong></p><p>自定义属性还可以SourceSet中，当使用productFlavors定义多个渠道，还会增加很多的SourceSet:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;java&apos;</span><br><span class="line">//自定义一个project属性</span><br><span class="line">ext.age=18</span><br><span class="line"></span><br><span class="line">//通过代码同时自定义多个属性</span><br><span class="line">ext &#123;</span><br><span class="line">phone=1334512</span><br><span class="line">address=&apos;&apos;</span><br><span class="line">&#125;</span><br><span class="line">sourceSets.all &#123;</span><br><span class="line">ext.resourceDir=null</span><br><span class="line">&#125;</span><br><span class="line">sourceSets&#123;</span><br><span class="line">main &#123;</span><br><span class="line">resourceDir = &apos;main/res&apos;</span><br><span class="line">&#125;</span><br><span class="line">test &#123;</span><br><span class="line">resourceDir = &apos;test/res&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">task ext37Cu&lt;&lt;&#123;</span><br><span class="line">println &quot;年龄 $&#123;age&#125;&quot;</span><br><span class="line">println &quot;电话 $&#123;phone&#125;&quot;</span><br><span class="line">println &quot;地址 $&#123;address&#125;&quot;</span><br><span class="line">sourceSets.each &#123;</span><br><span class="line">println &quot;$&#123;it.name&#125;resourceDir是:$&#123;it.resourceDir&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目中一般使用它来自定义版本号和版本名称，把版本号和版本名称单独放在一个Gradle文件中，便于管理。</p><p>定义一个生成日期格式的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def buildTime()&#123;</span><br><span class="line">def date = new Date()</span><br><span class="line">def formattedDate=date.format(&apos;yyyyMMdd&apos;)</span><br><span class="line">return formattedDate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-介绍&quot;&gt;&lt;a href=&quot;#0-介绍&quot; class=&quot;headerlink&quot; title=&quot;0 介绍&quot;&gt;&lt;/a&gt;0 介绍&lt;/h1&gt;&lt;p&gt;Gradle是一个构建系统工具，DSL基于Groovy实现。Gradle构建大部分通过插件方式来实现，内置插件不能满足，可以自己自定义插件。DSL（Domain Specific Language）领域特定语言。java是一种通用语言。软件开发大师Martin Flower&amp;lt;&amp;lt;领域特定语言&amp;gt;&amp;gt;介绍。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android脚本" scheme="http://yoursite.com/tags/Android%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>PackageManagerService</title>
    <link href="http://yoursite.com/2017/08/01/PackageManagerService/"/>
    <id>http://yoursite.com/2017/08/01/PackageManagerService/</id>
    <published>2017-08-01T00:47:54.000Z</published>
    <updated>2019-02-02T11:21:31.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>PackageManagerService是本书分析的第一个核心服务，也是Android系统中最常用的服务之一。它负责系统中<code>Package的管理</code>，<code>应用程序的安装</code>、<code>卸载</code>、<code>信息查询</code>等.</p><a id="more"></a><p><img src="/2017/08/01/PackageManagerService/20150803110319692.png" alt="PackageManager家族"></p><ul><li>IPackageManager接口类中定义了服务端和客户端通信的业务函数，还定义了内部类Stub，该类从Binder派生并实现了IPackageManager接口。</li><li>PackageManagerService继承自IPackageManager.Stub类，由于Stub类从Binder派生，因此PackageManagerService将作为服务端参与Binder通信。</li><li>Stub类中定义了一个内部类Proxy，该类有一个IBinder类型（实际类型为BinderProxy）的成员变量mRemote，mRemote用于和服务端PackageManagerService通信。</li><li>IPackageManager接口类中定义了许多业务函数，但是出于安全等方面的考虑，Android对外（即SDK）提供的只是一个子集，该子集被封装在抽象类PackageManager中。客户端一般通过Context的getPackageManager函数返回一个类型为PackageManager的对象，该对象的实际类型是PackageManager的子类ApplicationPackageManager。这种基于接口编程的方式，虽然极大降低了模块之间的耦合性，却给代码分析带来了不小的麻烦。</li><li>ApplicationPackageManager类继承自PackageManager类。它并没有直接参与Binder通信，而是通过mPM成员变量指向一个IPackageManager.Stub.Proxy类型的对象。</li></ul><p><strong>提示</strong>在源码中可能找不到<code>IPackageManager.java</code>文件。该文件在编译过程中是经aidl工具处理IPackageManager.aidl后得到，最终的文件位置在Android源码<code>/out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src/core/java/android/content/pm/</code>.</p><h1 id="1-PMS初始"><a href="#1-PMS初始" class="headerlink" title="1.PMS初始"></a>1.PMS初始</h1><p>PKMS作为系统的核心服务，由SystemServer创建，相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SystemServer.java......ServerThread的run函数</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*4.0新增的一个功能，即设备加密（encrypting the device）,该功能由</span></span><br><span class="line"><span class="comment"> 系统属性vold.decrypt指定。这部分功能比较复杂，本书暂不讨论。该功能对PKMS的影响就是通过onlyCore实现的，该变量用于判断是否只扫描系统库（包括APK和Jar包*/</span></span><br><span class="line"> StringcryptState =SystemProperties.get(<span class="string">"vold.decrypt"</span>);</span><br><span class="line"> booleanonlyCore = <span class="keyword">false</span>;</span><br><span class="line"> <span class="comment">//ENCRYPTING_STATE的值为"trigger_restart_min_framework"</span></span><br><span class="line"> <span class="keyword">if</span>(ENCRYPTING_STATE.equals(cryptState)) &#123;......</span><br><span class="line">onlyCore = <span class="keyword">true</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">       ......<span class="comment">//ENCRYPTED_STATE的值为"1"</span></span><br><span class="line">     onlyCore = <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1.调用PKMS的main函数，第二个参数用于判断是否为工厂测试，我们不讨论的这种情况，</span></span><br><span class="line"> <span class="comment">//假定onlyCore的值为false</span></span><br><span class="line"> pm =PackageManagerService.main(context,factoryTest !=SystemServer.FACTORY_TEST_OFF,onlyCore);</span><br><span class="line"> booleanfirstBoot = <span class="keyword">false</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//判断本次是否为初次启动。当Zygote或SystemServer退出时，init会再次启动</span></span><br><span class="line">        <span class="comment">//它们，所以这里的FirstBoot是指开机后的第一次启动</span></span><br><span class="line">        firstBoot = pm.isFirstBoot();</span><br><span class="line"> &#125;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.做dex优化。dex是Android上针对Java字节码的一种优化技术，可提高运行效率</span></span><br><span class="line">       pm.performBootDexOpt();</span><br><span class="line">  &#125;</span><br><span class="line"> ......</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">        pm.systemReady();<span class="comment">//③通知系统进入就绪状态</span></span><br><span class="line"> &#125;</span><br><span class="line"> ......</span><br><span class="line">&#125;<span class="comment">//run函数结束</span></span><br></pre></td></tr></table></figure><p>首先分析PKMS的main函数，它是核心函数.</p><h1 id="2-PKMS的main"><a href="#2-PKMS的main" class="headerlink" title="2.PKMS的main"></a>2.PKMS的main</h1><p>PKMS的main函数代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> IPackageManager <span class="title">main</span><span class="params">(Contextcontext, <span class="keyword">boolean</span> factoryTest,<span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用PKMS的构造函factoryTest和onlyCore的值均为false</span></span><br><span class="line">PackageManagerService m = <span class="keyword">new</span> PackageManagerService(context,factoryTest, onlyCore);</span><br><span class="line">    <span class="comment">//向ServiceManager注册PKMS</span></span><br><span class="line">    ServiceManager.addService(<span class="string">"package"</span>, m);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>main函数很简单，只有短短几行代码，执行时间却较长，主要原因是PKMS在其构造函数中做了很多“重体力活”，这也是Android启动速度慢的主要原因之一。</p><p><strong>PKMS构造函数的主要功能是</strong>扫描Android系统中几个目标文件夹中的APK，从而建立合适的数据结构以管理诸如Package信息、四大组件信息、权限信息等各种信息。抽象地看，PKMS像一个加工厂，它解析实际的物理文件（APK文件）以生成符合自己要求的产品。例如，PKMS将解析APK包中的AndroidManifest.xml，并根据其中声明的Activity标签来创建与此对应的对象并加以保管。</p><p>PKMS的工作流程相对简单，复杂的是其中用于保存各种信息的数据结构和它们之间的关系，以及影响最终结果的策略控制（例如前面代码中的onlyCore变量，用于判断是否只扫描系统目录）。曾经阅读过PKMS的读者可能会发现，代码中大量不同的数据结构以及它们之间的关系会令人大为头疼。所以，本章除了分析PKMS的工作流程外，也将关注重要的数据结构及它们的作用。</p><p>PKMS构造函数的工作流程大体可分三个阶段：</p><ul><li>1.扫描目标文件夹之前的准备工作。</li><li>2.扫描目标文件夹。</li><li>3.扫描之后的工作。</li></ul><h1 id="3-扫描准备工作"><a href="#3-扫描准备工作" class="headerlink" title="3.扫描准备工作"></a>3.扫描准备工作</h1><p>下面开始分析构造函数第一阶段的工作，先看如下所示的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PackageManagerService</span><span class="params">(Context context,<span class="keyword">boolean</span> factoryTest,booleanonlyCore)</span> </span>&#123;</span><br><span class="line"><span class="comment">//系统属性“ro.build.version.sdk”</span></span><br><span class="line"><span class="keyword">if</span>(mSdkVersion &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">Slog.w(TAG, <span class="string">"**** ro.build.version.sdk not set!"</span>);<span class="comment">//打印一句警告</span></span><br><span class="line">&#125;</span><br><span class="line">mContext = context;</span><br><span class="line">    mFactoryTest= factoryTest;<span class="comment">//假定为false，即运行在非工厂模式下</span></span><br><span class="line"></span><br><span class="line">    mOnlyCore = onlyCore;<span class="comment">//假定为false，即运行在普通模式下</span></span><br><span class="line"><span class="comment">//如果此系统是eng版，则扫描Package后，不对package做dex优化</span></span><br><span class="line">mNoDexOpt =<span class="string">"eng"</span>.equals(SystemProperties.get(<span class="string">"ro.build.type"</span>));</span><br><span class="line"><span class="comment">//如果此系统是eng版，则扫描Package后，不对package做dex优化</span></span><br><span class="line">mNoDexOpt =<span class="string">"eng"</span>.equals(SystemProperties.get(<span class="string">"ro.build.type"</span>));</span><br><span class="line"> <span class="comment">//mMetrics用于存储与显示屏相关的一些属性，例如屏幕的宽/高尺寸，分辨率等信息</span></span><br><span class="line">mMetrics = <span class="keyword">new</span> DisplayMetrics();</span><br><span class="line"><span class="comment">//Settings是一个非常重要的类，该类用于存储系统运行过程中的一些设置，</span></span><br><span class="line">mSettings = <span class="keyword">new</span> Settings();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1.addSharedUserLPw是什么？马上来分析</span></span><br><span class="line">mSettings.addSharedUserLPw(<span class="string">"android.uid.system"</span>,Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);</span><br><span class="line">mSettings.addSharedUserLPw(<span class="string">"android.uid.phone"</span>, MULTIPLE_APPLICATION_UIDS  <span class="comment">//该变量的默认值是true</span></span><br><span class="line">? RADIO_UID :FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);</span><br><span class="line"> mSettings.addSharedUserLPw(<span class="string">"android.uid.log"</span>,MULTIPLE_APPLICATION_UIDS? LOG_UID :FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);</span><br><span class="line">mSettings.addSharedUserLPw(<span class="string">"android.uid.nfc"</span>,MULTIPLE_APPLICATION_UIDS? NFC_UID :FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);......<span class="comment">//第一段结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会遇到第一个较为复杂的数据结构Setting及它的addSharedUserLPw函数。Setting的作用是管理Android系统运行过程中的一些设置信息。</p><h2 id="3-1-初识Settings"><a href="#3-1-初识Settings" class="headerlink" title="3.1  初识Settings"></a>3.1  初识Settings</h2><p>先分析addSharedUserLPw函数。addSharedUserLPw传递了3个参数：</p><ul><li>第一个是字符串“android.uid.system“；</li><li>第二个是SYSTEM_UID，其值为1000；</li><li>第三个是FLAG_SYSTEM标志，用于标识系统Package。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SharedUserSetting <span class="title">addSharedUserLPw</span><span class="params">(String name,<span class="keyword">int</span> uid, <span class="keyword">int</span> pkgFlags)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/*注意这里的参数：name为字符串”android.uid.system”,uid为1000，pkgFlags为</span></span><br><span class="line"><span class="comment">ApplicationInfo.FLAG_SYSETM(以后简写为FLAG_SYSTEM)*/</span></span><br><span class="line"><span class="comment">//mSharedUsers是一个HashMap，key为字符串，值为SharedUserSetting对象</span></span><br><span class="line">       SharedUserSetting s = mSharedUsers.get(name);</span><br><span class="line">       <span class="keyword">if</span>(s != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (s.userId == uid) &#123;</span><br><span class="line">               <span class="keyword">return</span> s;</span><br><span class="line">           &#125;......</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个新的SharedUserSettings对象，并设置的userId为uid，</span></span><br><span class="line">       <span class="comment">//SharedUserSettings是什么？有什么作用？</span></span><br><span class="line">        s =<span class="keyword">new</span> SharedUserSetting(name, pkgFlags);</span><br><span class="line">       s.userId = uid;</span><br><span class="line">        <span class="keyword">if</span>(addUserIdLPw(uid, s, name)) &#123;</span><br><span class="line">           mSharedUsers.put(name, s);<span class="comment">//将name与s键值对添加到mSharedUsers中保存</span></span><br><span class="line">           <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在AndroidManifest.xml中，声明了一个名为android:sharedUserId的属性，其为“android.uid.system”，有两个作用：</p><ul><li>两个或多个声明了同一种sharedUserIds的APK可共享彼此的数据，并且可运行在同一进程中。</li><li>更重要的是，通过声明特定的sharedUserId，该APK所在进程将被赋予指定的UID。例如，本例中的SystemUI声明了system的uid，运行SystemUI的进程就可享有system用户所对应的权限（实际上就是将该进程的uid设置为system的uid）了。</li></ul><p><strong>注意</strong>除了在AndroidManifest.xml中声明sharedUserId外，APK在编译时还必须使用对应的证书进行签名。例如本例的SystemUI，在其Android.mk中需要额外声明<code>LOCAL_CERTIFICATE := platform</code>，如此，才可获得指定的UID。</p><p>Android是设计相应数据结构如下：<br><img src="/2017/08/01/PackageManagerService/20150803110344641.png" alt="PackageManagerShareUID"></p><p> Settings中还有两个成员，一个是<code>mUserIds</code>，另一个是<code>mOtherUserIds</code>，这两位成员的类型分别是ArrayList和SparseArray。其目的是以UID为索引，得到对应的SharedUserSettings对象。在一般情况下，以索引获取数组元素的速度，比以key获取HashMap中元素的速度要快很多。<br><strong>提示</strong> 根据以上对mUserIds和mOtherUserIds的描述，可知这是典型的以空间换时间的做法。<br>addUserIdLPw函数功能就是将SharedUserSettings对象保存到对应的数组中.</p><h2 id="3-2-扫描XML文件"><a href="#3-2-扫描XML文件" class="headerlink" title="3.2 扫描XML文件"></a>3.2 扫描XML文件</h2><p>下面继续分析PKMS的构造函数:进行<strong>XML文件扫描</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">......<span class="comment">//接前一段</span></span><br><span class="line">String separateProcesses = <span class="comment">//该值和调试有关。一般不设置该属性</span></span><br><span class="line">SystemProperties.get(<span class="string">"debug.separate_processes"</span>)</span><br><span class="line"><span class="keyword">if</span>(separateProcesses != <span class="keyword">null</span> &amp;&amp; separateProcesses.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ......</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">mDefParseFlags = <span class="number">0</span>;</span><br><span class="line">mSeparateProcesses = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个Installer对象，该对象和Native进程installd交互，以后分析installd时再来讨论它的作用</span></span><br><span class="line">mInstaller = <span class="keyword">new</span> Installer();</span><br><span class="line">WindowManager wm =(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">Display d = wm.getDefaultDisplay();</span><br><span class="line">d.getMetrics(mMetrics); <span class="comment">//获取当前设备的显示屏信息</span></span><br><span class="line"><span class="keyword">synchronized</span> (mInstallLock) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line"><span class="comment">//创建一个ThreadHandler对象，实际就是创建一个带消息循环处理的线程，该线程</span></span><br><span class="line"><span class="comment">//的工作是：程序的和卸载等。以后分析程序安装时会和它亲密接触</span></span><br><span class="line">mHandlerThread.start();</span><br><span class="line"><span class="comment">//以ThreadHandler线程的消息循环(Looper对象)为参数创建一个PackageHandler，</span></span><br><span class="line"><span class="comment">//可知该Handler的handleMessage函数将运行在此线程上</span></span><br><span class="line">mHandler = <span class="keyword">new</span> PackageHandler(mHandlerThread.getLooper());</span><br><span class="line">    File dataDir = Environment.getDataDirectory();</span><br><span class="line"><span class="comment">// mAppDataDir指向/data/data目录</span></span><br><span class="line">mAppDataDir = <span class="keyword">new</span> File(dataDir, <span class="string">"data"</span>);</span><br><span class="line"><span class="comment">// mUserAppDataDir指向/data/user目录</span></span><br><span class="line">mUserAppDataDir = <span class="keyword">new</span> File(dataDir, <span class="string">"user"</span>);</span><br><span class="line"><span class="comment">// mDrmAppPrivateInstallDir指向/data/app-private目录</span></span><br><span class="line">mDrmAppPrivateInstallDir = <span class="keyword">new</span> File(dataDir, <span class="string">"app-private"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个UserManager对象，目前没有什么作用，但其前途将不可限量。</span></span><br><span class="line"><span class="comment">     根据Google的设想，未来手机将支持多个User，每个User将安装自己的应用，</span></span><br><span class="line"><span class="comment">     该功能为Andorid智能手机推向企业用户打下坚实基础</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">mUserManager = <span class="keyword">new</span> UserManager(mInstaller, mUserAppDataDir);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//1.从文件中读权限</span></span><br><span class="line">     readPermissions();</span><br><span class="line"><span class="comment">//2.readLPw分析</span></span><br><span class="line">mRestoredSettings = mSettings.readLPw();</span><br><span class="line"><span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br></pre></td></tr></table></figure><h2 id="3-3readPermissions"><a href="#3-3readPermissions" class="headerlink" title="3.3readPermissions"></a>3.3readPermissions</h2><p>分析readPermissions函数，从其函数名可猜测到它和权限有关.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readPermissions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 指向/system/etc/permission目录，该目录中存储了和设备相关的一些权限信息</span></span><br><span class="line">   FilelibraryDir = <span class="keyword">new</span> File(Environment.getRootDirectory(),<span class="string">"etc/permissions"</span>);</span><br><span class="line">   ......</span><br><span class="line"><span class="keyword">for</span>(File f : libraryDir.listFiles()) &#123;</span><br><span class="line">        <span class="comment">//先处理该目录下的非platform.xml文</span></span><br><span class="line">        <span class="keyword">if</span> (f.getPath().endsWith(<span class="string">"etc/permissions/platform.xml"</span>)) &#123;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......<span class="comment">//调用readPermissionFromXml解析此XML文件</span></span><br><span class="line">        readPermissionsFromXml(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    finalFile permFile = <span class="keyword">new</span> File(Environment.getRootDirectory(),<span class="string">"etc/permissions/platform.xml"</span>);</span><br><span class="line"><span class="comment">//解析platform.xml文件，看来该文件优先级最高</span></span><br><span class="line">readPermissionsFromXml(permFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>readPermissionFromXml</code>函数解析<code>/system/etc/permissions</code>目录下的文件.</p><p><img src="/2017/08/01/PackageManagerService/20150803110405552.png" alt="permission"></p><p>例如：<code>platform.xml</code>文件内容如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;permissions&gt;</span><br><span class="line">   &lt;!--建立权限名与gid的映射关系。如下面声明的BLUTOOTH_ADMIN权限，它对应的用户组是</span><br><span class="line">    net_bt_admin。注意，该文件中的permission标签只对那些需要通过读写设备（蓝牙/camera）</span><br><span class="line">     /创建socket等进程划分了gid。因为这些权限涉及和Linux内核交互，所以需要在底层</span><br><span class="line">     权限（由不同的用户组界定）和Android层权限（由不同的字符串界定）之间建立映射关系</span><br><span class="line">  --&gt;</span><br><span class="line"> &lt;permission name=&quot;android.permission.BLUETOOTH_ADMIN&quot; &gt;</span><br><span class="line">       &lt;group gid=&quot;net_bt_admin&quot; /&gt;</span><br><span class="line"> &lt;/permission&gt;</span><br><span class="line"> &lt;permission name=&quot;android.permission.BLUETOOTH&quot; &gt;</span><br><span class="line">       &lt;group gid=&quot;net_bt&quot; /&gt;</span><br><span class="line">  &lt;/permission&gt;</span><br><span class="line">  ......</span><br><span class="line">   &lt;!--</span><br><span class="line">     赋予对应uid相应的权限。如果下面一行表示uid为shell，那么就赋予</span><br><span class="line">       它SEND_SMS的权限，其实就是把它加到对应的用户组中--&gt;</span><br><span class="line">   &lt;assign-permission name=&quot;android.permission.SEND_SMS &quot;uid=&quot;shell&quot; /&gt;</span><br><span class="line">   &lt;assign-permission name=&quot;android.permission.CALL_PHONE &quot;uid=&quot;shell&quot; /&gt;</span><br><span class="line">   &lt;assign-permission name=&quot;android.permission.READ_CONTACTS&quot; uid=&quot;shell&quot; /&gt;</span><br><span class="line">   &lt;assign-permission name=&quot;android.permission.WRITE_CONTACTS&quot;uid=&quot;shell&quot; /&gt;</span><br><span class="line">   &lt;assign-permissionname=&quot;android.permission.READ_CALENDAR&quot; uid=&quot;shell&quot; /&gt;</span><br><span class="line">......</span><br><span class="line">    &lt;!-- 系统提供的Java库，应用程序运行时候必须要链接这些库，该工作由系统自动完成 --&gt;</span><br><span class="line">    &lt;libraryname=&quot;android.test.runner&quot; file=&quot;/system/frameworks/android.test.runner.jar&quot; /&gt;</span><br><span class="line">    &lt;library name=&quot;javax.obex&quot; file=&quot;/system/frameworks/javax.obex.jar&quot;/&gt;</span><br><span class="line">&lt;/permissions&gt;</span><br></pre></td></tr></table></figure><p>platform.xml文件中主要使用了如下4个标签：</p><ul><li><code>permission</code>和<code>group</code>用于建立Linux层gid和Android层pemission之间的映射关系。</li><li><code>assign-permission</code>用于向指定的uid赋予相应的权限。这个权限由Android定义，用字符串表示。</li><li><code>library</code>用于指定系统库。当应用程序运行时，系统会自动为这些进程加载这些库。</li></ul><p>再看其他的XML文件，这里以<code>handheld-core-hardware.xml</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;permissions&gt;</span><br><span class="line">   &lt;feature name=&quot;android.hardware.camera&quot; /&gt;</span><br><span class="line">   &lt;feature name=&quot;android.hardware.location&quot; /&gt;</span><br><span class="line">   &lt;feature name=&quot;android.hardware.location.network&quot; /&gt;</span><br><span class="line">   &lt;feature name=&quot;android.hardware.sensor.compass&quot; /&gt;</span><br><span class="line">   &lt;feature name=&quot;android.hardware.sensor.accelerometer&quot; /&gt;</span><br><span class="line">   &lt;feature name=&quot;android.hardware.bluetooth&quot; /&gt;</span><br><span class="line">   &lt;feature name=&quot;android.hardware.touchscreen&quot; /&gt;</span><br><span class="line">   &lt;feature name=&quot;android.hardware.microphone&quot; /&gt;</span><br><span class="line">   &lt;feature name=&quot;android.hardware.screen.portrait&quot; /&gt;</span><br><span class="line">   &lt;feature name=&quot;android.hardware.screen.landscape&quot; /&gt;</span><br><span class="line">&lt;/permissions&gt;</span><br></pre></td></tr></table></figure><p>这个XML文件包含了许多feature标签。根据该文件中的注释，这些feature用来描述一个手持终端（包括手机、平板电脑等）应该支持的硬件特性，例如支持camera、支持蓝牙等。</p><p><strong>注意</strong>对于不同的硬件特性，还需要包含其他的xml文件。例如，要支持前置摄像头，还需要包含<code>android.hardware.camera.front.xml</code>文件。这些文件内容大体一样，都通过feature标签表明自己的硬件特性。</p><p>设备上<code>/system/etc/permission</code>目录中的文件来自：在编译阶段由不同硬件平台根据自己的配置信息复制相关文件到目标目录中得来的。<br>readPermissionFromXml函数:就是将XML文件中的标签以及它们之间的关系转换成代码中的相应数据结构.<br><img src="/2017/08/01/PackageManagerService/20150803110509033.png" alt="Xml结构体"></p><h2 id="3-4readLPw"><a href="#3-4readLPw" class="headerlink" title="3.4readLPw"></a>3.4readLPw</h2><p>readLPw函数的功能也是解析文件，不过这些文件的内容却是在PKMS正常启动后生成的。这里仅介绍作为readLPw“佐料”的文件的信息。文件的具体位置在Settings构造函数中指明，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Settings()&#123;</span><br><span class="line">    FiledataDir = Environment.getDataDirectory();</span><br><span class="line">    FilesystemDir = <span class="keyword">new</span> File(dataDir, <span class="string">"system"</span>);<span class="comment">//指向/data/system目录</span></span><br><span class="line">    systemDir.mkdirs();<span class="comment">//创建该目录</span></span><br><span class="line">        ......</span><br><span class="line">    <span class="comment">/*一共有5个文件，packages.xml和packages-backup.xml为一组，用于描述系统中</span></span><br><span class="line"><span class="comment">     所安装的Package的信息，其中backup是临时文件。PKMS先把数据写到backup中，</span></span><br><span class="line"><span class="comment">     信息都写成功后再改名成非backup的文件。其目的是防止在写文件过程中出错，导致信息丢失。</span></span><br><span class="line"><span class="comment">packages-stopped.xml和packages-stopped-backup.xml为一组，用于描述系统中</span></span><br><span class="line"><span class="comment">    强制停止运行的pakcage的信息，backup也是临时文件。如果此处存在该临时文件，表明</span></span><br><span class="line"><span class="comment">   此前系统因为某种原因中断了正常流程packages.list列出当前系统中应用级（即UID大于10000）Package的信息*/</span></span><br><span class="line">   mSettingsFilename = <span class="keyword">new</span> File(systemDir, <span class="string">"packages.xml"</span>);</span><br><span class="line">   mBackupSettingsFilename = <span class="keyword">new</span> File(systemDir,<span class="string">"packages-backup.xml"</span>);</span><br><span class="line">   mPackageListFilename = <span class="keyword">new</span> File(systemDir, <span class="string">"packages.list"</span>);</span><br><span class="line">   mStoppedPackagesFilename = <span class="keyword">new</span> File(systemDir,<span class="string">"packages-stopped.xml"</span>);</span><br><span class="line">   mBackupStoppedPackagesFilename = <span class="keyword">new</span> File(systemDir,<span class="string">"packages-stopped-backup.xml"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面5个文件共分为三组，这里简单介绍一下这些文件的来历（不考虑临时的backup文件）。</p><ul><li><code>packages.xml</code>： PKMS<code>扫描完目标文件夹</code>后会创建该文件。当系统进行<code>程序安装</code>、<code>卸载</code>和<code>更新</code>等操作时，均会<strong>更新该文件</strong>。该文件保存了系统中与<code>package相关</code>的一些信息。</li><li><code>packages.list</code>：描述系统中存在的所有<code>非系统自带的APK</code>的信息。当这些程序有变动时，PKMS就会更新该文件。</li><li><code>packages-stopped.xml</code>：从系统自带的设置程序中进入应用程序页面，然后在选择强制停止（ForceStop）某个应用时，系统会将该应用的相关信息记录到此文件中。也就是该文件保存系统中被用户强制停止的Package的信息。<br>readLPw的函数功能就是解析其中的XML文件的内容，然后建立并更新对应的数据结构，例如停止的package重启之后依然是stopped状态。</li></ul><h3 id="第一阶段工作总结"><a href="#第一阶段工作总结" class="headerlink" title="第一阶段工作总结"></a>第一阶段工作总结</h3><p>在继续征程前，先总结一下PKMS构造函数在第一阶段的工作，千言万语汇成一句话：扫描并解析XML文件，将其中的信息保存到特定的数据结构中。</p><p>第一阶段扫描的XML文件与权限及上一次扫描得到的Package信息有关，它为PKMS下一阶段的工作提供了重要的参考信息。</p><h1 id="4-扫描Package"><a href="#4-扫描Package" class="headerlink" title="4.扫描Package"></a>4.扫描Package</h1><p>PKMS构造函数第二阶段的工作就是扫描系统中的APK了。由于需要逐个扫描文件，因此手机上装的程序越多，PKMS的工作量越大，系统启动速度也就越慢。</p><h2 id="4-1-系统库的dex优化"><a href="#4-1-系统库的dex优化" class="headerlink" title="4.1 系统库的dex优化"></a>4.1 系统库的dex优化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">mRestoredSettings= mSettings.readLPw();<span class="comment">//接第一段的结尾</span></span><br><span class="line">longstartTime = SystemClock.uptimeMillis();<span class="comment">//记录扫描开始的时间</span></span><br><span class="line"><span class="comment">//定义扫描参数</span></span><br><span class="line">intscanMode = SCAN_MONITOR | SCAN_NO_PATHS | SCAN_DEFER_DEX;</span><br><span class="line"> <span class="keyword">if</span>(mNoDexOpt) &#123;</span><br><span class="line">    scanMode|= SCAN_NO_DEX; <span class="comment">//在控制扫描过程中是否对APK文件进行dex优化</span></span><br><span class="line"> &#125;</span><br><span class="line"> finalHashSet&lt;String&gt; libFiles = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"> <span class="comment">// mFrameworkDir指向/system/frameworks目录</span></span><br><span class="line"> mFrameworkDir = newFile(Environment.getRootDirectory(),<span class="string">"framework"</span>);</span><br><span class="line"> <span class="comment">// mDalvikCacheDir指向/data/dalvik-cache目录</span></span><br><span class="line"> mDalvikCacheDir= <span class="keyword">new</span> File(dataDir, <span class="string">"dalvik-cache"</span>);</span><br><span class="line"> booleandidDexOpt = <span class="keyword">false</span>;</span><br><span class="line"> <span class="comment">/*获取Java启动类库的路径，在init.rc文件中通过BOOTCLASSPATH环境变量输出，该值如下</span></span><br><span class="line"><span class="comment">  /system/framework/core.jar:/system/frameworks/core-junit.jar:</span></span><br><span class="line"><span class="comment">  /system/frameworks/bouncycastle.jar:/system/frameworks/ext.jar:</span></span><br><span class="line"><span class="comment">  /system/frameworks/framework.jar:/system/frameworks/android.policy.jar:</span></span><br><span class="line"><span class="comment">  /system/frameworks/services.jar:/system/frameworks/apache-xml.jar:</span></span><br><span class="line"><span class="comment">  /system/frameworks/filterfw.jar</span></span><br><span class="line"><span class="comment">  该变量指明了framework所有核心库及文件位置*/</span></span><br><span class="line"> StringbootClassPath = System.getProperty(<span class="string">"java.boot.class.path"</span>);</span><br><span class="line"> <span class="keyword">if</span>(bootClassPath != <span class="keyword">null</span>) &#123;</span><br><span class="line">     String[] paths = splitString(bootClassPath, <span class="string">':'</span>);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;paths.length; i++) &#123;</span><br><span class="line">       <span class="keyword">try</span>&#123;  <span class="comment">//判断该jar包是否需要重新做dex优化</span></span><br><span class="line">            <span class="keyword">if</span> (dalvik.system.DexFile.isDexOptNeeded(paths[i])) &#123;</span><br><span class="line">                 <span class="comment">/*</span></span><br><span class="line"><span class="comment">                  将该jar包文件路径保存到libFiles中，然后通过mInstall对象发送</span></span><br><span class="line"><span class="comment">                   命令给installd，让其对该jar包进行dex优化</span></span><br><span class="line"><span class="comment">                  */</span></span><br><span class="line">                  libFiles.add(paths[i]);</span><br><span class="line">                  mInstaller.dexopt(paths[i], Process.SYSTEM_UID, <span class="keyword">true</span>);</span><br><span class="line">                  didDexOpt = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125; ......</span><br><span class="line">           &#125;</span><br><span class="line">      &#125; ......</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    读者还记得mSharedLibrarires的作用吗？它保存的是platform.xml中声明的系统库的信息。</span></span><br><span class="line"><span class="comment">    这里也要判断系统库是否需要做dex优化。处理方式同上</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">if</span> (mSharedLibraries.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//将framework-res.apk添加到libFiles中。framework-res.apk定义了系统常用的</span></span><br><span class="line"> 资源，还有几个重要的Activity，如长按Power键后弹出的选择框</span><br><span class="line"> libFiles.add(mFrameworkDir.getPath() + <span class="string">"/framework-res.apk"</span>);</span><br><span class="line"> <span class="comment">//列举/system/frameworks目录中的文件</span></span><br><span class="line"> String[] frameworkFiles = mFrameworkDir.list();</span><br><span class="line"> <span class="keyword">if</span>(frameworkFiles != <span class="keyword">null</span>) &#123;</span><br><span class="line">         ......<span class="comment">//判断该目录下的apk或jar文件是否需要做dex优化。处理方式同上</span></span><br><span class="line"> &#125;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   上面代码对系统库（BOOTCLASSPATH指定，或 platform.xml定义，或</span></span><br><span class="line"><span class="comment">  /system/frameworks目录下的jar包与apk文件）进行一次仔细检查，该优化的一定要优化。</span></span><br><span class="line"><span class="comment">  如果发现期间对任何一个文件进行了优化，则设置didDexOpt为true</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">if</span> (didDexOpt) &#123;</span><br><span class="line">      String[] files = mDalvikCacheDir.list();</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         如果前面对任意一个系统库重新做过dex优化，就需要删除cache文件。原因和</span></span><br><span class="line"><span class="comment">         dalvik虚拟机的运行机制有关。本书暂不探讨dex及cache文件的作用。</span></span><br><span class="line"><span class="comment">         从删除cache文件这个操作来看，这些cache文件应该使用了dex优化后的系统库</span></span><br><span class="line"><span class="comment">         所以当系统库重新做dex优化后，就需要删除旧的cache文件。可简单理解为缓存失效</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;files.length; i++) &#123;</span><br><span class="line">                   String fn = files[i];</span><br><span class="line">                     <span class="keyword">if</span>(fn.startsWith(<span class="string">"data@app@"</span>)</span><br><span class="line">                          ||fn.startsWith(<span class="string">"data@app-private@"</span>)) &#123;</span><br><span class="line">                         (newFile(mDalvikCacheDir, fn)).delete();</span><br><span class="line">        ......</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-扫描系统Package"><a href="#4-2-扫描系统Package" class="headerlink" title="4.2  扫描系统Package"></a>4.2  扫描系统Package</h2><p>清空cache文件后，PKMS终于进入重点段了。接下来看PKMS第二阶段工作的核心内容，即扫描Package</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建文件夹监控对象，监视/system/frameworks目录。利用了Linux平台的inotify机制</span></span><br><span class="line">mFrameworkInstallObserver = <span class="keyword">new</span> AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS, <span class="keyword">true</span>);</span><br><span class="line">mFrameworkInstallObserver.startWatching();</span><br><span class="line"> <span class="comment">/*调用scanDirLI函数扫描/system/frameworks目录，这个函数很重要，稍后会再分析。</span></span><br><span class="line"><span class="comment">  注意，在第三个参数中设置了SCAN_NO_DEX标志，因为该目录下的package在前面的流程</span></span><br><span class="line"><span class="comment">  中已经过判断并根据需要做过dex优化了*/</span></span><br><span class="line">scanDirLI(mFrameworkDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">|PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//创建文件夹监控对象，监视/system/app目录</span></span><br><span class="line">mSystemAppDir = <span class="keyword">new</span> File(Environment.getRootDirectory(),<span class="string">"app"</span>);</span><br><span class="line">mSystemInstallObserver = <span class="keyword">new</span> AppDirObserver(mSystemAppDir.getPath(), OBSERVER_EVENTS, <span class="keyword">true</span>);</span><br><span class="line">mSystemInstallObserver.startWatching();</span><br><span class="line"><span class="comment">//扫描/system/app下的package</span></span><br><span class="line">scanDirLI(mSystemAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">                   | PackageParser.PARSE_IS_SYSTEM_DIR, scanMode, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//监视并扫描/vendor/app目录</span></span><br><span class="line">mVendorAppDir = <span class="keyword">new</span> File(<span class="string">"/vendor/app"</span>);</span><br><span class="line">mVendorInstallObserver = <span class="keyword">new</span> AppDirObserver(</span><br><span class="line">mVendorAppDir.getPath(), OBSERVER_EVENTS, <span class="keyword">true</span>);</span><br><span class="line">mVendorInstallObserver.startWatching();</span><br><span class="line"><span class="comment">//扫描/vendor/app下的package</span></span><br><span class="line">scanDirLI(mVendorAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">| PackageParser.PARSE_IS_SYSTEM_DIR, scanMode, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//和installd交互。以后单独分析installd</span></span><br><span class="line">mInstaller.moveFiles();</span><br></pre></td></tr></table></figure><p>由以上代码可知，PKMS将扫描以下几个目录。</p><ul><li><code>/system/frameworks</code>：该目录中的文件都是系统库，例如<code>framework.jar</code>、<code>services.jar</code>、<code>framework-res.apk</code>。不过<code>scanDirLI</code>只扫描APK文件，所以framework-res.apk是该目录中唯一“受宠”的文件。</li><li><code>/system/app</code>：该目录下全是默认的系统应用，例如Browser.apk、SettingsProvider.apk等。</li><li><code>/vendor/app</code>：该目录中的文件由厂商提供，即厂商特定的APK文件，不过目前市面上的厂商都把自己的应用放在/system/app目录下。</li></ul><p><strong>注意</strong>将把这三个目录称为系统Package目录，以区分后面的非系统Package目录。</p><h3 id="4-2-1scanDirLI函数分析"><a href="#4-2-1scanDirLI函数分析" class="headerlink" title="4.2.1scanDirLI函数分析"></a>4.2.1scanDirLI函数分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanDirLI</span><span class="params">(File dir, <span class="keyword">int</span> flags, intscanMode, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">    String[] files = dir.list();<span class="comment">//列举该目录下的文件</span></span><br><span class="line">     ......</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;files.length; i++) &#123;</span><br><span class="line">           File file = <span class="keyword">new</span> File(dir, files[i]);</span><br><span class="line">           <span class="keyword">if</span> (!isPackageFilename(files[i])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//根据文件名后缀，判断是否为APK 文件。这里只扫描APK 文件</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            调用scanPackageLI函数扫描一个特定的文件，返回值是PackageParser的内部类</span></span><br><span class="line"><span class="comment">            Package，该类的实例代表一个APK文件，所以它就是和APK文件对应的数据结构</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          PackageParser.Package pkg = scanPackageLI(file,</span><br><span class="line">                flags|PackageParser.PARSE_MUST_BE_APK, scanMode, currentTime);</span><br><span class="line">          <span class="keyword">if</span> (pkg == <span class="keyword">null</span> &amp;&amp; (flags &amp;PackageParser.PARSE_IS_SYSTEM) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">               mLastScanError ==PackageManager.INSTALL_FAILED_INVALID_APK) &#123;</span><br><span class="line">               <span class="comment">//注意此处flags的作用，只有非系统Package扫描失败，才会删除该文件</span></span><br><span class="line">               file.delete();</span><br><span class="line">          &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着来分析scanPackageLI函数。PKMS中有两个同名的scanPackageLI函数，后面会一一见到。先来看第一个也是最先碰到的scanPackageLI函数。</p><h3 id="4-2-2scanPackageLI函数"><a href="#4-2-2scanPackageLI函数" class="headerlink" title="4.2.2scanPackageLI函数"></a>4.2.2scanPackageLI函数</h3><p>首次相遇的scanPackageLI函数的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PackageParser.<span class="function">Package <span class="title">scanPackageLI</span><span class="params">(FilescanFile, <span class="keyword">int</span> parseFlags,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> scanMode, <span class="keyword">long</span> currentTime)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     mLastScanError = PackageManager.INSTALL_SUCCEEDED;</span><br><span class="line">     StringscanPath = scanFile.getPath();</span><br><span class="line">     parseFlags |= mDefParseFlags;<span class="comment">//默认的扫描标志，正常情况下为0</span></span><br><span class="line">     <span class="comment">//创建一个PackageParser对象</span></span><br><span class="line">     PackageParser pp = <span class="keyword">new</span> PackageParser(scanPath);</span><br><span class="line">     pp.setSeparateProcesses(mSeparateProcesses);<span class="comment">// mSeparateProcesses为空</span></span><br><span class="line">     pp.setOnlyCoreApps(mOnlyCore);<span class="comment">// mOnlyCore为false</span></span><br><span class="line">      <span class="comment">/*调用PackageParser的parsePackage函数解析APK文件。注意，这里把代表屏幕</span></span><br><span class="line"><span class="comment">       信息的mMetrics对象也传了进去*/</span></span><br><span class="line">     finalPackageParser.Package pkg = pp.parsePackage(scanFile,</span><br><span class="line">               scanPath, mMetrics, parseFlags);</span><br><span class="line">        ......</span><br><span class="line">     PackageSetting ps = <span class="keyword">null</span>;</span><br><span class="line">     PackageSetting updatedPkg;</span><br><span class="line">        ......</span><br><span class="line">     <span class="comment">/* 这里略去一大段代码，主要是关于Package升级方面的工作。读者可能会比较好奇：既然是</span></span><br><span class="line"><span class="comment">        升级，一定有新旧之分，如果这里刚解析后得到的Package信息是新，那么旧Package</span></span><br><span class="line"><span class="comment">        的信息从何得来？还记得”readLPw的‘佐料’”这一小节提到的package.xml文件吗？此</span></span><br><span class="line"><span class="comment">        文件中存储的就是上一次扫描得到的Package信息。对比这两次的信息就知道是否需要做</span></span><br><span class="line"><span class="comment">        升级了。这部分代码比较繁琐，但不影响我们正常分析。感兴趣的读者可自行研究</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="comment">//收集签名信息，这部分内容涉及signature，本书暂不拟讨论[①]。</span></span><br><span class="line">      <span class="keyword">if</span> (!collectCertificatesLI(pp, ps, pkg,scanFile, parseFlags))</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">//判断是否需要设置PARSE_FORWARD_LOCK标志，这个标志针对资源文件和Class文件</span></span><br><span class="line">     <span class="comment">//不在同一个目录的情况。目前只有/vendor/app目录下的扫描会使用该标志。这里不讨论</span></span><br><span class="line">     <span class="comment">//这种情况。</span></span><br><span class="line">      <span class="keyword">if</span> (ps != <span class="keyword">null</span> &amp;&amp;!ps.codePath.equals(ps.resourcePath))</span><br><span class="line">           parseFlags|= PackageParser.PARSE_FORWARD_LOCK;</span><br><span class="line">        String codePath = <span class="keyword">null</span>;</span><br><span class="line">       String resPath = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>((parseFlags &amp; PackageParser.PARSE_FORWARD_LOCK) != <span class="number">0</span>) &#123;</span><br><span class="line">            ......<span class="comment">//这里不考虑PARSE_FORWARD_LOCK的情况。</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           resPath = pkg.mScanPath;</span><br><span class="line">        &#125;</span><br><span class="line">       codePath = pkg.mScanPath;<span class="comment">//mScanPath指向该APK文件所在位置</span></span><br><span class="line">        <span class="comment">//设置文件路径信息，codePath和resPath都指向APK文件所在位置</span></span><br><span class="line">       setApplicationInfoPaths(pkg, codePath, resPath);</span><br><span class="line">        <span class="comment">//调用第二个scanPackageLI函数</span></span><br><span class="line">       <span class="keyword">return</span> scanPackageLI(pkg, parseFlags, scanMode | SCAN_UPDATE_SIGNATURE,</span><br><span class="line">                                 currentTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scanPackageLI函数首先调用PackageParser对APK文件进行解析。根据前面的介绍可知，PackageParser完成了从物理文件到对应数据结构的转换。下面来分析这个PackageParser。</p><h3 id="4-2-3PackageParser分析"><a href="#4-2-3PackageParser分析" class="headerlink" title="4.2.3PackageParser分析"></a>4.2.3PackageParser分析</h3><p>PackageParser主要负责APK文件的解析，即解析APK文件中的AndroidManifest.xml代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">publicPackage <span class="title">parsePackage</span><span class="params">(File sourceFile, String destCodePath,</span></span></span><br><span class="line"><span class="function"><span class="params">           DisplayMetrics metrics, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">      mParseError = PackageManager.INSTALL_SUCCEEDED;</span><br><span class="line">      mArchiveSourcePath =sourceFile.getPath();</span><br><span class="line">        ......<span class="comment">//检查是否为APK文件</span></span><br><span class="line">      XmlResourceParser parser = <span class="keyword">null</span>;</span><br><span class="line">      AssetManager assmgr = <span class="keyword">null</span>;</span><br><span class="line">      Resources res = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">boolean</span> assetError = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">           assmgr = <span class="keyword">new</span> AssetManager();</span><br><span class="line">           <span class="keyword">int</span> cookie = assmgr.addAssetPath(mArchiveSourcePath);</span><br><span class="line">           <span class="keyword">if</span> (cookie != <span class="number">0</span>) &#123;</span><br><span class="line">               res = <span class="keyword">new</span> Resources(assmgr, metrics, <span class="keyword">null</span>);</span><br><span class="line">              assmgr.setConfiguration(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                              <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,Build.VERSION.RESOURCES_SDK_INT);</span><br><span class="line">          <span class="comment">/*获得一个XML资源解析对象，该对象解析的是APK中的AndroidManifest.xml文件。</span></span><br><span class="line"><span class="comment">           以后再讨论AssetManager、Resource及相关的知识</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">          parser = assmgr.openXmlResourceParser(cookie,                                            ANDROID_MANIFEST_FILENAME);</span><br><span class="line">               assetError = <span class="keyword">false</span>;</span><br><span class="line">           &#125; ......<span class="comment">//出错处理</span></span><br><span class="line">       String[] errorText = <span class="keyword">new</span> String[<span class="number">1</span>];</span><br><span class="line">       Package pkg = <span class="keyword">null</span>;</span><br><span class="line">       Exception errorException = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//调用另外一个parsePackage函数</span></span><br><span class="line">           pkg = parsePackage(res, parser, flags, errorText);</span><br><span class="line"></span><br><span class="line">        &#125; ......</span><br><span class="line">        ......<span class="comment">//错误处理</span></span><br><span class="line">       parser.close();</span><br><span class="line">       assmgr.close();</span><br><span class="line">       <span class="comment">//保存文件路径，都指向APK文件所在的路径</span></span><br><span class="line">       pkg.mPath = destCodePath;</span><br><span class="line">       pkg.mScanPath = mArchiveSourcePath;</span><br><span class="line">       pkg.mSignatures = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">return</span> pkg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2017/08/01/PackageManagerService/20150803110542379.png" alt="PackageParser"></p><ul><li><code>PackageParser</code>定了相当多的内部类，这些内部类的作用就是保存对应的信息。解析AndroidManifest.xml文件得到的信息由Package保存。从该类的成员变量可看出，和Android四大组件相关的信息分别由<code>activites</code>、<code>receivers</code>、<code>providers</code>、<code>services</code>保存。由于一个APK可声明多个组件，因此activites和receivers等均声明为ArrayList。</li><li>以<code>PackageParser.Activity</code>为例，它从<code>Component&lt;ActivityIntentInfo&gt;</code>派生。Component是一个模板类，元素类型是ActivityIntentInfo，此类的顶层基类是IntentFilter。<code>PackageParser.Activity</code>内部有一个ActivityInfo类型的成员变量，该变量保存的就是四大组件中Activity的信息。</li><li>Package除了保存信息外，还需要支持Intent匹配查询。例如，设置Intent的Action为某个特定值，然后查找匹配该Intent的Activity。由于ActivityIntentInfo是从IntentFilter派生的，因此它它能判断自己是否满足该Intent的要求，如果满足，则返回对应的ActivityInfo。</li><li>PackageParser定了一个轻量级的数据结构PackageLite，该类仅存储Package的一些简单信息。我们在介绍Package安装的时候，会遇到PackageLite。</li></ul><h3 id="4-2-4scanPackageLI"><a href="#4-2-4scanPackageLI" class="headerlink" title="4.2.4scanPackageLI"></a>4.2.4scanPackageLI</h3><p>在PackageParser扫描完一个APK后，此时系统已经根据该APK中AndroidManifest.xm，创建了一个完整的Package对象，下一步就是将该Package加入到系统中。此时调用的函数就是另外一个scanPackageLI，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PackageParser.<span class="function">Package <span class="title">scanPackageLI</span><span class="params">(PackageParser.Package pkg,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> parseFlags, <span class="keyword">int</span> scanMode, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">        FilescanFile = <span class="keyword">new</span> File(pkg.mScanPath);</span><br><span class="line">        ......</span><br><span class="line">       mScanningPath = scanFile;</span><br><span class="line">        <span class="comment">//设置package对象中applicationInfo的flags标签，用于标示该Package为系统Package</span></span><br><span class="line">        <span class="keyword">if</span>((parseFlags&amp;PackageParser.PARSE_IS_SYSTEM) != <span class="number">0</span>) &#123;</span><br><span class="line">           pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.下面这句if判断极为重要，见下面的解释</span></span><br><span class="line">        <span class="keyword">if</span>(pkg.packageName.equals(<span class="string">"android"</span>)) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">               <span class="keyword">if</span> (mAndroidApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  ......</span><br><span class="line">               mPlatformPackage = pkg;</span><br><span class="line">               pkg.mVersionCode = mSdkVersion;</span><br><span class="line">               mAndroidApplication = pkg.applicationInfo;</span><br><span class="line">               mResolveActivity.applicationInfo = mAndroidApplication;</span><br><span class="line">               mResolveActivity.name = ResolverActivity.class.getName();</span><br><span class="line">               mResolveActivity.packageName = mAndroidApplication.packageName;</span><br><span class="line">               mResolveActivity.processName = mAndroidApplication.processName;</span><br><span class="line">               mResolveActivity.launchMode = ActivityInfo.LAUNCH_MULTIPLE;</span><br><span class="line">               mResolveActivity.flags = ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;</span><br><span class="line">               mResolveActivity.theme =</span><br><span class="line">                          com.android.internal.R.style.Theme_Holo_Dialog_Alert;</span><br><span class="line">               mResolveActivity.exported = <span class="keyword">true</span>;</span><br><span class="line">               mResolveActivity.enabled = <span class="keyword">true</span>;</span><br><span class="line">               <span class="comment">//mResoveInfo的activityInfo成员指向mResolveActivity</span></span><br><span class="line">               mResolveInfo.activityInfo = mResolveActivity;</span><br><span class="line">               mResolveInfo.priority = <span class="number">0</span>;</span><br><span class="line">               mResolveInfo.preferredOrder = <span class="number">0</span>;</span><br><span class="line">               mResolveInfo.match = <span class="number">0</span>;</span><br><span class="line">               mResolveComponentName = <span class="keyword">new</span> ComponentName(</span><br><span class="line">                       mAndroidApplication.packageName, mResolveActivity.name);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>packageName为“android”的Package对应的APK是framework-res.apk.framework-res.apk还包含了以下几个常用的Activity。</p><ul><li><code>ChooserActivity</code>：当多个Activity符合某个Intent的时候，系统会弹出此Activity，由用户选择合适的应用来处理。</li><li><code>RingtonePickerActivity</code>：铃声选择Activity</li><li><code>ShutdownActivity</code>：关机前弹出的选择对话框。</li></ul><p>由前述知识可知，该Package和系统息息相关，因此它得到了PKMS的特别青睐，主要体现在以下几点。</p><ul><li><code>mPlatformPackage</code>成员用于保存该Package信息。</li><li><code>mAndroidApplication</code>用于保存此Package中的ApplicationInfo。</li><li><code>mResolveActivity</code>指向用于表示ChooserActivity信息的ActivityInfo。</li><li><code>mResolveInfo</code>为ResolveInfo类型，它用于存储系统解析Intent（经IntentFilter的过滤）后得到的结果信息，例如满足某个Intent的Activity的信息。由前面的代码可知，mResolveInfo的activityInfo其实指向的就是mResolveActivity。</li></ul><p><strong>注意</strong>在从PKMS中查询满足某个Intent的Activity时，返回的就是ResolveInfo，再根据ResolveInfo的信息得到具体的Activity。<br>此处保存这些信息，主要是为了提高运行过程中的效率。Goolge工程师可能觉得ChooserActivity使用的地方比较多，所以这里单独保存了此Activity的信息。<br>继续对scanPackageLI函数的分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mPackages用于保存系统内的所有Package，以packageName为key</span></span><br><span class="line"><span class="keyword">if</span>(mPackages.containsKey(pkg.packageName)</span><br><span class="line">               || mSharedLibraries.containsKey(pkg.packageName)) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">File destCodeFile = newFile(pkg.applicationInfo.sourceDir);</span><br><span class="line">FiledestResourceFile = <span class="keyword">new</span> File(pkg.applicationInfo.publicSourceDir);</span><br><span class="line">SharedUserSettingsuid = <span class="keyword">null</span>;<span class="comment">//代表该Package的SharedUserSetting对象</span></span><br><span class="line">PackageSetting pkgSetting = <span class="keyword">null</span>;<span class="comment">//代表该Package的PackageSetting对象</span></span><br><span class="line"><span class="keyword">synchronized</span>(mPackages) &#123;</span><br><span class="line">   <span class="comment">//此段代码大约有300行左右，主要做了以下几方面工作</span></span><br><span class="line">   <span class="comment">/*1.如果该Packge声明了” uses-librarie”话，那么系统要判断该library是否在mSharedLibraries中</span></span><br><span class="line"><span class="comment">     2.如果package声明了SharedUser，则需要处理SharedUserSettings相关内容,由Settings的getSharedUserLPw函数处理</span></span><br><span class="line"><span class="comment"> 3.处理pkgSetting，通过调用Settings的getPackageLPw函数完成</span></span><br><span class="line"><span class="comment">     4.调用verifySignaturesLP函数，检查该Package的signature</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">long</span> scanFileTime = scanFile.lastModified();</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">boolean</span> forceDex = (scanMode&amp;SCAN_FORCE_DEX) != <span class="number">0</span>;</span><br><span class="line">   <span class="comment">//确定运行该package的进程的进程名，一般用packageName作为进程名</span></span><br><span class="line">   pkg.applicationInfo.processName = fixProcessName(</span><br><span class="line">                         pkg.applicationInfo.packageName,</span><br><span class="line">                         pkg.applicationInfo.processName,</span><br><span class="line">                         pkg.applicationInfo.uid);</span><br><span class="line">      <span class="keyword">if</span>(mPlatformPackage == pkg) &#123;</span><br><span class="line">           dataPath = <span class="keyword">new</span> File (Environment.getDataDirectory(),<span class="string">"system"</span>);</span><br><span class="line">           pkg.applicationInfo.dataDir = dataPath.getPath();</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*getDataPathForPackage函数返回该package的目录</span></span><br><span class="line"><span class="comment">            一般是/data/data/packageName/</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           dataPath = getDataPathForPackage(pkg.packageName, <span class="number">0</span>);</span><br><span class="line">           <span class="keyword">if</span>(dataPath.exists())&#123;</span><br><span class="line">             ......<span class="comment">//如果该目录已经存在，则要处理uid的问题</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//向installd发送install命令，实际上就是在/data/data下</span></span><br><span class="line">              <span class="comment">//建立packageName目录。后续将分析installd相关知识</span></span><br><span class="line">              <span class="keyword">int</span> ret = mInstaller.install(pkgName, pkg.applicationInfo.uid,</span><br><span class="line">                       pkg.applicationInfo.uid);</span><br><span class="line">              <span class="comment">//为系统所有user安装此程序</span></span><br><span class="line">               mUserManager.installPackageForAllUsers(pkgName,pkg.applicationInfo.uid);</span><br><span class="line">               <span class="keyword">if</span> (dataPath.exists()) &#123;</span><br><span class="line">                   pkg.applicationInfo.dataDir = dataPath.getPath();</span><br><span class="line">               &#125; ......</span><br><span class="line">               <span class="keyword">if</span> (pkg.applicationInfo.nativeLibraryDir == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                      pkg.applicationInfo.dataDir!= <span class="keyword">null</span>) &#123;</span><br><span class="line">               ......<span class="comment">//为该Package确定native library所在目录</span></span><br><span class="line">              <span class="comment">//一般是/data/data/packagename/lib</span></span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果该APK包含了native动态库，则需要将它们从APK文件中解压并复制到对应目录中</span></span><br><span class="line">    <span class="keyword">if</span>(pkg.applicationInfo.nativeLibraryDir != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">final</span> File nativeLibraryDir = <span class="keyword">new</span></span><br><span class="line">                            File(pkg.applicationInfo.nativeLibraryDir);</span><br><span class="line">               <span class="keyword">final</span> String dataPathString = dataPath.getCanonicalPath();</span><br><span class="line">               <span class="comment">//从2.3开始，系统package的native库统一放在/system/lib下。所以</span></span><br><span class="line">               <span class="comment">//系统不会提取系统Package目录下APK包中的native库</span></span><br><span class="line">               <span class="keyword">if</span> (isSystemApp(pkg) &amp;&amp; !isUpdatedSystemApp(pkg)) &#123;</span><br><span class="line">                   NativeLibraryHelper.removeNativeBinariesFromDirLI(</span><br><span class="line">                                            nativeLibraryDir))&#123;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nativeLibraryDir.getParentFile().getCanonicalPath()</span><br><span class="line">                       .equals(dataPathString)) &#123;</span><br><span class="line">                   <span class="keyword">boolean</span> isSymLink;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                        isSymLink = S_ISLNK(Libcore.os.lstat(</span><br><span class="line">                                        nativeLibraryDir.getPath()).st_mode);</span><br><span class="line">                   &#125; ......<span class="comment">//判断是否为链接，如果是，需要删除该链接</span></span><br><span class="line">                   <span class="keyword">if</span> (isSymLink) &#123;</span><br><span class="line">                       mInstaller.unlinkNativeLibraryDirectory(dataPathString);</span><br><span class="line">                   &#125;</span><br><span class="line">             <span class="comment">//在lib下建立和CPU类型对应的目录，例如ARM平台的是arm/，MIPS平台的是mips/</span></span><br><span class="line">               NativeLibraryHelper.copyNativeBinariesIfNeededLI(scanFile,</span><br><span class="line">                                   nativeLibraryDir);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   mInstaller.linkNativeLibraryDirectory(dataPathString,</span><br><span class="line">                                       pkg.applicationInfo.nativeLibraryDir);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; ......</span><br><span class="line">        &#125;</span><br><span class="line">     pkg.mScanPath= path;</span><br><span class="line">     <span class="keyword">if</span>((scanMode&amp;SCAN_NO_DEX) == <span class="number">0</span>) &#123;</span><br><span class="line">            ......<span class="comment">//对该APK做dex优化</span></span><br><span class="line">        performDexOptLI(pkg,forceDex, (scanMode&amp;SCAN_DEFER_DEX);</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">//如果该APK已经存在，要先杀掉运行该APK的进程</span></span><br><span class="line">     <span class="keyword">if</span>((parseFlags &amp; PackageManager.INSTALL_REPLACE_EXISTING) != <span class="number">0</span>) &#123;</span><br><span class="line">           killApplication(pkg.applicationInfo.packageName,</span><br><span class="line">                       pkg.applicationInfo.uid);</span><br><span class="line">     &#125;</span><br><span class="line">......__________________________________________________________________________</span><br><span class="line">     <span class="comment">/*在此之前，四大组件信息都属于Package的私有财产，现在需要把它们登记注册到PKMS内部的</span></span><br><span class="line"><span class="comment">     财产管理对象中。这样，PKMS就可对外提供统一的组件信息，而不必拘泥于具体的Package*/</span></span><br><span class="line">   <span class="keyword">synchronized</span>(mPackages) &#123;</span><br><span class="line">   <span class="keyword">if</span> ((scanMode&amp;SCAN_MONITOR) != <span class="number">0</span>) &#123;</span><br><span class="line">        mAppDirs.put(pkg.mPath, pkg);</span><br><span class="line">   &#125;</span><br><span class="line">   mSettings.insertPackageSettingLPw(pkgSetting, pkg);</span><br><span class="line">   mPackages.put(pkg.applicationInfo.packageName,pkg);</span><br><span class="line">   <span class="comment">//1.处理该Package中的Provider信息</span></span><br><span class="line">   <span class="keyword">int</span> N =pkg.providers.size();</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N; i++) &#123;</span><br><span class="line">   PackageParser.Providerp = pkg.providers.get(i);</span><br><span class="line">   p.info.processName=fixProcessName(</span><br><span class="line">                               pkg.applicationInfo.processName,</span><br><span class="line">                  p.info.processName, pkg.applicationInfo.uid);</span><br><span class="line">    <span class="comment">//mProvidersByComponent提供基于ComponentName的Provider信息查询</span></span><br><span class="line">    mProvidersByComponent.put(<span class="keyword">new</span> ComponentName(</span><br><span class="line">                               p.info.packageName,p.info.name), p);</span><br><span class="line">            ......</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.处理该Package中的Service信息</span></span><br><span class="line">   N =pkg.services.size();</span><br><span class="line">   r = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N; i++) &#123;</span><br><span class="line">   PackageParser.Service s =pkg.services.get(i);</span><br><span class="line">   mServices.addService(s);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3.处理该Package中的BroadcastReceiver信息</span></span><br><span class="line">   N =pkg.receivers.size();</span><br><span class="line">   r = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N; i++) &#123;</span><br><span class="line">   PackageParser.Activity a =pkg.receivers.get(i);</span><br><span class="line">   mReceivers.addActivity(a,<span class="string">"receiver"</span>);</span><br><span class="line">   ......</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//处理该Package中的Activity信息</span></span><br><span class="line">   N = pkg.activities.size();</span><br><span class="line">   r =<span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">   PackageParser.Activity a =pkg.activities.get(i);</span><br><span class="line">   mActivities.addActivity(a,<span class="string">"activity"</span>);<span class="comment">//后续将详细分析该调用</span></span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//处理该Package中的PermissionGroups信息</span></span><br><span class="line">   N = pkg.permissionGroups.size();</span><br><span class="line">   ......<span class="comment">//permissionGroups处理</span></span><br><span class="line">   N =pkg.permissions.size();</span><br><span class="line">   ......<span class="comment">//permissions处理</span></span><br><span class="line">   N =pkg.instrumentation.size();</span><br><span class="line">   ......<span class="comment">//instrumentation处理</span></span><br><span class="line">   <span class="keyword">if</span>(pkg.protectedBroadcasts != <span class="keyword">null</span>) &#123;</span><br><span class="line">      N = pkg.protectedBroadcasts.size();</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">   ......<span class="comment">//Package的私有财产终于完成了公有化改造</span></span><br><span class="line"><span class="keyword">return</span> pkg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-5scanDirLI函数总结"><a href="#4-2-5scanDirLI函数总结" class="headerlink" title="4.2.5scanDirLI函数总结"></a>4.2.5scanDirLI函数总结</h3><p>scanDirLI用于对指定目录下的APK文件进行扫描，如图4-7所示为该函数的调用流程。<br><img src="/2017/08/01/PackageManagerService/20150803110657112.png" alt="scanDirLI"></p><p>扫描完APK文件后，Package的私有财产就充公了。PKMS提供了好几个重要数据结构来保存这些财产，这些数据结构的相关信息<br><img src="/2017/08/01/PackageManagerService/20150803110726269.png" alt="datastruct"></p><h2 id="4-3扫描非系统Package"><a href="#4-3扫描非系统Package" class="headerlink" title="4.3扫描非系统Package"></a>4.3扫描非系统Package</h2><p>非系统Package就是指那些不存储在系统目录下的APK文件，这部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!mOnlyCore) &#123;<span class="comment">//mOnlyCore用于控制是否扫描非系统Package</span></span><br><span class="line">   Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator();</span><br><span class="line">   <span class="keyword">while</span> (psit.hasNext()) &#123;</span><br><span class="line">      ......<span class="comment">//删除系统package中那些不存在的APK</span></span><br><span class="line">   &#125;</span><br><span class="line">   mAppInstallDir = <span class="keyword">new</span> File(dataDir,<span class="string">"app"</span>);</span><br><span class="line">   .....<span class="comment">//删除安装不成功的文件及临时文件</span></span><br><span class="line">   <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">     <span class="comment">//在普通模式下，还需要扫描/data/app以及/data/app_private目录 </span></span><br><span class="line">     mAppInstallObserver = <span class="keyword">new</span> AppDirObserver(mAppInstallDir.getPath(), OBSERVER_EVENTS, <span class="keyword">false</span>);</span><br><span class="line">     mAppInstallObserver.startWatching();</span><br><span class="line">     scanDirLI(mAppInstallDir, <span class="number">0</span>, scanMode, <span class="number">0</span>);</span><br><span class="line">     mDrmAppInstallObserver = newAppDirObserver(mDrmAppPrivateInstallDir.getPath(), OBSERVER_EVENTS, <span class="keyword">false</span>);</span><br><span class="line">     mDrmAppInstallObserver.startWatching();</span><br><span class="line">     scanDirLI(mDrmAppPrivateInstallDir,         PackageParser.PARSE_FORWARD_LOCK,scanMode,<span class="number">0</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     mAppInstallObserver = <span class="keyword">null</span>;</span><br><span class="line">     mDrmAppInstallObserver = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合前述代码，这里总结几个存放APK文件的目录。</p><ul><li>系统Package目录包括：<code>/system/frameworks</code>、<code>/system/app</code>和<code>/vendor/app</code>。</li><li>非系统Package目录包括：<code>/data/app</code>、<code>/data/app-private</code>。</li></ul><h2 id="4-4-第二阶段工作总结"><a href="#4-4-第二阶段工作总结" class="headerlink" title="4.4 第二阶段工作总结"></a>4.4 第二阶段工作总结</h2><p>PKMS构造函数第二阶段的工作任务非常繁重，要创建比较多的对象，所以它是一个耗时耗内存的操作。在工作中，我们一直想优化该流程以加快启动速度，例如延时扫描不重要的APK，或者保存Package信息到文件中，然后在启动时从文件中恢复这些信息以减少APK文件读取并解析XML的工作量。但是一直没有一个比较完满的解决方案，原因有很多。比如APK之间有着比较微妙的依赖关系，因此到底延时扫描哪些APK，尚不能确定。</p><h1 id="5-扫描之后"><a href="#5-扫描之后" class="headerlink" title="5.扫描之后"></a>5.扫描之后</h1><p>这部分任务比较简单，就是将第二阶段收集的信息再集中整理一次，比如将有些信息保存到文件中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">mSettings.mInternalSdkPlatform= mSdkVersion;</span><br><span class="line"><span class="comment">//汇总并更新和Permission相关的信息</span></span><br><span class="line">updatePermissionsLPw(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">true</span>,regrantPermissions,regrantPermissions);</span><br><span class="line"><span class="comment">//将信息写到package.xml、package.list及package-stopped.xml文件中</span></span><br><span class="line">mSettings.writeLPr();</span><br><span class="line">Runtime.getRuntime().gc();</span><br><span class="line">mRequiredVerifierPackage= getRequiredVerifierLPr();</span><br><span class="line">......<span class="comment">//PKMS构造函数返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-PKMS构造函数总结"><a href="#6-PKMS构造函数总结" class="headerlink" title="6.PKMS构造函数总结"></a>6.PKMS构造函数总结</h1><p>从流程角度看，PKMS构造函数的功能还算清晰，无非是扫描XML或APK文件，但是其中涉及的数据结构及它们之间的关系却较为复杂。</p><ul><li><p>理解PKMS构造函数工作的三个阶段及其各阶段的工作职责。</p></li><li><p>了解PKMS第二阶段工作中解析APK文件的几个关键步骤.</p></li><li><p>了解重点数据结构的名字和大体功能。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-概述&quot;&gt;&lt;a href=&quot;#0-概述&quot; class=&quot;headerlink&quot; title=&quot;0.概述&quot;&gt;&lt;/a&gt;0.概述&lt;/h1&gt;&lt;p&gt;PackageManagerService是本书分析的第一个核心服务，也是Android系统中最常用的服务之一。它负责系统中&lt;code&gt;Package的管理&lt;/code&gt;，&lt;code&gt;应用程序的安装&lt;/code&gt;、&lt;code&gt;卸载&lt;/code&gt;、&lt;code&gt;信息查询&lt;/code&gt;等.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android组件" scheme="http://yoursite.com/tags/Android%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>ActivityManagerService</title>
    <link href="http://yoursite.com/2017/08/01/ActivityManagerService/"/>
    <id>http://yoursite.com/2017/08/01/ActivityManagerService/</id>
    <published>2017-07-31T19:47:00.000Z</published>
    <updated>2019-02-02T11:21:31.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>AMS是Android中<code>最核心的服务</code>，主要负责系统中<code>四大组件的启动</code>、<code>切换</code>、<code>调度</code>及<code>应用进程的管理和调度</code>等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要。</p><a id="more"></a><ul><li><code>ActivityManagerService extends ActivityManagerNative implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback</code></li><li>客户端使用ActivityManager类。由于AMS是系统核心服务，很多API不能开放供客户端使用，所以设计者没有让ActivityManager直接加入AMS家族。在ActivityManager类内部通过调用AMN的getDefault函数得到一个ActivityManagerProxy对象，通过它可与AMS通信。</li></ul><h1 id="1-AMS启动"><a href="#1-AMS启动" class="headerlink" title="1.AMS启动"></a>1.AMS启动</h1><p>AMS由SystemServer的ServerThread线程创建，提取它的调用轨迹，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//path:SystemServer.java::initAndLoop()</span></span><br><span class="line"><span class="comment">//1.Boolean:factoryTest SystemProperties.get("ro.factorytest");是否厂测</span></span><br><span class="line">Context context=ActivityManagerService.main(factoryTest);</span><br><span class="line"><span class="comment">//2.setSystemProcess：这样SystemServer进程可加到AMS中，并被它管理</span></span><br><span class="line">ActivityManagerService.setSystemProcess();</span><br><span class="line"><span class="comment">//3.installSystemProviders：将SettingsProvider放到SystemServer进程中来运行</span></span><br><span class="line">ActivityManagerService.installSystemProviders();</span><br><span class="line"><span class="comment">//4.在内部保存WindowManagerService（以后简称WMS）</span></span><br><span class="line">ActivityManagerService.self().setWindowManager(wm);</span><br><span class="line"><span class="comment">//5.AMS是系统的核心，只有它准备好后，才能调用其他服务的systemReady,少量之前那完成。</span></span><br><span class="line"> ActivityManagerService.self().systemReady(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Slog.i(TAG, <span class="string">"Making services ready"</span>);</span><br><span class="line">       ActivityManagerService.self().startObservingNativeCrashes();</span><br><span class="line">      <span class="comment">// 如此，状态栏就准备好了</span></span><br><span class="line">      <span class="comment">//SystemUIService由SystemUi.apk提供，它实现了系统的状态栏。</span></span><br><span class="line">       <span class="keyword">if</span> (!headless) startSystemUi(contextF);</span><br><span class="line">       <span class="keyword">if</span> (mountServiceF != <span class="keyword">null</span>) mountServiceF.systemReady();</span><br><span class="line">       <span class="keyword">if</span> (batteryF != <span class="keyword">null</span>) batteryF.systemReady();</span><br><span class="line">       <span class="keyword">if</span> (networkManagementF != <span class="keyword">null</span>) networkManagementF.systemReady();</span><br><span class="line">       <span class="keyword">if</span> (networkStatsF != <span class="keyword">null</span>) networkStatsF.systemReady();</span><br><span class="line">       <span class="keyword">if</span> (networkPolicyF != <span class="keyword">null</span>) networkPolicyF.systemReady();</span><br><span class="line">       <span class="keyword">if</span> (connectivityF != <span class="keyword">null</span>) connectivityF.systemReady();</span><br><span class="line">       <span class="keyword">if</span> (dockF != <span class="keyword">null</span>) dockF.systemReady();</span><br><span class="line">       <span class="keyword">if</span> (usbF != <span class="keyword">null</span>) usbF.systemReady();</span><br><span class="line">       <span class="keyword">if</span> (twilightF != <span class="keyword">null</span>) twilightF.systemReady();</span><br><span class="line">       <span class="keyword">if</span> (uiModeF != <span class="keyword">null</span>) uiModeF.systemReady();</span><br><span class="line">       <span class="keyword">if</span> (recognitionF != <span class="keyword">null</span>) recognitionF.systemReady();</span><br><span class="line">       Watchdog.getInstance().start();</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span>It is now okay to let the various system services start their third party code...</span></span><br><span class="line">       <span class="keyword">if</span> (appWidgetF != <span class="keyword">null</span>) appWidgetF.systemRunning(safeMode);</span><br><span class="line">       <span class="keyword">if</span> (wallpaperF != <span class="keyword">null</span>) wallpaperF.systemRunning();</span><br><span class="line">       <span class="keyword">if</span> (immF != <span class="keyword">null</span>) immF.systemRunning(statusBarF);     </span><br><span class="line">       <span class="keyword">if</span> (locationF != <span class="keyword">null</span>) locationF.systemRunning();</span><br><span class="line">       <span class="keyword">if</span> (countryDetectorF != <span class="keyword">null</span>) countryDetectorF.systemRunning();</span><br><span class="line">       <span class="keyword">if</span> (networkTimeUpdaterF != <span class="keyword">null</span>) networkTimeUpdaterF.systemRunning();</span><br><span class="line">       <span class="keyword">if</span> (commonTimeMgmtServiceF != <span class="keyword">null</span>) commonTimeMgmtServiceF.systemRunning();</span><br><span class="line">        ...</span><br><span class="line">       <span class="comment">// For debug builds, log event loop stalls to dropbox for analysis.</span></span><br><span class="line">        <span class="keyword">if</span> (StrictMode.conditionallyEnableDebugLogging()) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">"Enabled StrictMode for system server main thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Looper.loop();</span><br><span class="line">        Slog.d(TAG, <span class="string">"System ServerThread is exiting!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将分析除了4外的掉用。</p><h2 id="1-1-ActivityManagerService-main"><a href="#1-1-ActivityManagerService-main" class="headerlink" title="1.1 ActivityManagerService.main"></a>1.1 ActivityManagerService.main</h2><p>AMS的main函数将返回一个<code>Context</code>类型的对象，该对象在SystemServer中被其他服务大量使用。<code>Context</code>，顾名思义，代表了一种上下文环境，有了这个环境，我们就可以做很多事情（例如获取该环境中的资源、Java类信息等）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Context <span class="title">main</span><span class="params">(<span class="keyword">int</span> factoryTest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//线程中完成：</span></span><br><span class="line">    <span class="comment">//1.ActivityManagerService m = new ActivityManagerService();</span></span><br><span class="line">    <span class="comment">//mService = m;通知实例好了，则thr.mService!=null</span></span><br><span class="line">    AThread thr = <span class="keyword">new</span> AThread();</span><br><span class="line">    thr.start();</span><br><span class="line">    <span class="keyword">while</span> (thr.mService == <span class="keyword">null</span>) thr.wait();<span class="comment">//收到通知，继续</span></span><br><span class="line">    ActivityManagerService m = thr.mService;</span><br><span class="line">    mSelf = m;</span><br><span class="line">    <span class="comment">//2.ActivityThread它代表一个应用进程的主线程，其职责就是调度及执行在该线程中运行的四大组件。</span></span><br><span class="line">    ActivityThread at = ActivityThread.systemMain();</span><br><span class="line">    mSystemThread = at;</span><br><span class="line">    <span class="comment">//3.接口获取并操作Application对应的资源、类，甚至包含于Application中的四大组件。</span></span><br><span class="line">    Context context = at.getSystemContext();</span><br><span class="line">    context.setTheme(android.R.style.Theme_Holo);</span><br><span class="line">    m.mContext = context;</span><br><span class="line">    m.mFactoryTest = factoryTest;</span><br><span class="line">    m.mIntentFirewall = <span class="keyword">new</span> IntentFirewall(m.new IntentFirewallInterface());</span><br><span class="line">    <span class="comment">//AMS中用来管理Activity的启动和调度的核心类</span></span><br><span class="line">    m.mStackSupervisor = <span class="keyword">new</span> ActivityStackSupervisor(m, context, thr.mLooper);</span><br><span class="line">    m.mBatteryStatsService.publish(context);</span><br><span class="line">    m.mUsageStatsService.publish(context);</span><br><span class="line">    m.mAppOpsService.publish(context);</span><br><span class="line">    thr.mReady = <span class="keyword">true</span>;</span><br><span class="line">    thr.notifyAll();</span><br><span class="line">    <span class="comment">//4.启动startRunning函数</span></span><br><span class="line">    m.startRunning(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main函数中，完成mSystemThread等全局变量填充和调用了startRunning函数.。主要分析<code>ActivityManagerService</code>构造函数。<br>和几个全局变量。</p><h3 id="1-1-1-AMS构造函数"><a href="#1-1-1-AMS构造函数" class="headerlink" title="1.1.1 AMS构造函数"></a>1.1.1 AMS构造函数</h3><p>AMS的构造函数的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ActivityManagerService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建广播队列(前台和后台队列)</span></span><br><span class="line">mFgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, <span class="string">"foreground"</span>, BROADCAST_FG_TIMEOUT, <span class="keyword">false</span>);</span><br><span class="line">mBgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, <span class="string">"background"</span>, BROADCAST_BG_TIMEOUT, <span class="keyword">true</span>);</span><br><span class="line"> mBroadcastQueues[<span class="number">0</span>] = mFgBroadcastQueue;</span><br><span class="line"> mBroadcastQueues[<span class="number">1</span>] = mBgBroadcastQueue;</span><br><span class="line"><span class="comment">//service和provider</span></span><br><span class="line"> mServices = <span class="keyword">new</span> ActiveServices(<span class="keyword">this</span>);</span><br><span class="line"> mProviderMap = <span class="keyword">new</span> ProviderMap(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//创建/data/system/</span></span><br><span class="line"> File dataDir = Environment.getDataDirectory();</span><br><span class="line"> File systemDir = <span class="keyword">new</span> File(dataDir, <span class="string">"system"</span>);</span><br><span class="line"> systemDir.mkdirs();</span><br><span class="line"> <span class="comment">// 电源服务一些信息/data/system/batterystats.bin</span></span><br><span class="line"> mBatteryStatsService = <span class="keyword">new</span> BatteryStatsService(<span class="keyword">new</span> File(</span><br><span class="line">         systemDir, <span class="string">"batterystats.bin"</span>).toString());</span><br><span class="line"> mBatteryStatsService.getActiveStatistics().readLocked();</span><br><span class="line"> mBatteryStatsService.getActiveStatistics().writeAsyncLocked();</span><br><span class="line"> mOnBattery = DEBUG_POWER ? <span class="keyword">true</span></span><br><span class="line">         : mBatteryStatsService.getActiveStatistics().getIsOnBattery();</span><br><span class="line"> mBatteryStatsService.getActiveStatistics().setCallback(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//进程状态 /data/system/procstates</span></span><br><span class="line"> mProcessStats = <span class="keyword">new</span> ProcessStatsService(<span class="keyword">this</span>, <span class="keyword">new</span> File(systemDir, <span class="string">"procstats"</span>));</span><br><span class="line"> <span class="comment">//使用状态 /data/system/usagestats</span></span><br><span class="line">mUsageStatsService = <span class="keyword">new</span> UsageStatsService(<span class="keyword">new</span> File(systemDir, <span class="string">"usagestats"</span>).toString());</span><br><span class="line"><span class="comment">// Ops状态 /data/system/appops.xml</span></span><br><span class="line"> mAppOpsService = <span class="keyword">new</span> AppOpsService(<span class="keyword">new</span> File(systemDir, <span class="string">"appops.xml"</span>));</span><br><span class="line"><span class="comment">// Uri授权记录 /data/system/urigrants.xml</span></span><br><span class="line"> mGrantFile = <span class="keyword">new</span> AtomicFile(<span class="keyword">new</span> File(systemDir, <span class="string">"urigrants.xml"</span>));</span><br><span class="line"></span><br><span class="line"> mHeadless = <span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"ro.config.headless"</span>, <span class="string">"0"</span>));</span><br><span class="line"></span><br><span class="line"> <span class="comment">// User 0 is the first and only user that runs at boot.</span></span><br><span class="line"> mStartedUsers.put(<span class="number">0</span>, <span class="keyword">new</span> UserStartedState(<span class="keyword">new</span> UserHandle(<span class="number">0</span>), <span class="keyword">true</span>));</span><br><span class="line"> mUserLru.add(Integer.valueOf(<span class="number">0</span>));</span><br><span class="line"> updateStartedUserArrayLocked();</span><br><span class="line"></span><br><span class="line"> GL_ES_VERSION = SystemProperties.getInt(<span class="string">"ro.opengles.version"</span>,</span><br><span class="line">     ConfigurationInfo.GL_ES_VERSION_UNDEFINED);</span><br><span class="line"><span class="comment">//mConfiguration类型为Configuration，用于描述资源文件的配置属性，</span></span><br><span class="line"><span class="comment">//例如字体、语言等。后文再讨论这方面的内容</span></span><br><span class="line"> mConfiguration.setToDefaults();</span><br><span class="line"> mConfiguration.setLocale(Locale.getDefault());</span><br><span class="line"></span><br><span class="line"> mConfigurationSeq = mConfiguration.seq = <span class="number">1</span>;</span><br><span class="line"> mProcessCpuTracker.init();</span><br><span class="line"></span><br><span class="line"> mCompatModePackages = <span class="keyword">new</span> CompatModePackages(<span class="keyword">this</span>, systemDir);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Add ourself to the Watchdog monitors.</span></span><br><span class="line"> Watchdog.getInstance().addMonitor(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"> mProcessCpuThread = <span class="keyword">new</span> Thread(<span class="string">"CpuTracker"</span>)&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">             <span class="keyword">long</span> nextCpuDelay =(mLastCpuTime.get()+MONITOR_CPU_MAX_TIME)-now;</span><br><span class="line">              <span class="keyword">long</span> nextWriteDelay = (mLastWriteTime+BATTERY_STATS_TIME)-now;</span><br><span class="line">              <span class="comment">//Slog.i(TAG, "Cpu delay=" + nextCpuDelay</span></span><br><span class="line">               <span class="comment">//        + ", write delay=" + nextWriteDelay);</span></span><br><span class="line">              <span class="keyword">if</span> (nextWriteDelay &lt; nextCpuDelay) &#123;</span><br><span class="line">                    nextCpuDelay = nextWriteDelay;</span><br><span class="line">                &#125;</span><br><span class="line">                         <span class="keyword">if</span> (nextCpuDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                             mProcessCpuMutexFree.set(<span class="keyword">true</span>);</span><br><span class="line">                             <span class="keyword">this</span>.wait(nextCpuDelay);</span><br><span class="line">                         &#125;</span><br><span class="line">                 updateCpuStatsNow();</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> mProcessCpuThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数完成了：</p><ul><li>建立了<code>mFgBroadcastQueue</code>和<code>mBgBroadcastQueue</code>两个广播队列。</li><li><code>ActiveServices</code>和<code>providermap</code></li><li>建立<code>/data/system/</code>目录下一些信息，如：<code>/data/system/procstates</code>等一些配置信息初始化：字体，语言，等启动线程，cpu一些使用情况。</li></ul><h3 id="1-1-2-AT-systemMain"><a href="#1-1-2-AT-systemMain" class="headerlink" title="1.1.2 AT.systemMain"></a>1.1.2 AT.systemMain</h3><p><strong>注意</strong>:应用进程指那些运行APK的进程，它们由Zyote 派生（fork）而来，上面运行了dalvik虚拟机。与应用进程相对的就是系统进程（包括Zygote和SystemServer）。</p><p><strong>应用进程和系统进程</strong>与<strong>应用APK和系统APK</strong>的概念区分开来。APK的判别依赖其文件所在位置（如果apk文件在<code>/data/app</code>目录下，则为应用APK）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityThread <span class="title">systemMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//禁止硬件加速</span></span><br><span class="line">   HardwareRenderer.disable(<span class="keyword">true</span>);</span><br><span class="line">   ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">   thread.attach(<span class="keyword">true</span>);</span><br><span class="line">   <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面所说的<code>ActivityThread</code>代表应用进程（其上运行了APK）的主线程，而SystemServer并非一个应用进程，那么为什么此处也需要ActivityThread呢？</p><ul><li>还记得在PackageManagerService分析中提到的<code>framework-res.apk</code>吗？这个APK除了包含资源文件外，还包含一些Activity（如<code>关机对话框</code>），这些<code>Activity</code>实际上运行在<code>SystemServer</code>进程中。从这个角度看，SystemServer是一个特殊的应用进程。</li><li>另外，通过ActivityThread可以把Android系统提供的组件之间的交互机制和交互接口（如利用Context提供的API）也拓展到SystemServer中使用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//system=true</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">    sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">    mSystemThread = system;</span><br><span class="line">    <span class="keyword">if</span> (!system) &#123;<span class="comment">//应用进程处理流程</span></span><br><span class="line">        ViewRootImpl.addFirstDrawHandler(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ensureJitEnabled();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        android.ddm.DdmHandleAppName.setAppName(<span class="string">"&lt;pre-initialized&gt;"</span>,UserHandle.myUserId());</span><br><span class="line">        RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">        IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mgr.attachApplication(mAppThread);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//系统处理流程，systemServer中对应这个.</span></span><br><span class="line">        <span class="comment">// Don't set application object here -- if the system crashes,</span></span><br><span class="line">        <span class="comment">// we can't display an alert, we just want to die die die.</span></span><br><span class="line">        <span class="comment">//设置DDMS看到systemserver进程名为system_process</span></span><br><span class="line">        android.ddm.DdmHandleAppName.setAppName(<span class="string">"system_process"</span>,</span><br><span class="line">                                                UserHandle.myUserId());</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//Activity几员大将出场</span></span><br><span class="line">            mInstrumentation = <span class="keyword">new</span> Instrumentation();</span><br><span class="line">            ContextImpl context = <span class="keyword">new</span> ContextImpl();</span><br><span class="line">            context.init(getSystemContext().mPackageInfo, <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">            Application app = Instrumentation.newApplication(Application.class, context);</span><br><span class="line">            <span class="comment">//一个进程支持多个应用</span></span><br><span class="line">            mAllApplications.add(app);</span><br><span class="line">            mInitialApplication = app;</span><br><span class="line">            app.onCreate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Unable to instantiate Application():"</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add dropbox logging to libcore</span></span><br><span class="line">    DropBox.setReporter(<span class="keyword">new</span> DropBoxReporter());</span><br><span class="line">    <span class="comment">//监听配置改变，如语言切换时，需要调用。</span></span><br><span class="line">    ViewRootImpl.addConfigCallback(<span class="keyword">new</span> ComponentCallbacks2() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">                <span class="comment">// We need to apply this change to the resources</span></span><br><span class="line">                <span class="comment">// immediately, because upon returning the view</span></span><br><span class="line">                <span class="comment">// hierarchy will be informed about it.</span></span><br><span class="line">                <span class="keyword">if</span> (mResourcesManager.applyConfigurationToResourcesLocked(newConfig, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// This actually changed the resources!  Tell</span></span><br><span class="line">                    <span class="comment">// everyone about it.</span></span><br><span class="line">                    <span class="keyword">if</span> (mPendingConfiguration == <span class="keyword">null</span> ||</span><br><span class="line">                            mPendingConfiguration.isOtherSeqNewer(newConfig)) &#123;</span><br><span class="line">                        mPendingConfiguration = newConfig;</span><br><span class="line"></span><br><span class="line">                        sendMessage(H.CONFIGURATION_CHANGED, newConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLowMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Activity几员大将出场：</p><ul><li><code>Instrumentation</code>:一个工具类。当它被启用时，系统先创建它，再通过它来创建其他组件。系统和组件之间的交互也将通过<code>Instrumentation</code>来传递，这样，Instrumentation就能监测系统和这些组件的交互情况了。在实际使用中，我们可以创建Instrumentation的派生类来进行相应的处理。</li><li><code>Application</code>:保存了一个全局的application状态。Application由AndroidManifest.xml中的<code>&lt;application&gt;</code>标签声明。在实际使用时需定义Application的派生类。Application是Android中的一个概念，可理解为一种容器，它内部包含四大组件。另外，一个进程可以运行多个Application。</li><li><code>Context</code>是一个接口，通过它可以获取并操作Application对应的资源、类，甚至包含于Application中的四大组件。Context是一个抽象类，而由AMS创建的将是它的子类ContextImpl。</li></ul><h3 id="1-1-3-at-getSystemContext"><a href="#1-1-3-at-getSystemContext" class="headerlink" title="1.1.3 at.getSystemContext()"></a>1.1.3 at.getSystemContext()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ContextImpl <span class="title">getSystemContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mSystemContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ContextImpl context =</span><br><span class="line">                ContextImpl.createSystemContext(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//LoadedApk代表一个加载到系统中的APK</span></span><br><span class="line">            LoadedApk info = <span class="keyword">new</span> LoadedApk(<span class="keyword">this</span>, <span class="string">"android"</span>, context, <span class="keyword">null</span>,</span><br><span class="line">                    CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO);</span><br><span class="line">            context.init(info, <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">             <span class="comment">//初始化资源信息</span></span><br><span class="line">            context.getResources().updateConfiguration</span><br><span class="line">            (mResourcesManager.getConfiguration(),</span><br><span class="line">            getDisplayMetricsLocked(Display.DEFAULT_DISPLAY));</span><br><span class="line">            mSystemContext = context;</span><br><span class="line">            <span class="comment">//Slog.i(TAG, "Created system resources " + context.getResources()</span></span><br><span class="line">            <span class="comment">//        + ": " + context.getResources().getConfiguration());</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mSystemContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么函数名是getSystemContext呢？</p><ul><li>初始化ContextImp时使用了一个<code>LoadedApk</code>对象,package名为<code>android</code>,其实就是framework-res.apk,为了加载该APK。 </li></ul><p><img src="/2017/08/01/ActivityManagerService/2018031809480920.png" alt="Context家族图"></p><p>上述类中关系图：</p><ul><li>先来看派生关系,<code>ApplicationContentResolver</code>从<code>ConentResolver</code>派生，它主要用于和ContentProvider打交道。ContextImpl和ContextWrapper均从Context继承，而<code>Application</code>则从<code>ContextWrapper</code>派生。</li><li>从社会关系角度看，ContextImpl交际面最广。它通过mResources指向Resources，mPackageInfo指向LoadedApk，mMainThread指向ActivityThread，mContentResolver指向ApplicationContentResolver。</li></ul><p>对Context进行再议：</p><p><img src="/2017/08/01/ActivityManagerService/20180318095541276.png" alt="Context家族图"></p><p>由图可知:</p><ul><li><code>ContextWrapper</code>是一个代理类，被代理的对象是另外一个Context。被代理的类其实是ContextImpl，由ContextWrapper通过mBase成员变量指定。其内部函数功能的实现最终都由mBase完成。这样设计的目的是想把ContextImpl隐藏起来。</li><li>Application从ContextWrapper派生，并实现了ComponentCallbacks2接口。Application中有一个LoadedApk类型的成员变量mLoadedApk。<strong>LoadedApk代表一个APK文件</strong>。由于一个AndroidManifest.xml文件只能声明一个Application标签，所以一个Application必然会和一个LoadedApk绑定。</li><li>Service从ContextWrapper派生，其中Service内部成员变量mApplication指向Application（在AndroidManifest.xml中，Service只能作为Application的子标签，所以在代码中Service必然会和一个Application绑定）。</li><li>ContextThemeWrapper重载了和Theme（主题）相关的两个函数。这些和界面有关，所以Activity作为Android系统中的UI容器，必然也会从ContextThemeWrapper派生。与Service一样，Activity内部也通过mApplication成员变量指向Application。</li></ul><p><strong>systemMain函数总结</strong></p><ul><li>得到一个ActivityThread对象，它代表应用进程的主线程。</li><li>得到一个Context对象，它背后所指向的Application环境与framework-res.apk有关。</li></ul><p><strong>systemMain函数将为SystemServer进程搭建一个和应用进程一样的Android运行环境</strong>。这句话涉及两个概念。  </p><ul><li><code>进程</code>：来源于操作系统，是在OS中看到的运行体。我们编写的代码一定要运行在一个进程中。</li><li><code>Android运行环境</code>：Android努力构筑了一个自己的运行环境。在这个环境中，进程的概念被模糊化了。组件的运行及它们之间的交互均在该环境中实现。</li></ul><p>Android运行环境是构建在进程之上的。在应用程序中，一般只和Android运行环境交互。基于同样的道理，SystemServer希望它内部的那些Service也通过Android运行环境交互，因此也需为它创建一个运行环境。由于SystemServer的特殊性，此处调用了systemMain函数，而普通的应用进程将在主线程中调用ActivityThread的main函数来创建Android运行环境。</p><p>另外，ActivityThread虽然本意是代表进程的主线程，但是作为一个Java类，它的实例到底由什么线程创建，恐怕不是ActivityThread自己能做主的，所以在SystemServer中可以发现，ActivityThread对象由其他线程创建，而在应用进程中，ActivityThread将由主线程来创建。</p><h3 id="1-1-4-m-startRunning"><a href="#1-1-4-m-startRunning" class="headerlink" title="1.1.4 m.startRunning"></a>1.1.4 m.startRunning</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startRunning</span><span class="params">(String pkg, String cls, String action, String data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mStartRunning) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mStartRunning = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//mTopComponent最终赋值为null</span></span><br><span class="line">        mTopComponent = pkg != <span class="keyword">null</span> &amp;&amp; cls != <span class="keyword">null</span></span><br><span class="line">                ? <span class="keyword">new</span> ComponentName(pkg, cls) : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//mTopAction= Intent.ACTION_MAIN</span></span><br><span class="line">        mTopAction = action != <span class="keyword">null</span> ? action : Intent.ACTION_MAIN;</span><br><span class="line">        mTopData = data;<span class="comment">//mTopData最终为null</span></span><br><span class="line">        <span class="keyword">if</span> (!mSystemReady) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个函数很重要，可惜不在本次startRunning中调用</span></span><br><span class="line">    systemReady(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-AMS-setSystemProcess"><a href="#1-2-AMS-setSystemProcess" class="headerlink" title="1.2 AMS.setSystemProcess"></a>1.2 AMS.setSystemProcess</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setSystemProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ActivityManagerService m = mSelf;</span><br><span class="line">        <span class="comment">//向ServiceManager注册几个服务</span></span><br><span class="line">        ServiceManager.addService(Context.ACTIVITY_SERVICE, m, <span class="keyword">true</span>);</span><br><span class="line">        ServiceManager.addService(ProcessStats.SERVICE_NAME, m.mProcessStats);</span><br><span class="line">        ServiceManager.addService(<span class="string">"meminfo"</span>, <span class="keyword">new</span> MemBinder(m));</span><br><span class="line">        ServiceManager.addService(<span class="string">"gfxinfo"</span>, <span class="keyword">new</span> GraphicsBinder(m));<span class="comment">//显示加速方面的信息（Applications</span></span><br><span class="line">         Graphics Acceleration Info）， dumpsys gfxinfo</span><br><span class="line">        ServiceManager.addService(<span class="string">"dbinfo"</span>, <span class="keyword">new</span> DbBinder(m));</span><br><span class="line">        <span class="keyword">if</span> (MONITOR_CPU_USAGE) &#123;</span><br><span class="line">            ServiceManager.addService(<span class="string">"cpuinfo"</span>, <span class="keyword">new</span> CpuBinder(m));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向SM注册权限管理服务PermissionController</span></span><br><span class="line">        ServiceManager.addService(<span class="string">"permission"</span>, <span class="keyword">new</span> PermissionController(m));</span><br><span class="line">        <span class="comment">//虽然PKMS和AMS同属一个进程，但是二者交互仍然借助Context 其实，此处完全可以直接调用PKMS的函数。为什么要费如此周折呢   </span></span><br><span class="line">        ApplicationInfo info =</span><br><span class="line">            mSelf.mContext.getPackageManager().getApplicationInfo(</span><br><span class="line">                        <span class="string">"android"</span>, STOCK_PM_FLAGS);</span><br><span class="line">        <span class="comment">//1.installSystemApplicationInfo</span></span><br><span class="line">        mSystemThread.installSystemApplicationInfo(info);</span><br><span class="line">        <span class="keyword">synchronized</span> (mSelf) &#123;<span class="comment">//2.此处涉及AMS对进程的管理,processName=system</span></span><br><span class="line">            ProcessRecord app = mSelf.newProcessRecordLocked(info,</span><br><span class="line">                    info.processName, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//这里标识出systemProcess</span></span><br><span class="line">            app.persistent = <span class="keyword">true</span>;<span class="comment">//设置该值为true</span></span><br><span class="line">            app.pid = MY_PID;<span class="comment">//设置pid为SystemServer的进程号</span></span><br><span class="line">            app.maxAdj = ProcessList.SYSTEM_ADJ;<span class="comment">//设置最大OOM_Adj，系统进程默认值为-16</span></span><br><span class="line">            app.makeActive(mSystemThread.getApplicationThread(), mSelf.mProcessStats);</span><br><span class="line">            <span class="comment">//3.保存该ProcessRecord对象</span></span><br><span class="line">            mSelf.mProcessNames.put(app.processName, app.uid, app);</span><br><span class="line">            <span class="keyword">synchronized</span> (mSelf.mPidsSelfLocked) &#123;</span><br><span class="line">                mSelf.mPidsSelfLocked.put(app.pid, app);</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">//根据系统当前状态，调整进程的调度优先级和OOM_Adj，后续将详细分析该函数</span></span><br><span class="line">            mSelf.updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            mSelf.updateOomAdjLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to find android system package"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中列出了一个重要说明和两个关键点。</p><ul><li>AMS向PKMS查询名为“android”的ApplicationInfo。此处AMS和PKMS的交互是通过Context来完成的，查看这一系列函数调用的代码，最终发现AMS将通过Binder发送请求给PKMS来完成查询功能。</li><li>AMS和PKMS同属一个进程，它们完全可以不通过Context来交互。此处为何要如此大费周章呢？原因很简单，Android希望SystemServer中的服务也通过Android运行环境来交互。这更多是从设计上来考虑的，比如组件之间交互接口的统一及未来系统的可扩展性。</li></ul><h3 id="1-2-1-mSystemThread-installSystemApplicationInfo"><a href="#1-2-1-mSystemThread-installSystemApplicationInfo" class="headerlink" title="1.2.1 mSystemThread.installSystemApplicationInfo"></a>1.2.1 mSystemThread.installSystemApplicationInfo</h3><p>AMS通过Context查询PKMS中一个名为“android”的package得来，只有framework-res.apk声明其package名为“android”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installSystemApplicationInfo</span><span class="params">(ApplicationInfo info)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">     <span class="comment">//返回的ContextImpl对象即之前在AMS的main函数一节中创建的那个对象</span></span><br><span class="line">        ContextImpl context = getSystemContext();</span><br><span class="line">         <span class="comment">//又调用init初始化该Context，是不是重复调用init了？</span></span><br><span class="line">        context.init(<span class="keyword">new</span> LoadedApk(<span class="keyword">this</span>, <span class="string">"android"</span>, context, info,</span><br><span class="line">                CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO), <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// give ourselves a default profiler</span></span><br><span class="line">        <span class="comment">//创建一个Profiler对象，用于性能统计</span></span><br><span class="line">        mProfiler = <span class="keyword">new</span> Profiler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又调用init初始化该Context，是不是重复调用init了？</p><ul><li>第一次执行init时，在LoadedApk构造函数中第四个表示ApplicationInfo的参数为null。第二次执行init时，LoadedApk构造函数的第四个参数不为空，即该参数将真正指向一个实际的ApplicationInfo，该ApplicationInfo来源于framework-res.apk。</li><li>Context第一次执行init的目的仅仅是为了创建一个Android运行环境，而该Context并没有和实际的ApplicationInfo绑定。而第二次执行init前，先利用Context和PKMS交互得到一个实际的ApplicationInfo，然后再通过init将此Context和ApplicationInfo绑定。</li><li>framework-res.apk（包括后面将介绍的SettingsProvider.apk）运行在SystemServer中。和其他所有apk一样，它的运行需要一个正确初始化的Android运行环境。需要绑定ApplicationInfo。</li></ul><h3 id="1-2-2-mSelf-newProcessRecordLocked"><a href="#1-2-2-mSelf-newProcessRecordLocked" class="headerlink" title="1.2.2  mSelf.newProcessRecordLocked"></a>1.2.2  mSelf.newProcessRecordLocked</h3><p>AMS和应用进程交互，如启动其他进程的Activity，由于该Activity在另一个进程中，需要跨进程通信，通过Binder完成。Android提供了IApplicationThread接口，该接口定义了AMS和应用进程之间交互函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IApplicationThread</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> schedulePauseActivity;</span><br><span class="line">    <span class="keyword">void</span> scheduleStopActivity;</span><br><span class="line">    <span class="keyword">void</span> scheduleWindowVisibility;</span><br><span class="line">    <span class="keyword">void</span> scheduleSleeping;</span><br><span class="line">    <span class="keyword">void</span> scheduleResumeActivity</span><br><span class="line">    <span class="keyword">void</span> scheduleLaunchActivity</span><br><span class="line">    <span class="keyword">void</span> scheduleReceiver</span><br><span class="line">    <span class="keyword">void</span> scheduleCreateService</span><br><span class="line">    <span class="keyword">void</span> scheduleRegisteredReceiver</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleLowMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> setProcessState</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>newProcessRecordLocked函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">newProcessRecordLocked</span><span class="params">(ApplicationInfo info, String customProcess,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> isolated)</span> </span>&#123;</span><br><span class="line">   String proc = customProcess != <span class="keyword">null</span> ? customProcess : info.processName;</span><br><span class="line">    BatteryStatsImpl.Uid.Proc ps = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//BSImpl将为该进程创建一个耗电量统计项</span></span><br><span class="line">    BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();</span><br><span class="line">    <span class="keyword">int</span> uid = info.uid;</span><br><span class="line">    <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">        <span class="keyword">int</span> userId = UserHandle.getUserId(uid);</span><br><span class="line">        <span class="keyword">int</span> stepsLeft = Process.LAST_ISOLATED_UID - Process.FIRST_ISOLATED_UID + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mNextIsolatedProcessUid &lt; Process.FIRST_ISOLATED_UID</span><br><span class="line">                    || mNextIsolatedProcessUid &gt; Process.LAST_ISOLATED_UID) &#123;</span><br><span class="line">                mNextIsolatedProcessUid = Process.FIRST_ISOLATED_UID;</span><br><span class="line">            &#125;</span><br><span class="line">            uid = UserHandle.getUid(userId, mNextIsolatedProcessUid);</span><br><span class="line">            mNextIsolatedProcessUid++;</span><br><span class="line">            <span class="keyword">if</span> (mIsolatedProcesses.indexOfKey(uid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No process for this uid, use it.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stepsLeft--;</span><br><span class="line">            <span class="keyword">if</span> (stepsLeft &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个ProcessRecord对象，用于和其他进程通信的thread作为第一个参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProcessRecord(stats, info, proc, uid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProcessRecord构造函数初始化一些成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ProcessRecord(BatteryStatsImpl _batteryStats, ApplicationInfo _info,</span><br><span class="line">            String _processName, <span class="keyword">int</span> _uid) &#123;</span><br><span class="line">    mBatteryStats = _batteryStats; <span class="comment">//用于电量统计</span></span><br><span class="line">    info = _info;<span class="comment">//保存ApplicationInfo</span></span><br><span class="line">    isolated = _info.uid != _uid;</span><br><span class="line">    uid = _uid;</span><br><span class="line">    userId = UserHandle.getUserId(_uid);</span><br><span class="line">    processName = _processName; <span class="comment">//保存进程名</span></span><br><span class="line">    pkgList.put(_info.packageName, <span class="keyword">null</span>);<span class="comment">//一个进程能运行多个Package，pkgList用于保存package名</span></span><br><span class="line">     <span class="comment">//下面这些xxxAdj成员变量和进程调度优先级及OOM_adj有关。</span></span><br><span class="line">    maxAdj = ProcessList.UNKNOWN_ADJ;</span><br><span class="line">    curRawAdj = setRawAdj = -<span class="number">100</span>;</span><br><span class="line">    curAdj = setAdj = -<span class="number">100</span>;</span><br><span class="line">     <span class="comment">//用于控制该进程是否常驻内存（即使被杀掉，系统也会重启它），只有重要的进程才会有此待遇</span></span><br><span class="line">    persistent = <span class="keyword">false</span>;</span><br><span class="line">    removed = <span class="keyword">false</span>;</span><br><span class="line">    lastStateTime = lastPssTime = nextPssTime = SystemClock.uptimeMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AMS的setSystemProcess总结</strong></p><ul><li>注册AMS、meminfo、gfxinfo等服务到ServiceManager中。</li><li>根据PKMS返回的ApplicationInfo初始化Android运行环境，并创建一个代表SystemServer进程的ProcessRecord，从此，SystemServer进程也并入AMS的管理范围内。</li></ul><h2 id="1-3-AMS-installSystemProviders"><a href="#1-3-AMS-installSystemProviders" class="headerlink" title="1.3 AMS.installSystemProviders"></a>1.3 AMS.installSystemProviders</h2><p>该Provider在SettingsProvider.apk中，installSystemProviders就会加载该APK并把SettingsProvider放到SystemServer进程中来运行。此时的SystemServer已经加载了framework-res.apk，现在又要加载另外一个APK文件，这就是多个APK运行在同一进程的典型案例。另外，通过installSystemProviders函数还能见识ContentProvider的安装过程，下面就来分析它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">installSystemProviders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   List&lt;ProviderInfo&gt; providers;</span><br><span class="line">    <span class="keyword">synchronized</span> (mSelf) &#123;</span><br><span class="line">    <span class="comment">/*从mProcessNames找到进程名为“system”且uid为SYSTEM_UID的ProcessRecord,返回值就是前面在installSystemApplication中创建的那个ProcessRecord，它代表SystemServer进程 */</span></span><br><span class="line">    ProcessRecord app = mSelf.mProcessNames.get(<span class="string">"system"</span>, Process.SYSTEM_UID);</span><br><span class="line">    <span class="comment">//1.关键调用，见下文分析</span></span><br><span class="line">     providers = mSelf.generateApplicationProvidersLocked(app);</span><br><span class="line">     <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=providers.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                ProviderInfo pi = (ProviderInfo)providers.get(i);</span><br><span class="line">                <span class="keyword">if</span> ((pi.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//将非系统APK（即未设ApplicationInfo.FLAG_SYSTEM标志）提供的Provider从providers列表中去掉</span></span><br><span class="line">                    Slog.w(TAG, <span class="string">"Not installing system proc provider "</span> + pi.name</span><br><span class="line">                            + <span class="string">": not system .apk"</span>);</span><br><span class="line">                    providers.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//2.为SystemServer进程安装Provider</span></span><br><span class="line">        mSystemThread.installSystemProviders(providers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监视Settings数据库中Secure表的变化，目前只关注long_press_timeout配置的变化</span></span><br><span class="line">    mSelf.mCoreSettingsObserver = <span class="keyword">new</span> CoreSettingsObserver(mSelf);</span><br><span class="line">    mSelf.mUsageStatsService.monitorPackages();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中列出了两个关键调用，分别是：</p><ul><li>调用generateApplicationProvidersLocked函数，该函数返回一个ProviderInfo List。</li><li>调用ActivityThread的installSystemProviders函数。ActivityThread可以看做是进程的Android运行环境，那么installSystemProviders表示为该进程安装ContentProvider。 </li></ul><p><strong>注意</strong>：此处不再区分系统进程还是应用进程。由于只和ActivityThread交互，因此它运行在什么进程无关紧要。</p><p>AMS的 generateApplicationProvidersLocked函数分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;ProviderInfo&gt; <span class="title">generateApplicationProvidersLocked</span><span class="params">(ProcessRecord app)</span> </span>&#123;</span><br><span class="line">  List&lt;ProviderInfo&gt; providers = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">//1.向PKMS查询满足要求的ProviderInfo，最重要的查询条件包括：进程名和进程uid</span></span><br><span class="line">     providers = AppGlobals.getPackageManager().</span><br><span class="line">          queryContentProviders(app.processName, app.uid,</span><br><span class="line">                  STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (DEBUG_MU)</span><br><span class="line">      Slog.v(TAG_MU, <span class="string">"generateApplicationProvidersLocked, app.info.uid = "</span> + app.uid);</span><br><span class="line">  <span class="keyword">int</span> userId = app.userId;</span><br><span class="line">  <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> N = providers.size();</span><br><span class="line">      app.pubProviders.ensureCapacity(N + app.pubProviders.size());</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">      <span class="comment">//2.AMS对ContentProvider的管理，见下文解释</span></span><br><span class="line">          ProviderInfo cpi =</span><br><span class="line">              (ProviderInfo)providers.get(i);</span><br><span class="line">          <span class="keyword">boolean</span> singleton = isSingleton(cpi.processName, cpi.applicationInfo,</span><br><span class="line">                  cpi.name, cpi.flags);</span><br><span class="line">          <span class="keyword">if</span> (singleton &amp;&amp; UserHandle.getUserId(app.uid) != <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// This is a singleton provider, but a user besides the</span></span><br><span class="line">              <span class="comment">// default user is asking to initialize a process it runs</span></span><br><span class="line">              <span class="comment">// in...  well, no, it doesn't actually run in this process,</span></span><br><span class="line">              <span class="comment">// it runs in the process of the default user.  Get rid of it.</span></span><br><span class="line">              providers.remove(i);</span><br><span class="line">              N--;</span><br><span class="line">              i--;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          ComponentName comp = <span class="keyword">new</span> ComponentName(cpi.packageName, cpi.name);</span><br><span class="line">          <span class="comment">//ContentProvider在AMS中用ContentProviderRecord来表示</span></span><br><span class="line">          ContentProviderRecord cpr = mProviderMap.getProviderByClass(comp, userId);</span><br><span class="line">          <span class="keyword">if</span> (cpr == <span class="keyword">null</span>) &#123;</span><br><span class="line">              cpr = <span class="keyword">new</span> ContentProviderRecord(<span class="keyword">this</span>, cpi, app.info, comp, singleton);</span><br><span class="line">              mProviderMap.putProviderByClass(comp, cpr);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (DEBUG_MU)</span><br><span class="line">              Slog.v(TAG_MU, <span class="string">"generateApplicationProvidersLocked, cpi.uid = "</span> + cpr.uid);</span><br><span class="line">          app.pubProviders.put(cpi.name, cpr);</span><br><span class="line">          <span class="keyword">if</span> (!cpi.multiprocess || !<span class="string">"android"</span>.equals(cpi.packageName)) &#123;</span><br><span class="line">              <span class="comment">// Don't add this if it is a platform component that is marked</span></span><br><span class="line">              <span class="comment">// to run in multiple processes, because this is actually</span></span><br><span class="line">              <span class="comment">// part of the framework so doesn't make sense to track as a</span></span><br><span class="line">              <span class="comment">// separate apk in the process.</span></span><br><span class="line">              app.addPackage(cpi.applicationInfo.packageName, mProcessStats);</span><br><span class="line">          &#125;</span><br><span class="line">          ensurePackageDexOpt(cpi.applicationInfo.packageName);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> providers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上代码可知：generateApplicationProvidersLocked先从PKMS那里查询满足条件的ProviderInfo信息，而后将它们分别保存到AMS和ProcessRecord中对应的数据结构中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ProviderInfo&gt; <span class="title">queryContentProviders</span><span class="params">(String processName,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> uid, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ProviderInfo&gt; finalList = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// reader</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;PackageParser.Provider&gt; i = mProviders.mProviders.values().iterator();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId = processName != <span class="keyword">null</span> ?</span><br><span class="line">                UserHandle.getUserId(uid) : UserHandle.getCallingUserId();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">final</span> PackageParser.Provider p = i.next();</span><br><span class="line">            PackageSetting ps = mSettings.mPackages.get(p.owner.packageName);</span><br><span class="line">           <span class="comment">// 下面的if语句将从这些Provider中搜索本例设置的processName为“system”，uid为SYSTEM_UID，flags为FLAG_SYSTEM的Provider</span></span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="keyword">null</span> &amp;&amp; p.info.authority != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; (processName == <span class="keyword">null</span></span><br><span class="line">                            || (p.info.processName.equals(processName)</span><br><span class="line">                                    &amp;&amp; UserHandle.isSameApp(p.info.applicationInfo.uid, uid)))</span><br><span class="line">                    &amp;&amp; mSettings.isEnabledLPr(p.info, flags, userId)</span><br><span class="line">                    &amp;&amp; (!mSafeMode</span><br><span class="line">                            || (p.info.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (finalList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    finalList = <span class="keyword">new</span> ArrayList&lt;ProviderInfo&gt;(<span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ProviderInfo info = PackageParser.generateProviderInfo(p, flags,</span><br><span class="line">                        ps.readUserState(userId), userId);</span><br><span class="line">                <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    finalList.add(info);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由PackageParser.Provider得到ProviderInfo，并添加到finalList中</span></span><br><span class="line">    <span class="keyword">if</span> (finalList != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//最终结果按provider的initOrder排序，该值用于表示初始化ContentProvider的顺序</span></span><br><span class="line">        Collections.sort(finalList, mProviderInitOrderSorter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> finalList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>queryContentProviders函数很简单，就是从PKMS那里查找满足条件的Provider，然后生成AMS使用的ProviderInfo信息。为何偏偏能找到SettingsProvider呢？来看它的AndroidManifest.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">package</span>=<span class="string">"com.android.providers.settings"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">coreApp</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:sharedUserId</span>=<span class="string">"android.uid.system"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:allowClearUserData</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:label</span>=<span class="string">"@string/app_label"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:process</span>=<span class="string">"system"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:backupAgent</span>=<span class="string">"SettingsBackupAgent"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:killAfterRestore</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher_settings"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- todo add: android:neverEncrypt="true" --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">"SettingsProvider"</span> <span class="attr">android:authorities</span>=<span class="string">"settings"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:multiprocess</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:writePermission</span>=<span class="string">"android.permission.WRITE_SETTINGS"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:initOrder</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SettingsProvider设置了其uid为“android.uid.system”，同时在application中设置了process名为“system”。而在framework-res.apk中也做了相同的设置。所以，现在可以确认SettingsProvider将和framework-res.apk运行在同一个进程，即SystemServer中。</p><p>提示从运行效率角度来说，这样做也是合情合理的。因为SystemServer的很多Service都依赖Settings数据库，把它们放在同一个进程中，可以降低由于进程间通信带来的效率损失。</p><h2 id="1-4-ASM的systemReady分析"><a href="#1-4-ASM的systemReady分析" class="headerlink" title="1.4 ASM的systemReady分析"></a>1.4 ASM的systemReady分析</h2><p>AMS的systemReady代码较多，会做什么,将会分为三个阶段。</p><p><strong>第一阶段</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemReady</span><span class="params">(<span class="keyword">final</span> Runnable goingCallback)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (mSystemReady) &#123;<span class="comment">//SystemReady，则直接执行线程</span></span><br><span class="line">    <span class="keyword">if</span> (goingCallback != <span class="keyword">null</span>) goingCallback.run();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(SystemProperties.get(<span class="string">"persist.sys.qb.enable"</span>,<span class="string">"false"</span>).equals(<span class="string">"true"</span>))&#123;</span><br><span class="line">    reloadConfiguration();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Check to see if there are any update receivers to run.是否有升级动作</span></span><br><span class="line"><span class="keyword">if</span> (!mDidUpdate) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mWaitingUpdate) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//准备PRE_BOOT_COMPLETED广播</span></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_PRE_BOOT_COMPLETED);</span><br><span class="line">    List&lt;ResolveInfo&gt; ris = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// //向PKMS查询该广播的接收者</span></span><br><span class="line">        ris = AppGlobals.getPackageManager().queryIntentReceivers(</span><br><span class="line">                intent, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ris != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=ris.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ris.get(i).activityInfo.applicationInfo.flags</span><br><span class="line">                    &amp;ApplicationInfo.FLAG_SYSTEM) == <span class="number">0</span>) &#123;</span><br><span class="line">                ris.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//从返回的结果中删除那些非系统APK的广播接收者</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取/data/system/called_pre_boots.dat文件，这里存储了上次启动时候已经</span></span><br><span class="line">     <span class="comment">//接收并处理PRE_BOOT_COMPLETED广播的组件。鉴于该广播的特殊性，系统希望</span></span><br><span class="line">     <span class="comment">//该广播仅被这些接收者处理一次</span></span><br><span class="line">        intent.addFlags(Intent.FLAG_RECEIVER_BOOT_UPGRADE);</span><br><span class="line">        ArrayList&lt;ComponentName&gt; lastDoneReceivers = readLastDonePreBootReceivers();</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;ComponentName&gt; doneReceivers = <span class="keyword">new</span> ArrayList&lt;ComponentName&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ris.size(); i++) &#123;</span><br><span class="line">            ActivityInfo ai = ris.get(i).activityInfo;</span><br><span class="line">            ComponentName comp = <span class="keyword">new</span> ComponentName(ai.packageName, ai.name);</span><br><span class="line">            <span class="keyword">if</span> (lastDoneReceivers.contains(comp)) &#123;</span><br><span class="line">                ris.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="comment">//从PKMS返回的接收者中删除那些已经处理过该广播的对象</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] users = getUsersLocked();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ris.size(); i++) &#123;</span><br><span class="line">            ActivityInfo ai = ris.get(i).activityInfo;</span><br><span class="line">            ComponentName comp = <span class="keyword">new</span> ComponentName(ai.packageName, ai.name);</span><br><span class="line">            doneReceivers.add(comp);</span><br><span class="line">            intent.setComponent(comp);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;users.length; j++) &#123;</span><br><span class="line">                IIntentReceiver finisher = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//为最后一个广播接收者注册一个回调通知，当该接收者处理完广播后，将调用该回调</span></span><br><span class="line">                <span class="keyword">if</span> (i == ris.size()-<span class="number">1</span> &amp;&amp; j == users.length-<span class="number">1</span>) &#123;</span><br><span class="line">                    finisher = <span class="keyword">new</span> IIntentReceiver.Stub() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                String data, Bundle extras, <span class="keyword">boolean</span> ordered,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> </span>&#123;</span><br><span class="line">                            <span class="comment">// The raw IIntentReceiver interface is called</span></span><br><span class="line">                            <span class="comment">// with the AM lock held, so redispatch to</span></span><br><span class="line">                                                                    <span class="comment">// execute our code without the lock.</span></span><br><span class="line">                            mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                    <span class="keyword">synchronized</span> (ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">                                        mDidUpdate = <span class="keyword">true</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line"><span class="comment">//保存那些处理过该广播的接收者信息                                    writeLastDonePreBootReceivers(doneReceivers);</span></span><br><span class="line">                                    showBootMessage(mContext.getText(</span><br><span class="line">                                            R.string.android_upgrading_complete),</span><br><span class="line">                                            <span class="keyword">false</span>);</span><br><span class="line">                                    systemReady(goingCallback);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                Slog.i(TAG, <span class="string">"Sending system update to "</span> + intent.getComponent()</span><br><span class="line">                        + <span class="string">" for user "</span> + users[j]);</span><br><span class="line">                        + </span><br><span class="line">                broadcastIntentLocked(<span class="keyword">null</span>, <span class="keyword">null</span>, intent, <span class="keyword">null</span>, finisher,</span><br><span class="line">                        <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, AppOpsManager.OP_NONE,</span><br><span class="line">                        <span class="keyword">true</span>, <span class="keyword">false</span>, MY_PID, Process.SYSTEM_UID,</span><br><span class="line">                        users[j]);</span><br><span class="line">                <span class="keyword">if</span> (finisher != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mWaitingUpdate = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mWaitingUpdate) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDidUpdate = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用AppOpsService.systemReady()</span></span><br><span class="line">mAppOpsService.systemReady();</span><br><span class="line">mSystemReady = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!mStartRunning) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>systemReady第一阶段的工作并不轻松，其主要职责是发送并处理与PRE_BOOT_COMPLETED广播相关的事情。目前代码中还没有接收该广播的地方，不过从代码中的注释中可猜测到，该广播接收者的工作似乎和系统升级有关。</p><p><strong>第二阶段</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;ProcessRecord&gt; procsToKill = null;</span><br><span class="line"> synchronized(mPidsSelfLocked) &#123;</span><br><span class="line">     for (int i=mPidsSelfLocked.size()-1; i&gt;=0; i--) &#123;</span><br><span class="line">         ProcessRecord proc = mPidsSelfLocked.valueAt(i);</span><br><span class="line">         if (!isAllowedWhileBooting(proc.info))&#123;</span><br><span class="line">             if (procsToKill == null) &#123;</span><br><span class="line">                 procsToKill = new ArrayList&lt;ProcessRecord&gt;();</span><br><span class="line">             &#125;</span><br><span class="line">             procsToKill.add(proc);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> synchronized(this) &#123;</span><br><span class="line">     if (procsToKill != null) &#123;</span><br><span class="line">         for (int i=procsToKill.size()-1; i&gt;=0; i--) &#123;</span><br><span class="line">             ProcessRecord proc = procsToKill.get(i);</span><br><span class="line">             Slog.i(TAG, &quot;Removing system update proc: &quot; + proc);</span><br><span class="line">              //把这些进程关闭，removeProcessLocked</span><br><span class="line">             removeProcessLocked(proc, true, false, &quot;system update done&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // Now that we have cleaned up any update processes, we</span><br><span class="line">     // are ready to start launching real processes and know that</span><br><span class="line">     // we won&apos;t trample on them any more.</span><br><span class="line">       //至此，系统已经准备完毕</span><br><span class="line">     mProcessesReady = true;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> Slog.i(TAG, &quot;System now ready&quot;);</span><br><span class="line"> if(checkQbVersion())</span><br><span class="line"> &#123;</span><br><span class="line">     Slog.i(&quot;Qb&quot;,&quot;System now ready&quot;);</span><br><span class="line">     getQbAndroidManager();</span><br><span class="line">     mQbFlag = mQbAndroidManager.checkFlag();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY,</span><br><span class="line">     SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line"> synchronized(this) &#123;</span><br><span class="line">     // Make sure we have no pre-ready processes sitting around.</span><br><span class="line">     //和工厂测试有关，不对此进行讨论</span><br><span class="line">     if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">         ResolveInfo ri = mContext.getPackageManager()</span><br><span class="line">                 .resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),</span><br><span class="line">                         STOCK_PM_FLAGS);</span><br><span class="line">         CharSequence errorMsg = null;</span><br><span class="line">         if (ri != null) &#123;</span><br><span class="line">             ActivityInfo ai = ri.activityInfo;</span><br><span class="line">             ApplicationInfo app = ai.applicationInfo;</span><br><span class="line">             if ((app.flags&amp;ApplicationInfo.FLAG_SYSTEM) != 0) &#123;</span><br><span class="line">                 mTopAction = Intent.ACTION_FACTORY_TEST;</span><br><span class="line">                 mTopData = null;</span><br><span class="line">                 mTopComponent = new ComponentName(app.packageName,</span><br><span class="line">                         ai.name);</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">                 errorMsg = mContext.getResources().getText(</span><br><span class="line">                         com.android.internal.R.string.factorytest_not_system);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             errorMsg = mContext.getResources().getText(</span><br><span class="line">                     com.android.internal.R.string.factorytest_no_action);</span><br><span class="line">         &#125;</span><br><span class="line">         if (errorMsg != null) &#123;</span><br><span class="line">             mTopAction = null;</span><br><span class="line">             mTopData = null;</span><br><span class="line">             mTopComponent = null;</span><br><span class="line">             Message msg = Message.obtain();</span><br><span class="line">             msg.what = SHOW_FACTORY_ERROR_MSG;</span><br><span class="line">             msg.getData().putCharSequence(&quot;msg&quot;, errorMsg);</span><br><span class="line">             mHandler.sendMessage(msg);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">//查询Settings数据，获取一些配置参数</span><br><span class="line"> retrieveSettings();</span><br></pre></td></tr></table></figure><p>systemReady第二阶段的工作包括：</p><ul><li>杀死那些竟然在AMS还未启动完毕就先启动的应用进程。注意，这些应用进程一定是APK所在的Java进程，因为只有应用进程才会向AMS注册，而一般Native（例如mediaserver）进程是不会向AMS注册的。</li></ul><p><strong>第三阶段</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    readGrantedUriPermissionsLocked();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用systemReady传入的参数，它是一个Runnable对象，下节将分析此函数</span></span><br><span class="line"><span class="keyword">if</span> (goingCallback != <span class="keyword">null</span>) goingCallback.run();</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//从PKMS中查询那些persistent为1的ApplicationInfo</span></span><br><span class="line">            List apps = AppGlobals.getPackageManager().</span><br><span class="line">                getPersistentApplications(STOCK_PM_FLAGS);</span><br><span class="line">            <span class="keyword">if</span> (apps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> N = apps.size();</span><br><span class="line">                <span class="keyword">int</span> i;</span><br><span class="line">                <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                    ApplicationInfo info</span><br><span class="line">                        = (ApplicationInfo)apps.get(i);</span><br><span class="line">             <span class="comment">//由于framework-res.apk已经由系统启动，所以这里需要把它去除</span></span><br><span class="line">             <span class="comment">//framework-res.apk的packageName为"android"</span></span><br><span class="line">                    <span class="keyword">if</span> (info != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            !info.packageName.equals(<span class="string">"android"</span>)) &#123;</span><br><span class="line">                     addAppLocked(info, <span class="keyword">false</span>);<span class="comment">//启动该Application所在的进程</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="comment">// pm is in same process, this will never happen.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Start up initial activity.设置mBooting=true</span></span><br><span class="line">    mBooting = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (AppGlobals.getPackageManager().hasSystemUidErrors()) &#123;</span><br><span class="line">            Message msg = Message.obtain();</span><br><span class="line">            msg.what = SHOW_UID_ERROR_MSG;</span><br><span class="line">            mHandler.sendMessage(msg);<span class="comment">//处理那些Uid有错误的Application</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_USER_STARTED);</span><br><span class="line">        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY</span><br><span class="line">                | Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line">        intent.putExtra(Intent.EXTRA_USER_HANDLE, mCurrentUserId);</span><br><span class="line">        broadcastIntentLocked(<span class="keyword">null</span>, <span class="keyword">null</span>, intent,</span><br><span class="line">                <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, AppOpsManager.OP_NONE,</span><br><span class="line">                <span class="keyword">false</span>, <span class="keyword">false</span>, MY_PID, Process.SYSTEM_UID, mCurrentUserId);</span><br><span class="line">        intent = <span class="keyword">new</span> Intent(Intent.ACTION_USER_STARTING);</span><br><span class="line">        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);</span><br><span class="line">        intent.putExtra(Intent.EXTRA_USER_HANDLE, mCurrentUserId);</span><br><span class="line">        broadcastIntentLocked(<span class="keyword">null</span>, <span class="keyword">null</span>, intent,</span><br><span class="line">                <span class="keyword">null</span>, <span class="keyword">new</span> IIntentReceiver.Stub() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode, String data,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span></span></span><br><span class="line"><span class="function">                            <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">                android.Manifest.permission.INTERACT_ACROSS_USERS, AppOpsManager.OP_NONE,</span><br><span class="line">                <span class="keyword">true</span>, <span class="keyword">false</span>, MY_PID, Process.SYSTEM_UID, UserHandle.USER_ALL);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(ident);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//启动全系统第一个Activity，即Home</span></span><br><span class="line">    mStackSupervisor.resumeTopActivitiesLocked();</span><br><span class="line">    sendUserSwitchBroadcastsLocked(-<span class="number">1</span>, mCurrentUserId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>systemReady第三阶段的工作有3项：</p><ul><li>调用systemReady设置的回调对象goingCallback的run函数。</li><li>启动那些声明了persistent的APK。</li><li>启动桌面。在Home启动成功后，AMS才发送ACTION_BOOT_COMPLETED广播。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-概述&quot;&gt;&lt;a href=&quot;#0-概述&quot; class=&quot;headerlink&quot; title=&quot;0.概述&quot;&gt;&lt;/a&gt;0.概述&lt;/h1&gt;&lt;p&gt;AMS是Android中&lt;code&gt;最核心的服务&lt;/code&gt;，主要负责系统中&lt;code&gt;四大组件的启动&lt;/code&gt;、&lt;code&gt;切换&lt;/code&gt;、&lt;code&gt;调度&lt;/code&gt;及&lt;code&gt;应用进程的管理和调度&lt;/code&gt;等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android组件" scheme="http://yoursite.com/tags/Android%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android进程(创建)</title>
    <link href="http://yoursite.com/2017/07/29/Android%E8%BF%9B%E7%A8%8B-%E5%88%9B%E5%BB%BA/"/>
    <id>http://yoursite.com/2017/07/29/Android进程-创建/</id>
    <published>2017-07-29T15:49:20.000Z</published>
    <updated>2019-02-02T11:21:31.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1-准备知识"><a href="#1-1-准备知识" class="headerlink" title="1.1 准备知识"></a>1.1 准备知识</h2><p>Android中进程和线程的区别：</p><ul><li><strong>进程</strong>：每个APP启动前创建一个进程，进程由Zygote fork出来，App中很少提进程概念，APP程序运行在Android Runtime上。APP创建进程方法有：AndroidManifest.xml中配置<code>Android:process</code>属性，或者native代码系统调用fork.<ul><li><code>system_server</code>进程：管理整个Java framework层，包含各种系统服务。</li><li><code>Zygote</code>进程：是Android系统的首个Java进程，是所有Java进程的父进程，包括<code>system_server</code>进程以及所有的APP进程都是Zygote的子进程。</li></ul></li><li><strong>线程</strong>:<code>new Thread().start()</code><a id="more"></a></li></ul><h2 id="1-2进程创建过程"><a href="#1-2进程创建过程" class="headerlink" title="1.2进程创建过程"></a>1.2进程创建过程</h2><p><img src="/2017/07/29/Android进程-创建/start_app_process.jpg" alt="创建进程"></p><ul><li>1.<strong>APP发起进程</strong>：应用跳转，或者lancher，启动APP。先通过binder发送消息给system_server进程。</li><li>2.<strong>system_server进程</strong>：调用<code>Process.start()</code>方法，通过socket向zygote进程发送创建新进程请求。</li><li>3.<strong>zygote进程</strong>：在执行<code>ZygoteInit.main()</code>后便进入<code>runSelectLoop()</code>循环体内，当客户端连接时便会执行<code>ZygoteConnection.runOnce()</code>方法，再经过调用后<code>fork</code>出新应用进程。</li><li>4.<strong>新进程</strong>:执行<code>handleChildProc</code>方法，最后调用<code>ActivityThread.main()</code>方法。</li></ul><h1 id="2-system-server发起请求"><a href="#2-system-server发起请求" class="headerlink" title="2.system_server发起请求"></a>2.system_server发起请求</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Process.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult start</span><br><span class="line">(<span class="keyword">final</span> String processClass,<span class="keyword">final</span> String niceName,<span class="keyword">int</span> uid,</span><br><span class="line"><span class="keyword">int</span> gid,<span class="keyword">int</span>[] gids,<span class="keyword">int</span> debugFlags,<span class="keyword">int</span> mountExternal,</span><br><span class="line"><span class="keyword">int</span> targetSdkVersion,String seInfo,String abi,</span><br><span class="line">String instructionSet,String appDataDir,String[] zygoteArgs)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">return</span> startViaZygote(processClass,niceName,uid,gid,gids</span><br><span class="line">debugFlags,mountExternal,targetSdkVersion,seInfo,</span><br><span class="line">abi,instructionSet,appDataDir,zygoteArgs);</span><br><span class="line">&#125;<span class="keyword">catch</span>(ZygoteStartFailedEx ex)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessStartResult <span class="title">startViaZygote</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> String processClass,<span class="keyword">final</span> String niceName,<span class="keyword">final</span> <span class="keyword">int</span> uid,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> <span class="keyword">int</span> gid,<span class="keyword">final</span> <span class="keyword">int</span>[] gids,<span class="keyword">int</span> debugFlags,<span class="keyword">int</span> mountExternal,<span class="keyword">int</span> targetSdkVersion,String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">String abi,String instructionSet,String appDataDir,String[] extraArgs)</span> <span class="keyword">throws</span> ZygoteStartFailedEx</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sychronize(Process.class)&#123;</span><br><span class="line">ArrayList&lt;String&gt; argsForZygote=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">argsForZygote.add(<span class="string">"--runtime-args"</span>);</span><br><span class="line">argsFrozygote.add(<span class="string">"--setuid="</span>+uid);</span><br><span class="line"> argsForZygote.add(<span class="string">"--setgid="</span> + gid);</span><br><span class="line">argsForZygote.add(<span class="string">"--target-sdk-version="</span> + targetSdkVersion);</span><br><span class="line"><span class="keyword">if</span>(niceName!=<span class="keyword">null</span>)&#123;</span><br><span class="line">argsForZygote.add(<span class="string">"--nice-name"</span>+niceName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是否意味着，这里可以定制app数据目录？ 和恢复出厂连起来？</span></span><br><span class="line"><span class="keyword">if</span>(appDataDir!=<span class="keyword">null</span>)&#123;</span><br><span class="line">argsForZygote.add(<span class="string">"--app-data-dir="</span>+appDataDir);</span><br><span class="line">&#125;</span><br><span class="line">argsForZygote.add(processClass);</span><br><span class="line"><span class="keyword">if</span>(extraArgs!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(String arg:extraArgs)&#123;</span><br><span class="line">argsForZygote.add(arg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> zygoteSendArgsAndGetResult(</span><br><span class="line">openZygoteSocketIfNeeded(abi),argsForZygote</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面工作主要完成生成<code>argsForZygote</code>数组，保存进程uid,gid,groups等参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Process.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ZygoteState zygoteState,ArrayList&lt;String&gt; args</span></span></span><br><span class="line"><span class="function"><span class="params">)</span><span class="keyword">throws</span> ZygoteStartFailedEx</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">final</span> BufferWriter writer=zygoteState.writer;</span><br><span class="line"><span class="keyword">final</span> DataInputStream inputStream=zygoteState.inputStream;</span><br><span class="line">writer.write(Integer.toString(args.size()));</span><br><span class="line">writer.newLine();</span><br><span class="line"><span class="keyword">int</span> sz=args.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++)&#123;</span><br><span class="line">String arg=args.get(i);</span><br><span class="line"><span class="keyword">if</span>(arg.indexOf(<span class="string">'\n'</span>)&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"embeded newlines not allowed"</span>);</span><br><span class="line">&#125;</span><br><span class="line">writer.write(arg);</span><br><span class="line">writer.newLine();</span><br><span class="line">&#125;</span><br><span class="line">writer.flush();</span><br><span class="line"></span><br><span class="line">ProcessStartResult result=<span class="keyword">new</span> ProcessStartResult();</span><br><span class="line"><span class="comment">//等待socket服务端(zygote)返回新创建的进程pid</span></span><br><span class="line"><span class="comment">//对于等待时长问题，暂时未加</span></span><br><span class="line">result.pid=inputStream.readInt();</span><br><span class="line"><span class="keyword">if</span>(result.pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"fork() failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line">result.usingWrapper=inputStream.readBoolean();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line">zygoteState.close();</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的主要功能是通过socket通道向Zygote进程发送一个参数列表，然后进入<code>阻塞等待状态</code>，直到远端的socket服务端发送回来新创建的<code>进程pid</code>才返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static ZygoteState openZygoteSocketIfNeeded(String abi)</span><br><span class="line">throws ZygoteStateFailedEx&#123;</span><br><span class="line">if(primaryZygoteState==null||primaryZygoteState.isClosed())&#123;</span><br><span class="line">try&#123;</span><br><span class="line">//向主zygote发起connect</span><br><span class="line">primaryZygoteState=ZygoteState.connect(ZYGOTE_SOCKET);</span><br><span class="line">&#125;catch(IOException ioe)&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(primaryZygoteState.matches(abi))&#123;</span><br><span class="line">return primaryZygoteState;</span><br><span class="line">&#125;</span><br><span class="line">if(secondayZygoteState==null||secondaryZygoteState.isClosed())&#123;</span><br><span class="line">//当主zygote没能匹配成功，采用第二个zygote</span><br><span class="line">secondayZygoteState=ZygoteState.connect(SECONDAY_ZYGOTE_SOCKET);</span><br><span class="line">&#125;</span><br><span class="line">if(secondaryZygoteState.matches(abi))&#123;</span><br><span class="line">return seconaryZygoteState;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>openZygoteSocketIfNeeded(abi)</code>方法是根据当前的abi来选择与<code>zygote</code>还是<code>zygote64</code>来进行通信。</p><p>既然system_server进程的<code>zygoteSendArgsAndGetResult()</code>方法通过socket向Zygote进程发送消息，这是便会唤醒Zygote进程，<code>来响应socket客户端</code>的请求（即system_server端），接下来的操作便是在Zygote来创建进程.</p><h1 id="3-Zygote创建进程"><a href="#3-Zygote创建进程" class="headerlink" title="3.Zygote创建进程"></a>3.Zygote创建进程</h1><p>zygote进程是由init进程而创建的，进程启动之前调用<code>ZygoteInit.main()</code>方法，经过<code>创建socket管道</code>，<code>预加载资源</code>，便进入<code>runSelcetLoop()</code>方法。</p><p><strong>TIP</strong>:子线程和子进程判别：线程与进程的最为本质的区别便是是否共享内存空间，图中VSIZE和Zygote进程相同的才是Zygote的子线程，否则就是Zygote的子进程。</p><p>图中线程名显示的并不完整是由于底层的进程结构体task_struct是由长度为16的char型数组保存，超过15个字符便会截断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ps -t | grep &quot;808432&quot;</span><br><span class="line">USER      PID   PPID  VSIZE  RSS     WCHAN    PC         NAME</span><br><span class="line">root      3434  1     808432 19948 ffffffff 40049890 S zygote</span><br><span class="line">root      15408 3434  808432 19948 ffffffff 4004ab68 S ReferenceQueueD</span><br><span class="line">root      15409 3434  808432 19948 ffffffff 4004ab68 S FinalizerDaemon</span><br><span class="line">root      15411 3434  808432 19948 ffffffff 4004ab68 S FinalizerWatchd</span><br></pre></td></tr></table></figure><p>Zygote进程有4个Daemon子线程分别是<code>ReferenceQueueDaemon</code>，<code>FinalizerDaemon</code>，<code>FinalizerWatchdogDaemon</code>，<code>HeapTaskDaemon</code>。</p><h2 id="3-1-Zygote启动过程"><a href="#3-1-Zygote启动过程" class="headerlink" title="3.1 Zygote启动过程"></a>3.1 Zygote启动过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ZygoteInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">runSelectionLoop(abiList);</span><br><span class="line">&#125;<span class="keyword">catch</span>(MethodAndArgsCaller caller)&#123;</span><br><span class="line"><span class="comment">//runSelectLoop()方法抛出异常MethodAndArgsCaller从而进出入caller.run()方法</span></span><br><span class="line">caller.run();</span><br><span class="line">&#125;<span class="keyword">catch</span>(RuntimeException ex)&#123;</span><br><span class="line">closeServerSocket();</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> <span class="keyword">throws</span> MethodAndArgsCaller</span>&#123;</span><br><span class="line">ArrayList&lt;FileDescriptor&gt; fds=<span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">ArrayList&lt;ZygoteConnection&gt; peers=<span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"><span class="comment">//sServerSocket是socket通信中服务端，zygote进程保存到fds[0]</span></span><br><span class="line">fds.add(sServerSocket.getFileDescriptor());</span><br><span class="line">peers.add(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">StructPollfd[] pollFds=<span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pollFds.length;++i)&#123;</span><br><span class="line">pollFds[i]=<span class="keyword">new</span> StructPollfd();</span><br><span class="line">pollFds[i].fd=fds.get(i);</span><br><span class="line">pollFds[i].events=(<span class="keyword">short</span>)POLLIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//处理轮询状态，当epollFds有事件来则往下执行，否则阻塞在这里</span></span><br><span class="line">Os.poll(pollFds,-<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(ErrorException ex)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=pllFds.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line"><span class="keyword">if</span>((pollFds[i].events.&amp;POLLIN)==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//即fds[0]，代表是sServerSocket，则意味有客户端连接请求</span></span><br><span class="line"><span class="comment">//则创建ZygoteConnection对象，并添加到fds</span></span><br><span class="line">ZygoteConnection <span class="keyword">new</span> Peer=acceptCommandPeer(abiList);</span><br><span class="line">peers.add(newPeer);</span><br><span class="line">fds.add(newPeer.getFileDescriptor());</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//i&gt;0，则代表通过socket接收来自对端的数据，并执行相应操作</span></span><br><span class="line"><span class="keyword">boolean</span> done=peers.get(i).runOnce();</span><br><span class="line"><span class="keyword">if</span>(done)&#123;</span><br><span class="line">peers.remove(i):</span><br><span class="line"><span class="comment">//处理完成则从fds中移除文件描述符</span></span><br><span class="line">fds.remove(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要功能：</p><ul><li>客户端通过<code>openZygoteSocketIfNeeded()</code>来跟zygote进程建立连接。zygote进程收到客户端连接请求后执行<code>accept()</code>；然后再创建<code>ZygoteConnection</code>对象,并添加到fds数组列表；</li><li>建立连接之后，可以跟客户端通信，进入<code>runOnce()</code>方法来接收客户端数据，并执行进程创建工作。</li></ul><h2 id="3-2-zygote新的客户端"><a href="#3-2-zygote新的客户端" class="headerlink" title="3.2 zygote新的客户端"></a>3.2 zygote新的客户端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ZygoteInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ZygoteConnection <span class="title">acceptCommondPeer</span><span class="params">(String abiList)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ZygoteConnetion(sServerSocket.accept(),abiList);</span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收客户端发送过来的<code>connect()</code>操作，Zygote作为服务端执行<code>accept()</code>操作。 再后面客户端调用<code>write()</code>写数据，Zygote进程调用<code>read()</code>读数据。</p><p>没有连接请求时会进入休眠状态，当有创建新进程的连接请求时，唤醒Zygote进程，创建Socket通道ZygoteConnection，然后执行ZygoteConnection的runOnce()方法。</p><h2 id="3-3-已连接客服端处理"><a href="#3-3-已连接客服端处理" class="headerlink" title="3.3 已连接客服端处理"></a>3.3 已连接客服端处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ZygoteConnection.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">runOnce</span><span class="params">()</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller</span>&#123;</span><br><span class="line">String args[];</span><br><span class="line">Arguments parsedArgs=<span class="keyword">null</span>;</span><br><span class="line">FileDescriptor[] descriptors;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//读取socket客户端发送过来的参数列表</span></span><br><span class="line">args=readArgumentList();</span><br><span class="line">descriptors=mSocket.getAncillaryFileDescriptors();</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line">closeSocket();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">PrintStream newStderr=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(fd !=<span class="keyword">null</span>)&#123;</span><br><span class="line">fdsToClose[<span class="number">0</span>]=fd.getInt$();</span><br><span class="line">&#125;</span><br><span class="line">fd=<span class="keyword">null</span>;</span><br><span class="line">pid=Zygote.forkAndSpecialize(</span><br><span class="line">parsedArgs.uid,parsedArgs.gid,parsedArgs.gids,parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,parsedArgs.niceName, fdsToClose,parsedArgs.instructionSet,</span><br><span class="line">                parsedArgs.appDataDir);</span><br><span class="line">);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//子继承执行</span></span><br><span class="line">IoUtils.closeQuietly(serverPipFd);</span><br><span class="line">serverPipeFD=<span class="keyword">null</span>;</span><br><span class="line">handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line"><span class="comment">//不应该代到达这里，子进程预期的是抛出异常</span></span><br><span class="line"><span class="comment">//ZygoteInit.MethodAndArgsCaller或者执行exec();</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//父进程执行</span></span><br><span class="line">IoUtils.closeQuietly(childPipFd);</span><br><span class="line">childPipeFd=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> handleParentProc(pid,descriptors,serverPipFd,parsedArgs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">IoUtils.closeQuitely(childPipeFd);</span><br><span class="line">IoUtils.closeQuitely(serverPipeFd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-1-forkAndSpecialize"><a href="#3-3-1-forkAndSpecialize" class="headerlink" title="3.3.1 forkAndSpecialize"></a>3.3.1 forkAndSpecialize</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forkAndSpecialize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> debugFlags, <span class="keyword">int</span>[][] rlimits, <span class="keyword">int</span> mountExternal, String seInfo, </span></span></span><br><span class="line"><span class="function"><span class="params">String niceName, <span class="keyword">int</span>[] fdsToClose, String instructionSet, String appDataDir)</span></span>&#123;</span><br><span class="line">VM_HOOKS.preFork();</span><br><span class="line"><span class="keyword">int</span> pid=nativeForkAndSpecialize(</span><br><span class="line">uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,instructionSet, appDataDir</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">VM_HOOKS.postForkCommon();</span><br><span class="line"><span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ZygoteHooks.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preFork</span><span class="params">()</span></span>&#123;</span><br><span class="line">停止<span class="number">4</span>个Damon子线程</span><br><span class="line">Daemons.stop();</span><br><span class="line">waitUntilAllThreadsStopped();</span><br><span class="line"><span class="comment">//完成gc堆的初始化工作</span></span><br><span class="line">token=nativePreFork();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//JAVA 堆整理线程</span></span><br><span class="line">HeapTaskDaemon.INSTACNCE.stop();</span><br><span class="line"><span class="comment">//应用队列线程</span></span><br><span class="line">ReferenceQueueDaemon.INSTANCE.stop();</span><br><span class="line"><span class="comment">//析构线程</span></span><br><span class="line">FinalizerDaemon.INSTANCE.stop();</span><br><span class="line"><span class="comment">//析构监控线程</span></span><br><span class="line">FinalizerWatchdogDaemon.INSTACNCE.stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitUtilAllThreadStopped</span><span class="params">()</span></span>&#123;</span><br><span class="line">File task=<span class="keyword">new</span> File(<span class="string">"/proc/self/task"</span>);</span><br><span class="line"><span class="comment">//当/proc中线程数大于1,就出让CPU直到只有一个线程，才退出循环</span></span><br><span class="line"><span class="keyword">while</span>(tasks.list().lenght&gt;<span class="number">1</span>)&#123;</span><br><span class="line">Thread.yield();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VM_HOOKS是Zygote对象的静态成员变量：<code>VM_HOOKS = new ZygoteHooks()</code>;</p><p><strong>nativePreFork通过JNI最终调用</strong>如下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//dalvik_system_ZygoteHooks.cc</span><br><span class="line">static jlong ZygoteHooks_nativePreFork(JNIEnv*env,jclass)&#123;</span><br><span class="line">Runtime* runtime=Runtime::Current();</span><br><span class="line">runtime-&gt;PreZygoteFork();</span><br><span class="line">if(Trace::GetMethodTracingMode!=TracingMode::kTracingInactive)&#123;</span><br><span class="line">Trace::Pause();</span><br><span class="line">&#125;</span><br><span class="line">//将线程转化为long型，并保存到token，该过程是非安全的</span><br><span class="line">return reinterpret_cast&lt;jlong&gt;(ThreadForEnv(env));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VM_HOOKS.preFork()</code>的主要功能便是停止Zygote的4个Daemon子线程的运行，等待并确保Zygote是<code>单线程</code>（用于提升fork效率），并等待这些线程的停止，初始化gc堆的工作, 并将线程转换为long型并保存到token.</p><p><code>nativeForkAndSpecialize()</code>通过JNI最终调用调用如下方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">com_android_internal_os_Zygote_nativeForkAndSpecialize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">JNIEnv*env,jclass,jint uid,jint gid,jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">jnit debug_flags,jobjectArray rlimits,</span></span></span><br><span class="line"><span class="function"><span class="params">jint mount_external,jstring se_info,jstring se_name,</span></span></span><br><span class="line"><span class="function"><span class="params">jintArray fdsToClose,jstring instructionSet,jstring appDataDir</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>&#123;</span><br><span class="line"><span class="comment">//将CAP_WAKE_ALARM赋予蓝牙进程</span></span><br><span class="line">jlong capablities=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(uid==AID_BLUETOOTH)&#123;</span><br><span class="line">capabilities|=(<span class="number">1L</span>L&lt;&lt;CAP_WAKE_ALARM);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ForkAndSpecializeCommon(env, uid, gid, gids, debug_flags,</span><br><span class="line">            rlimits, capabilities, capabilities, mount_external, se_info,</span><br><span class="line">            se_name, <span class="literal">false</span>, fdsToClose, instructionSet, appDataDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ForkAndSpecializeCommon</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> pid_t <span class="title">ForkAndSpecializeCommon</span><span class="params">(JNIEnv* env, <span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid, jintArray javaGids,</span></span></span><br><span class="line"><span class="function"><span class="params"> jint debug_flags, jobjectArray javaRlimits, jlong permittedCapabilities, jlong effectiveCapabilities, jint mount_external, </span></span></span><br><span class="line"><span class="function"><span class="params">jstring java_se_info, jstring java_se_name, <span class="keyword">bool</span> is_system_server, jintArray fdsToClose, </span></span></span><br><span class="line"><span class="function"><span class="params">jstring instructionSet, jstring dataDir)</span></span>&#123;</span><br><span class="line"><span class="comment">//设置子进程的signal信号处理函数</span></span><br><span class="line">SetSigChldHandler();</span><br><span class="line"><span class="comment">//fork子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid=fork();</span><br><span class="line"><span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//关闭并清楚文件描述符</span></span><br><span class="line">DetachDescriptors(env,fdsToClose);</span><br><span class="line"><span class="keyword">if</span>(!is_system_server)&#123;</span><br><span class="line"><span class="comment">//对于非system_server子进程，则创建进程组</span></span><br><span class="line"><span class="keyword">int</span> rc=createProcessGroup(uid,getpid());</span><br><span class="line">&#125;</span><br><span class="line">SetGids(env,javaGids);</span><br><span class="line">SetRLimits(env,javaRlimits);</span><br><span class="line"><span class="keyword">int</span> rc=setresgid(gid,gid,gid);</span><br><span class="line">rc=setresuid(uid,uid,uid);</span><br><span class="line"><span class="comment">//selinux上下文</span></span><br><span class="line">rc=selinux_android_setcontext(uid,is_system_server,se_info_c_str,se_name_c_str);</span><br><span class="line"><span class="keyword">if</span>(se_info_c_str==<span class="literal">NULL</span> &amp;&amp; is_system_server)&#123;</span><br><span class="line">se_name_c_str=<span class="string">"system_server"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(se_info_c_str!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="comment">//设置线程名为system_server方便调试</span></span><br><span class="line">SetThreadName(se_name_c_str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在Zygote进程中，设置信号SIGCHLD的处理器恢复默认行为</span></span><br><span class="line">UnsetSigChldHandler();</span><br><span class="line"><span class="comment">//等价于调用zygote.callPostForkChildHook()</span></span><br><span class="line">env-&gt;CallStaticVoidMethod(gZygoteClass,gCallPostForkChildHook,debug_flags,</span><br><span class="line">is_system_server?<span class="literal">NULL</span>:instructionSet);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//进入父进程,即zygote进程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-zygote小结"><a href="#3-4-zygote小结" class="headerlink" title="3.4 zygote小结"></a>3.4 zygote小结</h2><p><code>fork()</code>的主要工作是寻找空闲的<code>进程号pid</code>，然后从父进程拷贝进程信息，例如数据段和代码段，fork()后子进程要执行的代码等。 Zygote进程是所有Android进程的母体，包括system_server和各个App进程。zygote利用fork()方法生成新进程，对于新进程A复用Zygote进程本身的资源，再加上新进程A相关的资源，构成新的应用进程A。</p><p><img src="/2017/07/29/Android进程-创建/zygote_fork.jpg" alt="zygote fork"></p><p><img src="/2017/07/29/Android进程-创建/fork_and_specialize.jpg" alt="fork_and_specialize"></p><p>到此App进程已完成了创建的所有工作，接下来开始新创建的App进程的工作。在前面<code>ZygoteConnection.runOnce</code>方法中，zygote进程执行完<code>forkAndSpecialize()</code>后，新创建的App进程便进入<code>handleChildProc()</code>方法，下面的操作运行在App进程。</p><h1 id="4-新进程运行"><a href="#4-新进程运行" class="headerlink" title="4.新进程运行"></a>4.新进程运行</h1><p>创建新进程后，返回值pid=0，继续执行<code>handleChildProc()</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ZygoteConneciton.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleChildProc</span><span class="params">()</span>Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr) </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"><span class="comment">//关闭zygote的socket两端连接</span></span><br><span class="line">closeSocket();</span><br><span class="line">ZygoteInit.closeServerSocket();</span><br><span class="line"><span class="keyword">if</span>(descriptor!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Os.dup2(descriptors[<span class="number">0</span>],STDIN_FIFLENO);</span><br><span class="line">Os.dup2(descriptors[<span class="number">1</span>],STDOUT_FILENO);</span><br><span class="line">Os.dup2(descriptor[<span class="number">2</span>],STDERR_FILENO);</span><br><span class="line"><span class="keyword">for</span>(FileDescriptor fd:descriptor)&#123;</span><br><span class="line">IoUtils.clsoeQuitely(fd);</span><br><span class="line">&#125;</span><br><span class="line">newStderr=System.err;</span><br><span class="line">&#125;<span class="keyword">catch</span>(ErrnoException ex)&#123;</span><br><span class="line">Log.e(TAG,<span class="string">"Error reopening stdio"</span>,ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(parseArgs.niceName!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//设置进程名</span></span><br><span class="line">Process.setArgV0(parseArgs.niceName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(parseArgs.invokeWidth!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//这里检测进程内存泄漏或溢出场景设计</span></span><br><span class="line">WrapperInit.execApplicaiton(parsedArgs.invokeWith,</span><br><span class="line">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                VMRuntime.getCurrentInstructionSet(),</span><br><span class="line">                pipeFd, parsedArgs.remainingArgs);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//执行目标类的main()方法</span></span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                parsedArgs.remainingArgs, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RuntimeInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller</span>&#123;</span><br><span class="line"><span class="comment">//重定向log输出</span></span><br><span class="line">redirectionLogStream();</span><br><span class="line"><span class="comment">//通用的一些初始化</span></span><br><span class="line">commonInit();</span><br><span class="line"><span class="comment">//zygote初始化.启动binder线程池</span></span><br><span class="line">nativeZygoteInit();</span><br><span class="line"><span class="comment">//应用初始化</span></span><br><span class="line">applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-1-commonInit"><a href="#4-1-commonInit" class="headerlink" title="4.1 commonInit"></a>4.1 commonInit</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RuntimeInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commonInit</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 设置默认的未捕捉异常处理方法</span></span><br><span class="line"> Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> UncaughtHandler());</span><br><span class="line"><span class="comment">//设置市区</span></span><br><span class="line">TimezoneGetter.setInstance(<span class="keyword">new</span> TimezoneGetter()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> SystemProperties.get(<span class="string">"persist.sys.timezone"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Timezone.setDefault(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//重置log配置</span></span><br><span class="line">LogManager.getLoManager().reset();</span><br><span class="line"><span class="keyword">new</span> AndroidConfig();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置默认的HTTP User-agent格式，用于HttpURLConneciton</span></span><br><span class="line">String userAgent=getDefaultUserAgent();</span><br><span class="line">System.setProperty(<span class="string">"http.agent"</span>,userAgent);</span><br><span class="line"><span class="comment">//设置socket的tag，用于网络流量统计</span></span><br><span class="line">NetworkManagementSocketTagger.install();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的HTTP User-agent格式，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Dalvik/1.1.0 (Linux; U; Android 6.0.1；LenovoX3c70 Build/LMY47V)&quot;.</span><br></pre></td></tr></table></figure><h2 id="4-2-applicationInit"><a href="#4-2-applicationInit" class="headerlink" title="4.2 applicationInit"></a>4.2 applicationInit</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applicaitonInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller</span>&#123;</span><br><span class="line"><span class="comment">//true代表应用程序退出时不调用AppRuntime.onExit(),否则会在退出前调用</span></span><br><span class="line">nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//设置虚拟机内存利用率参数值为0.75s</span></span><br><span class="line">VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.8</span>=<span class="number">75f</span>);</span><br><span class="line">VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"><span class="keyword">final</span> Argument args;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">args=<span class="keyword">new</span> Argumnet(argv);<span class="comment">//解析参数</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IllegalArgumentException ex)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"><span class="comment">//调用startClass的static方法main()</span></span><br><span class="line">invokeStaticMain(args.startClass,args.startArgs,classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处args.startClass为”android.app.ActivityThread”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RuntimeInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller</span>&#123;</span><br><span class="line">Class&lt;?&gt; cl=Class.forName(className,<span class="keyword">true</span>,classLoader);</span><br><span class="line">Method m=cl.getMethod(<span class="string">"main"</span>,<span class="keyword">new</span> Class[]&#123;String[].class&#125;);</span><br><span class="line"><span class="keyword">int</span> modifiers=m.getModifiers();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//通过抛出异常，回到ZygoteInit.main()，这样好处，能清空栈，体站栈帧利用率</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ZygoteInit.MethodAndArgsCaller(m,argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invokeStaticMain()</code>方法中抛出的异常MethodAndArgsCaller caller，该方法的参数m是指main()方法, argv是指<code>ActivityThread</code>. 根据前面的中可知，下一步进入<code>caller.run()</code>方法，也就是<code>MethodAndArgsCaller.run()</code>。</p><h2 id="4-3MethodAndArgsCaller"><a href="#4-3MethodAndArgsCaller" class="headerlink" title="4.3MethodAndArgsCaller"></a>4.3MethodAndArgsCaller</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ZygoteInit.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">extends</span> <span class="title">Exception</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//根据传递过来的参数，此处反射调用ActivityThread.main()方法</span></span><br><span class="line">mMethod.invoke(<span class="keyword">null</span>,<span class="keyword">new</span> Object[]&#123;margs&#125;);</span><br><span class="line">&#125;<span class="keyword">catch</span> ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，总算是进入到了ActivityThread类的<code>main()</code>方法。</p><h2 id="4-4-ActivityThread-main"><a href="#4-4-ActivityThread-main" class="headerlink" title="4.4 ActivityThread.main"></a>4.4 ActivityThread.main</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">Environment.initForCurrentUser();</span><br><span class="line">...</span><br><span class="line">Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line"><span class="comment">//创建主线程looper</span></span><br><span class="line">Looper.prepareMainLooper();</span><br><span class="line">ActivityThread thread=<span class="keyword">new</span> ActivityThread();</span><br><span class="line"><span class="comment">//attach到系统进程</span></span><br><span class="line">thread.attach(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span>(sMainThreadHandler==<span class="keyword">null</span>)&#123;</span><br><span class="line">sMainThreadHandler=thread.getHandler();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主线程进入循环状态</span></span><br><span class="line">Looper.loop();</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexceptedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p><img src="/2017/07/29/Android进程-创建/process-create.jpg" alt="process-create"></p><p>上图中，<code>system_server</code>进程通过socket IPC通道向zygote进程通信，zygote在fork出新进程后由于fork调用一次，返回两次，即在zygote进程中调用一次，在zygote进程和子进程中各返回一次，从而能进入子进程来执行代码。该调用流程图的过程：</p><ul><li>system_server进程：1~3,通过Process.start()方法发起创建新进程请求，会先收集各种新进程uid、gid、nice-name等相关的参数，然后通过socket通道发送给zygote进程；</li><li><p>zygote进程,4~12.接收到system_server进程发送过来的参数后封装成Arguments对象，图中绿色框forkAndSpecialize()方法是进程创建过程中最为核心的一个环节（详见流程6），其具体工作是依次执行下面的3个方法：</p><ul><li>preFork()：先停止Zygote的4个Daemon子线程（java堆内存整理线程、对线下引用队列线程、析构线程以及监控线程）的运行以及初始化gc堆；</li><li>nativeForkAndSpecialize()：调用linux的fork()出新进程，创建Java堆处理的线程池，重置gc性能数据，设置进程的信号处理函数，启动JDWP线程；</li><li>postForkCommon()：在启动之前被暂停的4个Daemon子线程。</li></ul></li><li><p>新进程：13~15进入<code>handleChildProc()</code>方法，设置进程名，打开binder驱动，启动新的binder线程；然后设置art虚拟机参数，再反射调用目标类的main()方法，即<code>Activity.main()</code>方法。</p></li></ul><p>再之后的流程，如果是<code>startActivity</code>则将要进入Activity的<code>onCreate/onStart/onResume</code>等生命周期；如果是<code>startServic</code>e则将要进入Service的<code>onCreate</code>等生命周期。</p><p>system_server进程等待zygote返回进程创建完成(ZygoteConnection.handleParentProc), 一旦<code>Zygote.forkAndSpecialize()</code>方法执行完成, 那么分道扬镳, <code>zygote</code>告知<code>system_server</code>进程进程已创建, 而子进程继续执行后续的<code>handleChildProc</code>操作.</p><p><strong>Tips2</strong>: <code>RuntimeInit.java</code>的方法<code>nativeZygoteInit()</code>会调用到<code>onZygoteInit()</code>，这个过程中有<code>startThreadPool()</code>创建Binder线程池。也就是说每个进程无论是否包含任何activity等组件，一定至少会包含一个Binder线程。</p><p>参考：</p><p><a href="http://gityuan.com/2016/03/26/app-process-create/#forkandspecialize-1" target="_blank" rel="noopener">理解Android进程创建流程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-准备知识&quot;&gt;&lt;a href=&quot;#1-1-准备知识&quot; class=&quot;headerlink&quot; title=&quot;1.1 准备知识&quot;&gt;&lt;/a&gt;1.1 准备知识&lt;/h2&gt;&lt;p&gt;Android中进程和线程的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt;：每个APP启动前创建一个进程，进程由Zygote fork出来，App中很少提进程概念，APP程序运行在Android Runtime上。APP创建进程方法有：AndroidManifest.xml中配置&lt;code&gt;Android:process&lt;/code&gt;属性，或者native代码系统调用fork.&lt;ul&gt;
&lt;li&gt;&lt;code&gt;system_server&lt;/code&gt;进程：管理整个Java framework层，包含各种系统服务。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Zygote&lt;/code&gt;进程：是Android系统的首个Java进程，是所有Java进程的父进程，包括&lt;code&gt;system_server&lt;/code&gt;进程以及所有的APP进程都是Zygote的子进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程&lt;/strong&gt;:&lt;code&gt;new Thread().start()&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android进程" scheme="http://yoursite.com/tags/Android%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Intent</title>
    <link href="http://yoursite.com/2017/07/01/Intent/"/>
    <id>http://yoursite.com/2017/07/01/Intent/</id>
    <published>2017-07-01T14:48:13.000Z</published>
    <updated>2019-02-02T11:21:31.742Z</updated>
    
    <content type="html"><![CDATA[<p>PKMS除了负责Android系统中Package的<code>安装</code>、<code>升级</code>、<code>卸载</code>外，还有一项很重要的职责，就是对外提供统一的<code>信息查询功能</code>，其中包括查询系统中匹配某Intent的<code>Activities</code>、<code>BroadCastReceivers</code>或<code>Services</code>等。本节将以查询匹配某Intent的Activities为例，介绍PKMS在这方便提供的服务。</p><a id="more"></a><h1 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h1><h2 id="1-1Intent介绍"><a href="#1-1Intent介绍" class="headerlink" title="1.1Intent介绍"></a>1.1Intent介绍</h2><p>Android系统明确指定的一个Intent可由两方面属性来衡量。</p><ul><li><p><code>主要属性</code>：包括Action和Data。其中Action用于表示该Intent所表达的动作意图、Data用于表示该Action所操作的数据。</p></li><li><p><code>次要属性</code>：包括<code>Category</code>、<code>Type</code>、<code>Component</code>和<code>Extras</code>。其中Category表示类别，Type表示数据的MIME类型，Component可用于指定特定的Intent响应者（例如指定广播接收者为某Package的某个BroadcastReceiver），Extras用于承载其他的信息。</p></li></ul><h2 id="1-2IntentFilter介绍"><a href="#1-2IntentFilter介绍" class="headerlink" title="1.2IntentFilter介绍"></a>1.2IntentFilter介绍</h2><p>Andorid规定了3项内容.</p><ul><li><code>Action</code>：求职方支持的Intent动作（和Intent中的Action对应）。</li><li><code>Category</code>：求职方支持的Intent种类（和Intent的Category对应）。</li><li><code>Data</code>：求职方支持的Intent 数据（和Intent的Data对应，包括URI和MIME类型）。</li></ul><h1 id="2-Activity信息的管理"><a href="#2-Activity信息的管理" class="headerlink" title="2. Activity信息的管理"></a>2. Activity信息的管理</h1><p>前面在介绍PKMS扫描APK时提到，PKMS将解析得到的Package私有的Activity信息加入到自己的数据结构mActivities中保存。先来回顾一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[--&gt;PacakgeManagerService.java::scanPackageLI函数]</span></span><br><span class="line">......<span class="comment">//此时APK文件已经解析完成</span></span><br><span class="line">N =pkg.activities.size();<span class="comment">//取出该APK中包含的Activities信息</span></span><br><span class="line">r =<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">   PackageParser.Activity a =pkg.activities.get(i);</span><br><span class="line">   a.info.processName = fixProcessName(pkg.applicationInfo.processName,                                 a.info.processName,pkg.applicationInfo.uid);</span><br><span class="line">   mActivities.addActivity(a,<span class="string">"activity"</span>);<span class="comment">//①加到mActivities中保存</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面的代码中有两个比较重要的数据结构</p><p><img src="/2017/07/01/Intent/20150803111124499.png" alt="数据结构"></p><ul><li><code>mActivities</code>为ActivityIntentResolver类型，是PKMS的成员变量，用于保存系统中所有与Activity相关的信息。此数据结构内部有一个<code>mActivities</code>变量，它以ComponetName为Key，保存<code>PackageParser.Activity</code>对象</li><li>从APK中解析得到的所有和Activity相关的信息（包括在XML中声明的IntentFilter标签）都由PacakgeParser.Activity来保存。</li></ul><p>前面代码中调用addActivity函数完成了私有信息的公有化。addActivity函数的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="title">voidaddActivity</span><span class="params">(PackageParser.Activity a, String type)</span> </span>&#123;</span><br><span class="line">     finalboolean systemApp = isSystemApp(a.info.applicationInfo);</span><br><span class="line">     <span class="comment">//将Component和Activity保存到mActivities中</span></span><br><span class="line">     mActivities.put(a.getComponentName(), a);</span><br><span class="line">     finalint NI = a.intents.size();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;NI; j++) &#123;</span><br><span class="line">     <span class="comment">//ActivityIntentInfo存储的就是XML中声明的IntentFilter信息</span></span><br><span class="line">    PackageParser.ActivityIntentInfo intent = a.intents.get(j);</span><br><span class="line">     <span class="keyword">if</span>(!systemApp &amp;&amp; intent.getPriority() &gt; <span class="number">0</span> &amp;&amp;<span class="string">"activity"</span>.equals(type)) &#123;</span><br><span class="line">          <span class="comment">//非系统APK的priority必须为0。后续分析中将介绍priority的作用</span></span><br><span class="line">          intent.setPriority(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">         addFilter(intent);<span class="comment">//接下来将分析这个函数</span></span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>下面来分析addFilter函数，这里涉及较多的复杂数据结构;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFilter</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">   ......</span><br><span class="line">   mFilters.add(f);<span class="comment">//mFilters保存所有IntentFilter信息</span></span><br><span class="line">   <span class="comment">//除此之外，为了加快匹配工作的速度，还需要分类保存IntentFilter信息</span></span><br><span class="line">   <span class="comment">//下边register_xxx函数的最后一个参数用于打印信息</span></span><br><span class="line">   intnumS = register_intent_filter(f, f.schemesIterator(),                      mSchemeToFilter,<span class="string">"      Scheme: "</span>);</span><br><span class="line">   intnumT = register_mime_types(f, <span class="string">"     Type: "</span>);</span><br><span class="line">   <span class="keyword">if</span>(numS == <span class="number">0</span> &amp;&amp; numT == <span class="number">0</span>) &#123;</span><br><span class="line">register_intent_filter(f, f.actionsIterator(),              mActionToFilter,<span class="string">" Action: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(numT != <span class="number">0</span>) &#123;</span><br><span class="line">           register_intent_filter(f, f.actionsIterator(,            mTypedActionToFilter, <span class="string">"     TypedAction: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>正如代码注释中所说，为了加快匹配工作的速度，这里使用了泛型编程并定义了较多的成员变量。下面总结一下这些变量的作用（注意，除mFilters为<code>HashSet&lt;F&gt;</code>类型外，其他成员变量的类型都是<code>HashMap&lt;String, ArrayList&lt;F&gt;</code>，其中F为模板参数）。</p><ul><li><code>mSchemeToFilter</code>：用于保存<code>URI</code>中与<code>schema</code>相关的<code>IntentFilter</code>信息。</li><li><code>mActionToFilter</code>：用于保存仅设置Action条件的IntentFilter信息。</li><li><code>mTypedActionToFilter</code>：用于保存既设置了Action又设置了Data的MIME类型的IntentFilter信息。</li><li><code>mFilters</code>：用于保存所有IntentFilter信息</li><li><code>mWildTypeToFilter</code>：用于保存设置了Data类型类似<code>image/*</code>的IntentFilter，但是设置MIME类型类似<code>Image/jpeg</code>的不算在此类。</li><li><code>mTypeToFilter</code>：除了包含mWildTypeToFilter外，还包含那些指明了Data类型为确定参数的IntentFilter信息，例如<code>image/*</code>和<code>image/jpeg</code>等都包含在mTypeToFilter中。</li><li><code>mBaseTypeToFilter</code>：包含MIME中Base 类型的IntentFilter信息，但不包括Sub type为<code>*</code>的IntentFilter。</li></ul><p>不妨举个例子来说明这些变量的用法。假设，在XML中声明一个IntentFilter，代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:label</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></span><br><span class="line">   data android:mimeType="audio/*" android:scheme="http"</span><br><span class="line"> <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么：</p><ul><li>在mTypedActionToFilter中能够以“android.intent.action.VIEW”为key找到该IntentFilter。</li><li>在mWildTypeToFilter和mTypeToFilter中能够以“audio”为key找到该IntentFilter。</li><li>在mSchemeToFilter中能够以”http“为key找到该IntentFilter。</li></ul><h1 id="3-Intent-匹配查询分析"><a href="#3-Intent-匹配查询分析" class="headerlink" title="3.Intent 匹配查询分析"></a>3.Intent 匹配查询分析</h1><h2 id="3-1客户端查询"><a href="#3-1客户端查询" class="headerlink" title="3.1客户端查询"></a>3.1客户端查询</h2><p>客户端通过ApplicationPackageManager输出的<code>queryIntentActivities</code>函数向PKMS发起一次查询请求，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;ResolveInfo&gt;queryIntentActivities(Intent intent, <span class="keyword">int</span> flags) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mPM.queryIntentActivities(</span><br><span class="line">               intent,<span class="comment">//下面这句话很重    </span></span><br><span class="line">  intent.resolveTypeIfNeeded(mContext.getContentResolver()), flags);</span><br><span class="line">        &#125;......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Intent的Data包含一个URI，那么就需要查询该URI的提供者（即ContentProvider）以取得该数据的数据类型.另外，flags参数目前有3个可选值，分别是<code>MATCH_DEFAULT_ONLY</code>、<code>GET_INTENT_FILTERS</code>和<code>GET_RESOLVED_FILTER</code>。</p><h2 id="3-2queryIntentActivities分析"><a href="#3-2queryIntentActivities分析" class="headerlink" title="3.2queryIntentActivities分析"></a>3.2queryIntentActivities分析</h2><p>该函数代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[--&gt;PacakgeManagerService.java::queryIntentActivities]</span></span><br><span class="line"><span class="keyword">public</span> List&lt;ResolveInfo&gt;queryIntentActivities(Intent intent,</span><br><span class="line">                                 String resolvedType, <span class="keyword">int</span> flags) &#123;</span><br><span class="line">    <span class="keyword">final</span> ComponentName comp = intent.getComponent();</span><br><span class="line">    <span class="keyword">if</span>(comp != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//Explicit的Intents，直接根据component得到对应的ActivityInfo</span></span><br><span class="line">       <span class="keyword">final</span> List&lt;ResolveInfo&gt; list = <span class="keyword">new</span> ArrayList&lt;ResolveInfo&gt;(<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">final</span> ActivityInfo ai = getActivityInfo(comp, flags);</span><br><span class="line">       <span class="keyword">if</span> (ai != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ResolveInfo ri = <span class="keyword">new</span> ResolveInfo();</span><br><span class="line">            <span class="comment">//ResovlerInfo的activityInfo指向查询得到的ActivityInfo</span></span><br><span class="line">            ri.activityInfo = ai;</span><br><span class="line">            list.add(ri);</span><br><span class="line">       &#125;</span><br><span class="line">           <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">       <span class="keyword">final</span> String pkgName = intent.getPackage();</span><br><span class="line">       <span class="keyword">if</span> (pkgName == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//Implicit Intents，我们重点分析此中情况</span></span><br><span class="line">              <span class="keyword">return</span> mActivities.queryIntent(intent, resolvedType, flags);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//Intent指明了PackageName，比Explicit Intents情况差一点</span></span><br><span class="line">       <span class="keyword">final</span> PackageParser.Package pkg = mPackages.get(pkgName);</span><br><span class="line">       <span class="keyword">if</span> (pkg != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//其实是从该Package包含的Activities中进行匹配查询</span></span><br><span class="line">       <span class="keyword">return</span> mActivities.queryIntentForPackage(intent, resolvedType,</span><br><span class="line">                                           flags, pkg.activities);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;ResolveInfo&gt;();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边代码分三种情况：</p><ul><li>如果Intent指明了Component，则直接查询该Component对应的ActivityInfo。</li><li>如果Intent指明了Package名，则根据Package名找到该Package，然后再从该Package包含的Activities中进行匹配查询。</li><li>如果上面条件都不满足，则需要在全系统范围内进行匹配查询，这就是queryIntent的工作。</li></ul><p>queryIntent函数的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ResolveInfo&gt; <span class="title">queryIntent</span><span class="params">(Intentintent, String resolvedType,intflags)</span> </span>&#123;</span><br><span class="line">    mFlags =flags;</span><br><span class="line">   <span class="comment">//调用基类的queryIntent函数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">super</span>.queryIntent(intent, resolvedType,</span><br><span class="line">               (flags&amp;PackageManager.MATCH_DEFAULT_ONLY) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[--&gt;IntentResolver.java::queryIntent]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;R&gt; <span class="title">queryIntent</span><span class="params">(Intent intent,String resolvedType,booleandefaultOnly)</span> </span>&#123;</span><br><span class="line">  Stringscheme = intent.getScheme();</span><br><span class="line">  ArrayList&lt;R&gt; finalList = <span class="keyword">new</span> ArrayList&lt;R&gt;();</span><br><span class="line">  <span class="comment">//最多有四轮匹配工作要做</span></span><br><span class="line">  ArrayList&lt;F&gt; firstTypeCut = <span class="keyword">null</span>;</span><br><span class="line">  ArrayList&lt;F&gt; secondTypeCut = <span class="keyword">null</span>;</span><br><span class="line">  ArrayList&lt;F&gt; thirdTypeCut = <span class="keyword">null</span>;</span><br><span class="line">  ArrayList&lt;F&gt; schemeCut = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//下面将设置各轮校验者</span></span><br><span class="line">  <span class="keyword">if</span>(resolvedType != <span class="keyword">null</span>) &#123;</span><br><span class="line">     intslashpos = resolvedType.indexOf(<span class="string">'/'</span>);</span><br><span class="line">     <span class="keyword">if</span>(slashpos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">final</span> String baseType = resolvedType.substring(<span class="number">0</span>, slashpos);</span><br><span class="line">         <span class="keyword">if</span> (!baseType.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">             <span class="keyword">if</span> (resolvedType.length() != slashpos+<span class="number">2</span></span><br><span class="line">                   || resolvedType.charAt(slashpos+<span class="number">1</span>) != <span class="string">'*'</span>) &#123;</span><br><span class="line">                       firstTypeCut =mTypeToFilter.get(resolvedType);</span><br><span class="line">                       secondTypeCut =mWildTypeToFilter.get(baseType);</span><br><span class="line">                   &#125;......<span class="comment">//略去一部分内容</span></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span>(scheme != <span class="keyword">null</span>) &#123;</span><br><span class="line">           schemeCut = mSchemeToFilter.get(scheme);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(resolvedType == <span class="keyword">null</span> &amp;&amp; scheme == <span class="keyword">null</span> &amp;&amp; intent.getAction()!= <span class="keyword">null</span>)</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="comment">//看来action的filter优先级最低</span></span><br><span class="line">       firstTypeCut = mActionToFilter.get(intent.getAction());</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//FastImmutableArraySet是一种特殊的数据结构，用于保存该Intent中携带的</span></span><br><span class="line">    <span class="comment">//Category相关的信息。</span></span><br><span class="line">    FastImmutableArraySet&lt;String&gt;categories = getFastIntentCategories(intent);</span><br><span class="line">    <span class="keyword">if</span>(firstTypeCut != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//匹配查询，第一轮过关斩将</span></span><br><span class="line">    buildResolveList(intent, categories, debug, defaultOnly,resolvedType, scheme, firstTypeCut,finalList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(secondTypeCut != <span class="keyword">null</span>) &#123;</span><br><span class="line">        buildResolveList(intent, categories, debug, defaultOnly,resolvedType, scheme, secondTypeCut, finalList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(thirdTypeCut != <span class="keyword">null</span>) &#123;</span><br><span class="line">        buildResolveList(intent, categories, debug, defaultOnly,resolvedType, scheme, thirdTypeCut, finalList);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">if</span>(schemeCut != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//生成符合schemeCut条件的finalList</span></span><br><span class="line">        buildResolveList(intent, categories, debug, defaultOnly, resolvedType, scheme, schemeCut, finalList);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//将匹配结果按Priority的大小排序</span></span><br><span class="line">   sortResults(finalList);</span><br><span class="line">   <span class="keyword">return</span> finalList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中设置了最多四轮匹配关卡，然后逐一执行匹配工作。具体的匹配代码由buildResolveList完成，无非是一项查找工作而已。此处就不再深究细节了，不宜深究其中的数据结构。</p><h1 id="4-queryIntentActivities总结"><a href="#4-queryIntentActivities总结" class="headerlink" title="4.queryIntentActivities总结"></a>4.queryIntentActivities总结</h1><p>本节分析了queryIntentActivities函数的实现，其功能很简单，就是进行Intent匹配查询。一路走来主要原因是涉及的数据结构较多，让人有些头晕。不要在数据结构上花太多时间，最好结合SDK中的文档说明来分析相关代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PKMS除了负责Android系统中Package的&lt;code&gt;安装&lt;/code&gt;、&lt;code&gt;升级&lt;/code&gt;、&lt;code&gt;卸载&lt;/code&gt;外，还有一项很重要的职责，就是对外提供统一的&lt;code&gt;信息查询功能&lt;/code&gt;，其中包括查询系统中匹配某Intent的&lt;code&gt;Activities&lt;/code&gt;、&lt;code&gt;BroadCastReceivers&lt;/code&gt;或&lt;code&gt;Services&lt;/code&gt;等。本节将以查询匹配某Intent的Activities为例，介绍PKMS在这方便提供的服务。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android组件" scheme="http://yoursite.com/tags/Android%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android编译</title>
    <link href="http://yoursite.com/2017/07/01/Android%E7%BC%96%E8%AF%91/"/>
    <id>http://yoursite.com/2017/07/01/Android编译/</id>
    <published>2017-06-30T20:48:46.000Z</published>
    <updated>2019-02-02T11:21:31.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p><code>Android Build系统</code>用来编译<code>andorid系统</code>，<code>Android SDK</code>以及<code>相关文档</code>。<br>Android Build系统主要由<code>Make文件</code>(主要)，<code>shell脚本</code>，以及<code>Python脚本</code>组成。</p><a id="more"></a><p>主要介绍两个：</p><ul><li>1.make系统介绍</li><li>2.添加新产品和新模块.</li></ul><p>整个Build系统的Make分为三类：</p><ul><li>1.整个build系统的框架:<code>/build/core</code></li><li>2.公司名和产品名两级目录：<code>/device/amlogic/xxx</code></li><li>3.针对某个模块:<code>Android.mk</code>内容执行模块的编译</li></ul><h1 id="1-编译整个系统"><a href="#1-编译整个系统" class="headerlink" title="1.编译整个系统"></a>1.编译整个系统</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line">lunch full-eng</span><br><span class="line">make -j32</span><br></pre></td></tr></table></figure><p>命令说明：</p><ul><li>第1行：映入辅助Shell函数，包含lunch函数。</li><li>第2行：列表的内容会根据当前 Build 系统中包含的产品配置而不同</li><li>第3行：真正进行编译。j(Job)，是个整数。该值通常是编译主机 CPU 支持的并发线程总数的 1 倍或 2 倍（例如：在一个 4 核，每个核支持两个线程的 CPU 上，可以使用 make -j8 或 make -j16）。调用 make 命令时，如果<strong>没有指定任何目标</strong>，则将使用默认的名称为<code>droid</code>目标，该目标会<strong>编译出完整的 Android系统镜像</strong>。<h2 id="1-1-build-envsetup-sh"><a href="#1-1-build-envsetup-sh" class="headerlink" title="1.1 /build/envsetup.sh"></a>1.1 <code>/build/envsetup.sh</code></h2></li></ul><p>定义常用函数：</p><table><thead><tr><th>序号</th><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>croot</td><td>切换到源码目录</td></tr><tr><td>2</td><td>m</td><td>切换到根目录并执行make</td></tr><tr><td>3</td><td>mm</td><td>Build当前目录下的模块</td></tr><tr><td>4</td><td>mmm</td><td>Build指定目录下的模块</td></tr><tr><td>5</td><td>cgrep</td><td>在所有<code>c/c++</code>文件执行grep</td></tr><tr><td>6</td><td>jgrep</td><td>在所有Java文件中执行grep</td></tr><tr><td>7</td><td>resgrep</td><td>在所有res/*.xml文件上执行grep</td></tr><tr><td>8</td><td>godir</td><td>转到包含某个文件的目录路径</td></tr><tr><td>9</td><td>printconfig</td><td>显示当前Build配置信息</td></tr><tr><td>10</td><td>add_lunch_combo</td><td>在lunch函数菜单中添加一条目录</td></tr></tbody></table><h2 id="1-2-build目录结构"><a href="#1-2-build目录结构" class="headerlink" title="1.2 build目录结构"></a>1.2 build目录结构</h2><ul><li><code>/out/host</code>:该目录包含针对主机ANDROID开发工具产物，emulator,adb,aapt等</li><li><code>out/target/common</code>:针对设备共同编译产物，主要是java应用代码和java库</li><li><code>out/target/product</code>:包含特定编译结果以及平台相关<code>C/C++库</code>和二进制文件</li><li><code>/out/dist</code>:多种分发而准备的包</li></ul><h2 id="1-3-编译生成镜像"><a href="#1-3-编译生成镜像" class="headerlink" title="1.3 编译生成镜像"></a>1.3 编译生成镜像</h2><p>Build 的产物中最重要的是三个镜像文件，它们都位于 <code>/out/target/product/&lt;product_name&gt;/</code>目录下。这三个文件是：</p><ul><li><code>system.img</code>：包含了 Android OS 的系统文件，库，可执行文件以及预置的应用程序，将被挂载为<code>根分区</code>。</li><li><code>ramdisk.img</code>：在启动时将被 Linux 内核挂载为只读分区，它包含了 <code>/init 文件</code>和<code>一些配置文件</code>。它用来挂载其他系统镜像并启动 <code>init 进程</code>。</li><li><code>userdata.img</code>：将被挂载为 <code>/data</code>，包含了应用程序相关的数据以及和用户相关的数据。</li></ul><h2 id="1-3-Make文件说明"><a href="#1-3-Make文件说明" class="headerlink" title="1.3 Make文件说明"></a>1.3 Make文件说明</h2><p>整个 Build 系统的入口文件是源码树根目录下名称为<strong>Makefile</strong>的文件，当在源代码根目录上调用 make 命令时，make 命令首先将读取该文件。Makefile 文件的内容只有一行：<code>include build/core/main.mk</code>。在 main.mk 文件中又会包含其他的文件，其他文件中又会包含更多的文件，这样就引入了整个 Build 系统。</p><p>这些 Make 文件间的包含关系是相当复杂的，图 3 描述了这种关系，该图中黄色标记的文件（且除了 $开头的文件）都位于 build/core/ 目录下。</p><p><img src="/2017/07/01/Android编译/image004.png" alt="Make文件关系"></p><table><thead><tr><th>序号</th><th>文件名</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><code>/base/Makefile</code></td><td>指向<code>/build/core/main.mk</code></td></tr><tr><td>2</td><td>main.mk</td><td>最主要的 Make 文件，该文件中首先将对<code>编译环境进行检查</code>，同时引入其他的 Make 文件。另外，该文件中还定义了几个最主要的 Make 目标，例如 <code>droid</code>，<code>sdk</code>，等（参见后文“Make 目标说明”）。</td></tr><tr><td>3</td><td>help.mk</td><td>说明  包含了名称为<code>help</code>的 Make目标的定义，该目标将列出主要的 Make 目标及其说明。</td></tr><tr><td>4</td><td>pathmap.mk</td><td>将许<code>多头文件的路径</code>通过<code>名值对的方式定义为映射表</code>，并提供 <code>include-path-for</code>函数来获取。例如，通过 <code>$(call include-path-for, frameworks-native)</code>便可以获取到framework本地代码需要的头文件路径。</td></tr><tr><td>5</td><td>envsetup.mk</td><td>配置Build系统需要的环境变量，例如：<code>TARGET_PRODUCT</code>，<code>TARGET_BUILD_VARIANT</code>，<code>HOST_OS</code>，<code>HOST_ARCH</code> 等。当前<code>编译的主机平台信息</code>（例如操作系统，CPU 类型等信息）就是在这个文件中确定的。另外，该文件中还指定了<code>各种编译结果的输出路径</code>。</td></tr><tr><td>6</td><td><code>combo/select.mk</code></td><td>根据当前编译器的平台选择平台相关的 Make 文件。</td></tr><tr><td>7</td><td>dumpvar.mk</td><td>在 Build 开始之前，显示此次 Build 的配置信息。</td></tr><tr><td>8</td><td><strong>config.mk</strong></td><td>整个Build系统的<code>配置文件</code>。该文件中主要包含以下内容：1.定义了许多的常量来负责不同类型模块的编译。2.定义编译器参数以及常见文件后缀，例如<code>.zip</code>,<code>.jar</code>,<code>.apk</code>。3.根据 BoardConfig.mk 文件,配置产品相关的参数。4.设置一些常用工具的路径，例如<code>flex</code>，<code>e2fsck</code>,<code>dx</code>。</td></tr><tr><td>9</td><td><strong>definitions.mk</strong></td><td>在其中定义了大量的函数。这些函数都是Build系统的其他文件将用到的。例如：<code>my-dir</code>，<code>all-subdir-makefiles</code>，<code>find-subdir-files</code>，<code>sign-package</code>等，关于这些函数的说明请参见每个函数的代码注释。</td></tr><tr><td>10</td><td>distdir.mk</td><td>针对dist目标的定义。dist 目标用来拷贝文件到指定路径。</td></tr><tr><td>11</td><td>dex_preopt.mk</td><td>针对启动 jar 包的预先优化</td></tr><tr><td>12</td><td>pdk_config.mk</td><td>顾名思义，针对 pdk（Platform Developement Kit）的配置文件。</td></tr><tr><td>13</td><td><code>${ONE_SHOT_MAKEFILE}</code></td><td>ONE_SHOT_MAKEFILE 是一个变量，当使用<code>mm</code>编译某个目录下的模块时，此变量的值即为当前指定路径下的Make文件的路径。</td></tr><tr><td>14</td><td><code>${subdir_makefiles}</code></td><td>各个模块的 <code>Android.mk</code>文件的集合，这个集合是通过 Python脚本扫描得到的。</td></tr><tr><td>15</td><td>post_clean.mk</td><td>在前一次 Build 的基础上检查当前 Build 的配置，并执行必要清理工作。</td></tr><tr><td>16</td><td>legacy_prebuilts.mk</td><td>该文件中只定义了 GRANDFATHERED_ALL_PREBUILT 变量。</td></tr><tr><td>17</td><td>Makefile</td><td>被main.mk包含,该文件中的内容是辅助main.mk的一些额外内容。</td></tr></tbody></table><h2 id="1-4-多模块，类型"><a href="#1-4-多模块，类型" class="headerlink" title="1.4 多模块，类型"></a>1.4 多模块，类型</h2><p>Android 源码中包含了许多的模块，模块的类型有很多种。</p><ul><li>Java 库，C/C++ 库，APK 应用，以及可执行文件等 。并且，Java 或者 C/C++ 库还可以分为静态的或者动态的。</li><li>库或可执行文件既可能是针对设备（本文的“设备”指的是 Android 系统将被安装的设备，例如某个型号的手机或平板）的也可能是针对主机（本文的“主机”指的是开发 Android 系统的机器，例如装有 Ubuntu 操作系统的 PC 机或装有 MacOS 的 iMac 或 Macbook）的。</li></ul><p>不同类型的模块的编译步骤和方法是不一样，为了能够一致且方便的执行各种类型模块的编译，在<strong>config.mk</strong>中定义了许多的常量，这其中的每个常量描述了一种类型模块的编译方式，这些常量有：</p><ul><li>BUILD_HOST_STATIC_LIBRARY</li><li>BUILD_HOST_SHARED_LIBRARY</li><li>BUILD_STATIC_LIBRARY</li><li>BUILD_SHARED_LIBRARY</li><li>BUILD_EXECUTABLE</li><li>BUILD_HOST_EXECUTABLE</li><li>BUILD_PACKAGE</li><li>BUILD_PREBUILT</li><li>BUILD_MULTI_PREBUILT</li><li>BUILD_HOST_PREBUILT</li><li>BUILD_JAVA_LIBRARY</li><li>BUILD_STATIC_JAVA_LIBRARY</li><li>BUILD_HOST_JAVA_LIBRARY</li></ul><p>在模块的Android.mk文件中，只要包含进这里对应的常量便可以<strong>执行相应类型模块的编译</strong>。这些常量的值都是另外一个 Make 文件的路径，详细的编译方式都是在对应的 Make 文件中定义的。这些常量和 Make 文件的是一一对应的，对应规则也很简单：常量的名称是 Make 文件的文件名除去后缀全部改为大写然后加上“BUILD_”作为前缀。例如常量BUILD_HOST_PREBUILT的值对应的文件就是 host_prebuilt.mk。</p><table><thead><tr><th>序号</th><th>文件名</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>host_static_library.mk</td><td>定义了如何编译主机上的静态库。</td></tr><tr><td>2</td><td>host_shared_library.mk</td><td>定义了如何编译主机上的共享库。</td></tr><tr><td>3</td><td>static_library.mk</td><td>定义了如何编译设备上的静态库。</td></tr><tr><td>4</td><td>shared_library.mk</td><td>定义了如何编译设备上的共享库。</td></tr><tr><td>5</td><td>executable.mk</td><td>定义了如何编译设备上的可执行文件。</td></tr><tr><td>6</td><td>host_executable.mk</td><td>定义了如何编译主机上的可执行文件。</td></tr><tr><td>7</td><td>package.mk</td><td>定义了<strong>如何编译 APK 文件</strong>。</td></tr><tr><td>8</td><td>prebuilt.mk</td><td>定义了<strong>如何处理一个已经编译好的文件</strong> ( 例如 Jar 包 )。</td></tr><tr><td>9</td><td>multi_prebuilt.mk</td><td>定义了如何处理一个或多个已编译文件，该文件的实现依赖 prebuilt.mk。</td></tr><tr><td>10</td><td>java_library.mk</td><td>定义了如何编译设备上的共享 Java 库。</td></tr><tr><td>11</td><td>static_java_library.mk</td><td>定义了如何编译设备上的静态 Java 库。</td></tr><tr><td>12</td><td>host_java_library.mk</td><td>定义了如何编译主机上的共享 Java 库。</td></tr></tbody></table><p>不同类型的模块的编译过程会有一些相同的步骤，例如：编译一个 Java 库和编译一个 APK 文件都需要定义如何编译 Java 文件。因此，表 3 中的这些 Make 文件的定义中会包含一些共同的代码逻辑。为了减少代码冗余，需要将共同的代码复用起来，复用的方式是将共同代码放到专门的文件中，然后在其他文件中包含这些文件的方式来实现的。</p><p><img src="/2017/07/01/Android编译/image005.png" alt="模块编译"></p><h1 id="2-Make-目标说明"><a href="#2-Make-目标说明" class="headerlink" title="2 Make 目标说明"></a>2 Make 目标说明</h1><h2 id="2-1-make-make-droid"><a href="#2-1-make-make-droid" class="headerlink" title="2.1 make /make droid"></a>2.1 make /make droid</h2><p>如果在源码树的根目录直接调用“make”命令而不指定任何目标，则会选择默认目标：“droid”（在 main.mk 中定义）。因此，这和执行“make droid”效果是一样的。</p><p><code>droid 目标</code>将编译出整个系统的镜像。从源代码到编译出系统镜像，整个编译过程非常复杂。这个过程并不是在droid一个目标中定义的，而是<strong>droid目标会依赖许多其他的目标</strong>，这些目标的互相配合导致了整个系统的编译。</p><p><img src="/2017/07/01/Android编译/image006.png" alt="droid 目标所依赖"></p><table><thead><tr><th>序号</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>app_only</td><td>该目标将编译出当前配置下不包含<code>user</code>,<code>userdebug</code>,<code>eng</code>标签（关于标签，请参见后文<strong>添加新的模块</strong>）的应用程序。</td></tr><tr><td>2</td><td>droidcore</td><td>该目标仅仅是所依赖的几个目标的组合，其本身不做更多的处理。</td></tr><tr><td>3</td><td>dist_files</td><td>该目标用来拷贝文件到 /out/dist 目录。</td></tr><tr><td>4</td><td>files</td><td>该目标仅仅是所依赖的几个目标的组合，其本身不做更多的处理。</td></tr><tr><td>5</td><td>prebuilt</td><td>该目标依赖于 <code>$(ALL_PREBUILT)</code>，<code>$(ALL_PREBUILT)</code>的作用就是处理所有已编译好的文件。</td></tr><tr><td>6</td><td>$(modules_to_install)</td><td>modules_to_install变量包含了当前配置下所有会被安装的模块（一个模块是否会被安装依赖于该产品的配置文件，模块的标签等信息),因此<strong>该目标将导致所有会被安装的模块的编译</strong>。</td></tr><tr><td>7</td><td>$(modules_to_check)</td><td>该目标用来确保我们定义的构建模块是没有冗余的。</td></tr><tr><td>8</td><td>$(INSTALLED_ANDROID_INFO_TXT_TARGET)</td><td>该目标会生成一个关于当前 Build 配置的设备信息的文件，该文件的生成路径是：<code>out/target/product/&lt;product_name&gt;/android-info.txt</code></td></tr><tr><td>9</td><td>systemimage</td><td>生成 system.img。</td></tr><tr><td>10</td><td>$(INSTALLED_BOOTIMAGE_TARGET)</td><td>生成 boot.img。</td></tr><tr><td>10</td><td>$(INSTALLED_RECOVERYIMAGE_TARGET)</td><td>生成 recovery.img。</td></tr><tr><td>11</td><td>$(INSTALLED_USERDATAIMAGE_TARGET)</td><td>生成 userdata.img。</td></tr><tr><td>12</td><td>$(INSTALLED_CACHEIMAGE_TARGET)</td><td>生成 cache.img。</td></tr><tr><td>13</td><td>$(INSTALLED_FILES_FILE)</td><td>该目标会生成<code>out/target/product/&lt;product_name&gt;/ installed-files.txt</code>文件，该文件中内容是当前系统镜像中已经安装的文件列表。</td></tr></tbody></table><h2 id="2-2其他目标"><a href="#2-2其他目标" class="headerlink" title="2.2其他目标"></a>2.2其他目标</h2><p>Build 系统中包含的其他一些 Make 目标说明如表 5 所示：</p><table><thead><tr><th>序号</th><th>目标</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>make clean</td><td>执行清理，等同于：<code>rm -rf out/</code></td></tr><tr><td>2</td><td>make sdk</td><td>编译出 Android 的 SDK。</td></tr><tr><td>3</td><td>make clean-sdk</td><td>清理 SDK 的编译产物。</td></tr><tr><td>4</td><td>make update-api</td><td>更新 API。在 framework API 改动之后，需要首先执行该命令来更新 API，公开的API记录在 <code>frameworks/base/api</code>目录下</td></tr><tr><td>5</td><td>make dist</td><td>执行 Build，并将 <code>MAKECMDGOALS</code>变量定义的输出文件拷贝到<code>/out/dist</code>目录</td></tr><tr><td>6</td><td>make all</td><td>编译所有内容，不管当前产品的定义中是否会包含</td></tr><tr><td>7</td><td>make help</td><td>帮助信息，显示主要的 make 目标</td></tr><tr><td>8</td><td>make snod</td><td>从已经编译出的包快速重建系统镜像</td></tr><tr><td>9</td><td>make libandroid_runtime</td><td>编译所有 JNI framework 内容</td></tr><tr><td>10</td><td><strong>make framework</strong></td><td>编译所有 Java framework 内容</td></tr><tr><td>11</td><td><strong>make services</strong></td><td>编译系统服务和相关内容</td></tr><tr><td>12</td><td>make <code>&lt;local_target&gt;</code></td><td>编译一个指定的模块，local_target 为模块的名称</td></tr><tr><td>13</td><td>make <code>clean-&lt;local_target&gt;</code></td><td>清理一个指定模块的编译结果</td></tr><tr><td>14</td><td>make dump-products</td><td>显示所有产品的编译配置信息，例如：<code>产品名</code>，<code>产品支持的地区语言</code>，<code>产品中会包含的模块</code>等信息</td></tr><tr><td>15</td><td>make PRODUCT-xxx-yyy</td><td>编译某个指定的产品。</td></tr><tr><td>16</td><td>make bootimage</td><td>生成 boot.img</td></tr><tr><td>17</td><td>make recoveryimage</td><td>生成 recovery.img</td></tr><tr><td>18</td><td>make userdataimage</td><td>生成 userdata.img</td></tr><tr><td>19</td><td>make cacheimage</td><td>生成 cache.img</td></tr></tbody></table><h1 id="3-在-Build-系统中添加新的产品"><a href="#3-在-Build-系统中添加新的产品" class="headerlink" title="3.在 Build 系统中添加新的产品"></a>3.在 Build 系统中添加新的产品</h1><p>当我们要开发一款新的 Android 产品的时候，我们首先就需要在 Build 系统中添加对于该产品的定义。</p><p>在 Android Build 系统中对产品定义的文件通常位于 device 目录下（另外还有一个可以定义产品的目录是 vender 目录，这是个历史遗留目录，Google 已经建议不要在该目录中进行定义，而应当选择 device 目录）。device 目录下根据公司名以及产品名分为二级目录.</p><p>通常，对于一个产品的定义通常至少会包括四个文件：</p><ul><li>1.AndroidProducts.mk:该文文件中的内容很简单，其中只需要定义一个变量，名称为“PRODUCT_MAKEFILES”，该变量的值为产品版本定义文件名的列表，例如：</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PRODUCT_MAKEFILES := \ </span><br><span class="line"><span class="variable">$(LOCAL_DIR)</span>/full_stingray.mk \ </span><br><span class="line"><span class="variable">$(LOCAL_DIR)</span>/stingray_emu.mk \ </span><br><span class="line"><span class="variable">$(LOCAL_DIR)</span>/generic_stingray.mk</span><br></pre></td></tr></table></figure><ul><li>2.产品版本定义文件:顾名思义，该文件中包含了对于特定产品版本的定义。该文件可能不只一个，因为同一个产品可能会有多种版本（例如，面向中国地区一个版本，面向美国地区一个版本）。该文件中可以定义的变量以及含义说明如表 6 所示：</li></ul><table><thead><tr><th>序号</th><th>常量</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>PRODUCT_NAME</td><td>最终用户将看到的完整产品名，会出现在<strong>关于手机</strong>信息中</td></tr><tr><td>2</td><td>PRODUCT_MODEL</td><td>产品的型号，这也是最终用户将看到的</td></tr><tr><td>3</td><td>PRODUCT_LOCALES</td><td>该产品支持的地区，以空格分格，例如：en_GB de_DE es_ES fr_CA</td></tr><tr><td>4</td><td>PRODUCT_PACKAGES</td><td>该产品版本中包含的 APK 应用程序，以空格分格，例如：Calendar Contacts</td></tr><tr><td>5</td><td>PRODUCT_DEVICE</td><td>该产品的工业设计的名称</td></tr><tr><td>6</td><td>PRODUCT_MANUFACTURER</td><td>制造商的名称</td></tr><tr><td>7</td><td>PRODUCT_BRAND</td><td>该产品专门定义的商标（如果有的)</td></tr><tr><td>8</td><td>PRODUCT_PROPERTY_OVERRIDES</td><td>对于商品属性的定义</td></tr><tr><td>9</td><td>PRODUCT_COPY_FILES</td><td>编译该产品时需要拷贝的文件，以<strong>源路径:目标路径</strong>的形式</td></tr><tr><td>10</td><td>PRODUCT_OTA_PUBLIC_KEYS</td><td>对于该产品的 OTA 公开 key 的列表</td></tr><tr><td>11</td><td>PRODUCT_POLICY</td><td>产品使用的策略</td></tr><tr><td>12</td><td>PRODUCT_PACKAGE_OVERLAYS</td><td>指出是否要使用默认的资源或添加产品特定定义来覆盖</td></tr><tr><td>13</td><td>PRODUCT_CONTRIBUTORS_FILE</td><td>HTML 文件，其中包含项目的贡献者</td></tr><tr><td>14</td><td>PRODUCT_TAGS</td><td>该产品的标签，以空格分格</td></tr></tbody></table><p>通常情况下，我们并不需要定义所有这些变量。Build 系统的已经预先定义好了一些组合，它们都位于<code>/build/target/product</code>下，每个文件定义了一个组合，我们只要继承这些预置的定义，然后再覆盖自己想要的变量定义即可。例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 继承 full_base.mk 文件中的定义</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> inherit-product, <span class="variable">$(SRC_TARGET_DIR)</span>/product/full_base.mk)</span> </span><br><span class="line"><span class="comment"># 覆盖其中已经定义的一些变量</span></span><br><span class="line">PRODUCT_NAME := full_lt26 </span><br><span class="line">PRODUCT_DEVICE := lt26 </span><br><span class="line">PRODUCT_BRAND := Android </span><br><span class="line">PRODUCT_MODEL := Full Android on LT26</span><br></pre></td></tr></table></figure><ul><li>3.BoardConfig.mk:该文件用来配置硬件主板，它其中定义的都是设备底层的硬件特性。例如：该设备的主板相关信息，Wifi 相关信息，还有 bootloader，内核，radioimage 等信息。对于该文件的示例，请参看 Android 源码树已经有的文件。</li><li>4.verndorsetup.sh。该文件中作用是通过 add_lunch_combo 函数在 lunch 函数中添加一个菜单选项。该函数的参数是产品名称加上编译类型，中间以“-”连接，例如：<code>add_lunch_combo full_lt26-userdebug</code>。<code>/build/envsetup.sh</code>会扫描所有<code>device</code>和<code>vender</code>二 级目 录下的名称 为<code>vendorsetup.sh</code>文件，并根据其中的内容来确定<code>lunch</code>函数的 菜单选项。</li></ul><p>在配置了以上的文件之后，便可以编译出我们新添加的设备的系统镜像了。</p><p>首先，调用“source build/envsetup.sh”该命令的输出中会看到 Build 系统已经引入了刚刚添加的 vendorsetup.sh 文件。</p><p>然后再调用“lunch”函数，该函数输出的列表中将包含新添加的 vendorsetup.sh 中添加的条目。然后通过编号或名称选择即可。</p><p>最后，调用“make -j8”来执行编译即可。</p><h1 id="4-添加新的模块"><a href="#4-添加新的模块" class="headerlink" title="4.添加新的模块"></a>4.添加新的模块</h1><p>在源码树中，一个模块的所有文件通常都位于同一个文件夹中。为了将当前模块添加到整个 Build 系统中，每个模块都需要一个专门的 Make 文件，该文件的名称为“Android.mk”。Build 系统会扫描名称为“Android.mk”的文件，并根据该文件中内容编译出相应的产物。</p><p><strong>需要注意的是</strong>：在 Android Build 系统中，编译是以<code>模块</code>（而不是文件）作为单位的，<strong>每个模块都有一个唯一的名称</strong>，<strong>一个模块的依赖对象只能是另外一个模块</strong>，而不能是其他类型的对象。对于已经编译好的二进制库，<code>如果要用来被当作是依赖对象，那么应当将这些已经编译好的库作为单独的模块</code>。对于这些已经编译好的库使用<code>BUILD_PREBUILT</code>或 <code>BUILD_MULTI_PREBUILT</code>。例如：当编译某个 Java 库需要依赖一些 Jar 包时，<code>并不能直接指定 Jar 包的路径作为依赖</code>，<code>而必须首先将这些 Jar 包定义为一个模块</code>，然后在编译 Java 库的时候通过模块的名称来依赖这些 Jar 包。</p><p>下面，我们就来讲解 Android.mk 文件的编写：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置当前模块的编译路径为当前文件夹路径</span></span><br><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span> </span><br><span class="line"><span class="comment">#清理（可能由其他模块设置过的）编译环境中用到的变量</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br></pre></td></tr></table></figure><p>为了方便模块的编译，Build 系统设置了很多的编译环境变量。要编译一个模块，只要在编译之前根据需要设置这些变量然后执行编译即可。它们包括：</p><ul><li><code>LOCAL_SRC_FILES</code>：当前模块包含的所有源代码文件</li><li><code>LOCAL_MODULE</code>：当前模块的名称，这个名称应当是唯一的，模块间的依赖关系就是通过这个名称来引用的。</li><li><code>LOCAL_C_INCLUDES</code>：C 或 C++ 语言需要的头文件的路径。</li><li><code>LOCAL_STATIC_LIBRARIES</code>：当前模块在<code>静态链接</code>时需要的库的名称</li><li><code>LOCAL_SHARED_LIBRARIES</code>：当前模块在<code>运行时</code>依赖的动态库的名称</li><li><code>LOCAL_CFLAGS</code>：提供给 C/C++ 编译器的额外编译参数</li><li><code>LOCAL_JAVA_LIBRARIES</code>：当前模块依赖的 Java 共享库</li><li><code>LOCAL_STATIC_JAVA_LIBRARIES</code>：当前模块依赖的 Java 静态库</li><li><code>LOCAL_PACKAGE_NAME</code>：当前 APK 应用的名称</li><li><code>LOCAL_CERTIFICATE</code>：签署当前应用的证书名称</li><li><code>LOCAL_MODULE_TAGS</code>：当前模块所包含的标签，一个模块可以包含多个标签。标签的值可能是 <code>debug</code>, <code>eng</code>, <code>user</code>，<code>development</code> 或者 <code>optional</code>。其中，optional 是默认标签。标签是提供给编译类型使用的。不同的编译类型会安装包含不同标签的模块.</li></ul><table><thead><tr><th>序号</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>eng</td><td>默认类型，该编译类型适用于开发阶段。当选择这种类型时，编译结果将：1.安装包含 eng, debug, user，development 标签的模块，2.安装所有没有标签的非 APK 模块，3.安装所有产品定义文件中指定的 APK 模块</td></tr><tr><td>2</td><td>user</td><td>该编译类型适合用于最终发布阶段。当选择这种类型时，编译结果将：1.安装所有带有user标签的模块2.安装所有没有标签的非 APK 模块3.安装所有产品定义文件中指定的 APK 模块，APK 模块的标签将被忽略</td></tr><tr><td>3</td><td>userdebug</td><td>该编译类型适合用于debug 阶段。该类型和 user 一样，除了：会安装包含 debug 标签的模块编译出的系统具有 root 访问权限</td></tr></tbody></table><p>Build 系统中还定义了一些便捷的函数以便在 Android.mk 中使用，包括：</p><ul><li><code>$(call my-dir)</code>：获取当前文件夹路径。</li><li><code>$(call all-java-files-under, &lt;src&gt;)</code>：获取指定目录下的所有 Java 文件。</li><li><code>$(call all-c-files-under, &lt;src&gt;)</code>：获取指定目录下的所有 C 语言文件。</li><li><code>$(call all-Iaidl-files-under, &lt;src&gt;)</code>：获取指定目录下的所有 AIDL 文件</li><li><code>$(call all-makefiles-under, &lt;folder&gt;)</code>：获取指定目录下的所有 Make 文件</li><li><code>$(call intermediates-dir-for, &lt;class&gt;, &lt;app_name&gt;, &lt;host or target&gt;, &lt;common?&gt; )</code>：获取 Build 输出的目标文件夹路径。</li></ul><h2 id="4-1-编译一个-APK-文件"><a href="#4-1-编译一个-APK-文件" class="headerlink" title="4.1 编译一个 APK 文件"></a>4.1 编译一个 APK 文件</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span> </span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span> </span><br><span class="line"><span class="comment"># 获取所有子目录中的 Java 文件</span></span><br><span class="line">LOCAL_SRC_FILES := <span class="variable">$(<span class="built_in">call</span> all-subdir-java-files)</span>          </span><br><span class="line"><span class="comment"># 当前模块依赖的静态 Java 库，如果有多个以空格分隔</span></span><br><span class="line">LOCAL_STATIC_JAVA_LIBRARIES := static-library </span><br><span class="line"><span class="comment"># 当前模块的名称</span></span><br><span class="line">LOCAL_PACKAGE_NAME := LocalPackage </span><br><span class="line"><span class="comment"># 编译 APK 文件</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_PACKAGE)</span></span><br></pre></td></tr></table></figure><h2 id="4-2-编译一个-Java-的静态库"><a href="#4-2-编译一个-Java-的静态库" class="headerlink" title="4.2 编译一个 Java 的静态库"></a>4.2 编译一个 Java 的静态库</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span> </span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span> </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 获取所有子目录中的 Java 文件</span></span><br><span class="line">LOCAL_SRC_FILES := <span class="variable">$(<span class="built_in">call</span> all-subdir-java-files)</span> </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 当前模块依赖的动态 Java 库名称</span></span><br><span class="line">LOCAL_JAVA_LIBRARIES := android.test.runner </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 当前模块的名称</span></span><br><span class="line">LOCAL_MODULE := sample </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 将当前模块编译成一个静态的 Java 库</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_STATIC_JAVA_LIBRARY)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-概述&quot;&gt;&lt;a href=&quot;#0-概述&quot; class=&quot;headerlink&quot; title=&quot;0.概述&quot;&gt;&lt;/a&gt;0.概述&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Android Build系统&lt;/code&gt;用来编译&lt;code&gt;andorid系统&lt;/code&gt;，&lt;code&gt;Android SDK&lt;/code&gt;以及&lt;code&gt;相关文档&lt;/code&gt;。&lt;br&gt;Android Build系统主要由&lt;code&gt;Make文件&lt;/code&gt;(主要)，&lt;code&gt;shell脚本&lt;/code&gt;，以及&lt;code&gt;Python脚本&lt;/code&gt;组成。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android脚本" scheme="http://yoursite.com/tags/Android%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Android 进程(一)</title>
    <link href="http://yoursite.com/2017/06/29/Android-%E8%BF%9B%E7%A8%8B-%E4%B8%80/"/>
    <id>http://yoursite.com/2017/06/29/Android-进程-一/</id>
    <published>2017-06-29T14:55:00.000Z</published>
    <updated>2019-02-02T11:21:31.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-优先级"><a href="#1-优先级" class="headerlink" title="1.优先级"></a>1.优先级</h1><p>Android 进程优先级，分为10级。优先级调度方法<code>setThreadPriority(int tid,int priority)</code></p><a id="more"></a><h2 id="1-1-进程优先级"><a href="#1-1-进程优先级" class="headerlink" title="1.1 进程优先级"></a>1.1 进程优先级</h2><table><thead><tr><th>进程优先级</th><th>nice值</th><th>解释</th></tr></thead><tbody><tr><td>THREAD_PRIORITY_LOWEST</td><td>19</td><td>最低优先级</td></tr><tr><td>THREAD_PRIORITY_BACKGROUND</td><td>10</td><td>后台</td></tr><tr><td>THREAD_PRIORITY_LESS_FAVOERABLE</td><td>1</td><td>比默认低</td></tr><tr><td>THREAD_PRIORITY_DEFAULT</td><td>0</td><td>默认</td></tr><tr><td>THREAD_PRIORITY_MORE_FAVORABLE</td><td>-1</td><td>比默认高</td></tr><tr><td>THREAD_PRIORITY_FORGROUND</td><td>-2</td><td>前台</td></tr><tr><td>THRAED_PRIORITY_DISPLAY</td><td>-4</td><td>显示相关</td></tr><tr><td>THREAD_PRIORITY_URGENT_DISPLAY</td><td>-8</td><td>显示（更为重要），input事件</td></tr><tr><td>THREAD_PRIORITY_AUDIO</td><td>-16</td><td>音频相关</td></tr><tr><td>THREAD_PRIORITY_URGENT_AUDIO</td><td>-19</td><td>音频（更为重要）</td></tr></tbody></table><h2 id="1-2组优先级别"><a href="#1-2组优先级别" class="headerlink" title="1.2组优先级别"></a>1.2组优先级别</h2><table><thead><tr><th>组优先级</th><th>取值</th><th>解释</th></tr></thead><tbody><tr><td>THREAD_GROUP_DEFAULT</td><td>-1</td><td>仅用于setProcessGroup,将优先级M=10进程提升到-2</td></tr><tr><td>THREAD_GROUP_BG_NONINTERACTIVE</td><td>0</td><td>CPU分时的时长缩短</td></tr><tr><td>THREAD_GROUP_FROGROUND</td><td>1</td><td>CPU分时的时长正常</td></tr><tr><td>THREAD_GROUP_SYSTEM</td><td>2</td><td>系统线程组</td></tr><tr><td>THREAD_GROUP_AUDIO_APP</td><td>3</td><td>应用程序音频</td></tr><tr><td>THREAD_GROUP_AUDIO_SYS</td><td>4</td><td>系统程序音频</td></tr></tbody></table><h1 id="2-调度器选择"><a href="#2-调度器选择" class="headerlink" title="2. 调度器选择"></a>2. 调度器选择</h1><p>设置调度器方法：<code>setThreadSchduler(int tid int policy,int priority)</code></p><table><thead><tr><th>调度器</th><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>SCHED_OTHER</td><td>默认</td><td>标准round-robin分时共享策略</td></tr><tr><td>SCHED_BATCH</td><td>批处理调度</td><td>针对具有batch风格(批处理)进程的调度策略</td></tr><tr><td>SCHED_IDLE</td><td>空闲调度</td><td>针对优先级非常低的适合在后台运行的进程</td></tr><tr><td>SCHED_FIFO</td><td>先进先出</td><td>实时调度策略，android暂未实现</td></tr><tr><td>SCHED_RR</td><td>循环调度</td><td>实时调度策略，Android暂未实现</td></tr></tbody></table><h1 id="3-Android进程声明周期"><a href="#3-Android进程声明周期" class="headerlink" title="3.Android进程声明周期"></a>3.Android进程声明周期</h1><p>进程的重要性，划分5级：</p><ul><li>1.前台进程(Foreground process)<ul><li>用户当前操作所必需的进程。</li></ul></li><li>2.可见进程(Visible process)<ul><li>没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。</li></ul></li><li>3.服务进程(Service process)<ul><li>尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。</li></ul></li><li>4.后台进程(Background process)<ul><li>后台进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。</li></ul></li><li>5.空进程(Empty process)<ul><li>保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</li></ul></li></ul><p>前台进程的重要性最高，依次递减，空进程的重要性最低。</p><h1 id="4-Lowmemorykiller"><a href="#4-Lowmemorykiller" class="headerlink" title="4.Lowmemorykiller"></a>4.Lowmemorykiller</h1><p>Android中对于内存的回收，主要依靠Lowmemorykiller来完成，是一种根据阈值级别触发相应力度的内存回收的机制。</p><h2 id="4-1-ADJ级别"><a href="#4-1-ADJ级别" class="headerlink" title="4.1  ADJ级别"></a>4.1  ADJ级别</h2><p>定义在ProcessList.java文件，oom_adj划分为16级，从<code>-17</code>到<code>16</code>之间取值。</p><table><thead><tr><th>ADJ级别</th><th>取值</th><th>解释</th></tr></thead><tbody><tr><td>UNKNOWN_ADJ</td><td>16</td><td>一般指将要会缓存进程，无法获取确定值</td></tr><tr><td>CACHED_APP_MAX_ADJ</td><td>15</td><td>不可见进程的adj最大值 1</td></tr><tr><td>CACHED_APP_MIN_ADJ</td><td>9</td><td>不可见进程的adj最小值 2</td></tr><tr><td>SERVICE_B_AD</td><td>8</td><td>B List中的Service（较老的、使用可能性更小）</td></tr><tr><td>PREVIOUS_APP_ADJ</td><td>7</td><td>上一个App的进程(往往通过按返回键)</td></tr><tr><td>HOME_APP_ADJ</td><td>6</td><td>Home进程</td></tr><tr><td>SERVICE_ADJ</td><td>5</td><td>服务进程(Service process)</td></tr><tr><td>HEAVY_WEIGHT_APP_ADJ</td><td>4</td><td>后台的重量级进程，<code>system/rootdir/init.rc</code>文件中设置</td></tr><tr><td>BACKUP_APP_ADJ</td><td>3</td><td>备份进程 3</td></tr><tr><td>PERCEPTIBLE_APP_ADJ</td><td>2</td><td>可感知进程，比如后台音乐播放 4</td></tr><tr><td>VISIBLE_APP_ADJ</td><td>1</td><td>可见进程(Visible process) 5</td></tr><tr><td>FOREGROUND_APP_ADJ</td><td>0</td><td>前台进程（Foreground process） 6</td></tr><tr><td>PERSISTENT_SERVICE_ADJ</td><td>-11</td><td>关联着系统或persistent进程</td></tr><tr><td>PERSISTENT_PROC_ADJ</td><td>-12</td><td>系统persistent进程，比如telephony</td></tr><tr><td>SYSTEM_ADJ</td><td>-16</td><td>系统进程</td></tr><tr><td>NATIVE_ADJ</td><td>-17</td><td>native进程（不被系统管理）</td></tr></tbody></table><h2 id="4-2-进程state级别"><a href="#4-2-进程state级别" class="headerlink" title="4.2 进程state级别"></a>4.2 进程state级别</h2><p>定义在ActivityManager.java文件，process_state划分18类，从<code>-1</code>到<code>16</code>之间取值。</p><table><thead><tr><th>state级别</th><th>取值</th><th>解释</th></tr></thead><tbody><tr><td>PROCESS_STATE_CACHED_EMPTY</td><td>16</td><td>进程处于cached状态，且为空进程</td></tr><tr><td>PROCESS_STATE_CACHED_ACTIVITY_CLIENT</td><td>15</td><td>进程处于cached状态，且为另一个cached进程(内含Activity)的client进程</td></tr><tr><td>PROCESS_STATE_CACHED_ACTIVITY</td><td>14</td><td>进程处于cached状态，且内含Activity</td></tr><tr><td>PROCESS_STATE_LAST_ACTIVITY</td><td>13</td><td>后台进程，且拥有上一次显示的Activity</td></tr><tr><td>PROCESS_STATE_HOME</td><td>12</td><td>后台进程，且拥有home Activity</td></tr><tr><td>PROCESS_STATE_RECEIVER</td><td>11</td><td>后台进程，且正在运行receiver</td></tr><tr><td>PROCESS_STATE_SERVICE</td><td>10</td><td>后台进程，且正在运行service</td></tr><tr><td>PROCESS_STATE_HEAVY_WEIGHT</td><td>9</td><td>后台进程，但无法执行restore，因此尽量避免kill该进程</td></tr><tr><td>PROCESS_STATE_BACKUP</td><td>8</td><td>后台进程，正在运行backup/restore操作</td></tr><tr><td>PROCESS_STATE_IMPORTANT_BACKGROUND</td><td>7</td><td>对用户很重要的进程，用户不可感知其存在</td></tr><tr><td>PROCESS_STATE_IMPORTANT_FOREGROUND</td><td>6</td><td>对用户很重要的进程，用户可感知其存在</td></tr><tr><td>PROCESS_STATE_TOP_SLEEPING</td><td>5</td><td>与PROCESS_STATE_TOP一样，但此时设备正处于休眠状态</td></tr><tr><td>PROCESS_STATE_FOREGROUND_SERVICE</td><td>4</td><td>拥有给一个前台Service</td></tr><tr><td>PROCESS_STATE_BOUND_FOREGROUND_SERVICE</td><td>3</td><td>拥有给一个前台Service，且由系统绑定</td></tr><tr><td>PROCESS_STATE_TOP</td><td>2</td><td>拥有当前用户可见的top Activity</td></tr><tr><td>PROCESS_STATE_PERSISTENT_UI</td><td>1</td><td>persistent系统进程，并正在执行UI操作</td></tr><tr><td>PROCESS_STATE_PERSISTENT</td><td>0</td><td>persistent系统进程</td></tr><tr><td>PROCESS_STATE_NONEXISTENT</td><td>-1</td><td>不存在的进程</td></tr></tbody></table><h2 id="4-3-lmk策略"><a href="#4-3-lmk策略" class="headerlink" title="4.3 lmk策略"></a>4.3 lmk策略</h2><p>lowmemorykiller根据当前可用内存情况来进行进程释放，总设计了6个级别：</p><ul><li>1.CACHED_APP_MAX_ADJ</li><li>2.CACHED_APP_MIN_ADJ</li><li>3.BACKUP_APP_ADJ</li><li>4.PERCEPTIBLE_APP_ADJ</li><li>5.VISIBLE_APP_ADJ</li><li>6.FOREGROUND_APP_ADJ</li></ul><p>系统内存从很宽裕到不足，<code>Lowmemorykiller</code>也会相应地从CACHED_APP_MAX_ADJ(第1档)开始杀进程，如果内存还不足，那么会杀CACHED_APP_MIN_ADJ(第2档)，不断深入，直到满足内存阈值条件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-优先级&quot;&gt;&lt;a href=&quot;#1-优先级&quot; class=&quot;headerlink&quot; title=&quot;1.优先级&quot;&gt;&lt;/a&gt;1.优先级&lt;/h1&gt;&lt;p&gt;Android 进程优先级，分为10级。优先级调度方法&lt;code&gt;setThreadPriority(int tid,int priority)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android进程" scheme="http://yoursite.com/tags/Android%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>contentprovider使用</title>
    <link href="http://yoursite.com/2017/03/11/contentprovider%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/03/11/contentprovider使用/</id>
    <published>2017-03-11T15:49:14.000Z</published>
    <updated>2019-02-02T11:21:31.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><ul><li>Content Providers将自己的数据安全封装给自己或别的app访问。</li><li>Content providers是一套接口，可连接不同的应用，能够让别的app安全访问和修改你的数据。</li><li>还有一点好处，content provider进行数据抽象，当你修改自己的数据，比如SQL转到其他数据库，其他app不用去修改。</li></ul><a id="more"></a><p><strong>CursorLoader</strong>对象依赖于content provider，能够用来异步查询，并返回结果给UI层。<a href="https://developer.android.com/guide/components/loaders" target="_blank" rel="noopener">用CursorLoader来查寻</a></p><h1 id="1-概要"><a href="#1-概要" class="headerlink" title="1.概要"></a>1.概要</h1><p>content provider访问数据有很多不同的api。</p><ul><li>和其他应用共享</li><li>发送数据给widget</li><li>通过<a href="https://developer.android.com/reference/android/content/SearchRecentSuggestionsProvider" target="_blank" rel="noopener">SearchRecentSuggestionsProvider</a>返回给应用搜索建议</li><li>和服务器同步应用数据，使用<a href="https://developer.android.com/reference/android/content/AbstractThreadedSyncAdapter" target="_blank" rel="noopener">AbstractThreadedSyncAdapter</a></li><li>在UI中加载数据使用<a href="https://developer.android.com/reference/android/content/CursorLoader" target="_blank" rel="noopener">CursorLoader</a></li></ul><h1 id="2-获得一个provider"><a href="#2-获得一个provider" class="headerlink" title="2.获得一个provider"></a>2.获得一个provider</h1><p>使用ContentResolver和Content provider进行交互。UI层交互过程应该这样实现：</p><p><img src="/2017/03/11/contentprovider使用/content-provider-interaction.png" alt="UI使用"></p><h2 id="2-1-query数据"><a href="#2-1-query数据" class="headerlink" title="2.1 query数据"></a>2.1 query数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查询用户字典和返回结果</span><br><span class="line">mCursor=getContentResolver().query(</span><br><span class="line">UserDictionary.Words.CONTENT_URI,//Uri,相当于FROM table_name，查询表名称</span><br><span class="line">mProjections,//col,col，待查询每行数据对应列数组</span><br><span class="line">mSelectingCluase,//指定选择行的条件</span><br><span class="line">mSelectionArgs,//指定选择行的参数</span><br><span class="line">mSortOrder//返回选择行排序Cursor</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="3-Conent-Uri"><a href="#3-Conent-Uri" class="headerlink" title="3.Conent Uri"></a>3.Conent Uri</h1><p>外界进程通过URI找到对应的ContentProvider和其中的数据，再进行数据操作<br>URI分为<strong>系统预置</strong>和<strong>自定义</strong>1，分别对应系统内置的数据（如通讯录、日程表等等）和自定义数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自定义URI=content://com.ellabrain.provider/User/1</span><br></pre></td></tr></table></figure><ul><li><code>content://</code>:主题(schema),Android规定ContentProvider的前缀</li><li><code>com.ellabrain.provider</code>:授权信息(authority),ContentProvider唯一标识</li><li><code>User</code>:表名</li><li><code>1</code>：记录(ID),表中某一个记录(若无指定，则返回全部记录)</li></ul><p>使用表中唯一行数据，比如<code>_ID</code>是4，可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uri 4thUri=ContentUris.withAppendedId(&quot;content://com.ellabrain.provider/User&quot;,4);</span><br></pre></td></tr></table></figure><h1 id="4-获取数据query"><a href="#4-获取数据query" class="headerlink" title="4.获取数据query"></a>4.获取数据query</h1><p>用下面表进行演示：</p><table><thead><tr><th>word</th><th>app id</th><th>frequency</th><th>locale</th><th>_ID</th></tr></thead><tbody><tr><td>mapreduce</td><td>user1</td><td>100</td><td>en_US</td><td>1</td></tr><tr><td>precompiler</td><td>user14</td><td>200</td><td>fr_FR</td><td>2</td></tr><tr><td>applet</td><td>user2</td><td>225</td><td>fr_CA</td><td>3</td></tr><tr><td>const</td><td>user1</td><td>255</td><td>pt_BR</td><td>4</td></tr><tr><td>int</td><td>user5</td><td>100</td><td>en_UK</td><td>5</td></tr></tbody></table><p>获取数据应该有两步：</p><ul><li>获得provider读权限</li><li>写查询provider的代码</li></ul><h2 id="4-1获取读权限"><a href="#4-1获取读权限" class="headerlink" title="4.1获取读权限"></a>4.1获取读权限</h2><p>需要在mainfest中用<code>&lt;uses-permisssion&gt;</code>标签中声明，声明的内容就是在provider中写的权限的名字，要保证两者一样。</p><h2 id="4-2写代码query"><a href="#4-2写代码query" class="headerlink" title="4.2写代码query"></a>4.2写代码query</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a prejection 其中返回行需要的哪些栏目</span></span><br><span class="line">String[] mProjection=&#123;</span><br><span class="line">UserDictionary.Words._ID,   </span><br><span class="line">    UserDictionary.Words.WORD,   </span><br><span class="line">    UserDictionary.Words.LOCALE</span><br><span class="line">&#125;;</span><br><span class="line">String mSelectionClause=<span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//初始化选择参数</span></span><br><span class="line">String [] mSelectionArgs=&#123;<span class="string">""</span>&#125;;</span><br></pre></td></tr></table></figure><p>行获取表达方式被分解成<code>selection clause</code>和<code>selection argumnets</code>.</p><ul><li><code>selection clause</code>由一个逻辑和布尔表达式，栏目名称，和值。<ul><li>设置null，则表示符栏目返回所有数据。</li><li>如果输入值，形式如<code>UserDictionary.Words.WORD + &quot; = ?&quot;</code>从selection arguments中获取，本例子从用户输入获取。</li></ul></li><li>如果<code>selection clause</code>使用替换参数<code>?</code>,参数从<code>selection arguments</code>中获取。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">String[] mSelectionArgs = &#123;<span class="string">""</span>&#125;;</span><br><span class="line"><span class="comment">//从UI获取一个单词</span></span><br><span class="line">mSearchString = mSearchWord.getText().toString();</span><br><span class="line"><span class="comment">//检查是否输入是否为空</span></span><br><span class="line"><span class="keyword">if</span>(TextUtils.isEmpty(mSearchString))&#123;</span><br><span class="line"><span class="comment">//设置selection clause 为null，将会返回所有单词</span></span><br><span class="line">mSelectionCluase=<span class="keyword">null</span>;</span><br><span class="line">mSelectionArgs[<span class="number">0</span>]=<span class="string">""</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">mSelectionClasue=UserDictionary.Words.WORD+<span class="string">""</span>= ?;</span><br><span class="line">mSelectionArgs[<span class="number">0</span>]=mSearchString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询用户字典和返回结果</span></span><br><span class="line">mCursor=getContentResolver().query(</span><br><span class="line">UserDictionary.Words.CONTENT_URI,<span class="comment">//Uri,相当于FROM table_name，查询表名称</span></span><br><span class="line">mProjections,<span class="comment">//col,col，待查询每行数据对应列数组</span></span><br><span class="line">mSelectingCluase,<span class="comment">//指定选择行的条件</span></span><br><span class="line">mSelectionArgs,<span class="comment">//指定选择行的参数</span></span><br><span class="line">mSortOrder<span class="comment">//返回选择行排序Cursor</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span>==mCursor)&#123;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(mCursor.getCount()&lt;<span class="number">1</span>)&#123;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面类似于SQL的语句为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT _ID, word ,locale FROM words WHERE word = &lt;userinput&gt; ORDER BY word ASC;</span><br></pre></td></tr></table></figure><h2 id="4-3避免恶意输入"><a href="#4-3避免恶意输入" class="headerlink" title="4.3避免恶意输入"></a>4.3避免恶意输入</h2><p>使用<code>?</code>可避免恶意输入。假如使用如下语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String mSelectionClause =  &quot;var = &quot; + mUserInput;</span><br></pre></td></tr></table></figure><p>如果用户输入内从容为<code>nothing; DROP TABLE *;&quot;</code>那么将会执行该SQL语句导致删除整个数据。使用<code>?</code>不会将输入当成SQL语句来执行，从而得到保护。</p><h2 id="4-4显示查询结果"><a href="#4-4显示查询结果" class="headerlink" title="4.4显示查询结果"></a>4.4显示查询结果</h2><p>查询返回一个<code>Cursor</code>对象。用<code>Cursor</code>对象可以遍历返回结果的所有行，来得到每栏目数据类型，得到栏目数据，和检查其他结果属性。一些<code>Cursor</code>当数据改变自动更新对象，并触发观察方法。</p><p>如果没有和选择条件匹配，返回一个<code>Cursor</code>对象，但是<code>Cursor.getCount()</code>是0.出错的时候返回null，或者抛出Exception。</p><p>下面举例说明将<code>Cursor</code>展示在<code>ListView</code>中.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String[] mWordListColumns=</span><br><span class="line">&#123;</span><br><span class="line">UserDictionary.Words.WORD,</span><br><span class="line">UserDictionary.Words.LOCALE</span><br><span class="line">&#125;;</span><br><span class="line">int[] mWordListItems=&#123;R.id.dictWord,R.id.locale&#125;;</span><br><span class="line"></span><br><span class="line">mCursorAdapter=new SimpleCursorAdapter&#123;</span><br><span class="line">getApplicaitonContext(),</span><br><span class="line">R.layout.worlistrow,</span><br><span class="line">mCursor,</span><br><span class="line">mWordListColumns,</span><br><span class="line">mWordListItems,</span><br><span class="line">0</span><br><span class="line">&#125;;</span><br><span class="line">mWordList.setAdapter(mCursorAdapter);</span><br></pre></td></tr></table></figure><h2 id="4-5从查询结果中获取数据"><a href="#4-5从查询结果中获取数据" class="headerlink" title="4.5从查询结果中获取数据"></a>4.5从查询结果中获取数据</h2><p>Cursor提供<code>get</code>方法获取元素，可以是<code>getType</code>，<code>getString</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//看栏"word"的栏索引</span></span><br><span class="line"><span class="keyword">int</span> index=mCursor.getColumnIndex(UserDictionary.Words.WORD);</span><br><span class="line"><span class="keyword">if</span>(mCursor!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//在第一次移动之前，行索引为-1.如果第一次不移动会得到exception</span></span><br><span class="line"><span class="keyword">while</span>(mCursor.moveToNext())&#123;</span><br><span class="line">newWord=mCursor.getString(index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="5-insert-update和delete数据"><a href="#5-insert-update和delete数据" class="headerlink" title="5.insert,update和delete数据"></a>5.insert,update和delete数据</h1><h2 id="5-1insert-data"><a href="#5-1insert-data" class="headerlink" title="5.1insert data"></a>5.1insert data</h2><p>插入新行到provider中，返回一个那个行的URI。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Uri mNewUri;</span><br><span class="line">//定义一个对象包含插入信息</span><br><span class="line">ContentValue mNewValues=new ContentValues();</span><br><span class="line">mNewValues.put(UserDictionary.Words.APP_ID, &quot;example.user&quot;);</span><br><span class="line">mNewValues.put(UserDictionary.Words.LOCALE, &quot;en_US&quot;);</span><br><span class="line">mNewValues.put(UserDictionary.Words.WORD, &quot;insert&quot;);</span><br><span class="line">mNewValues.put(UserDictionary.Words.FREQUENCY, &quot;100&quot;);</span><br><span class="line">mNewUri = getContentResolver().insert(</span><br><span class="line">    UserDictionary.Words.CONTENT_URI,   // the user dictionary content URI</span><br><span class="line">    mNewValues                          // the values to insert</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>注意：其中一栏，不要求同一个类型，当然还可以放入<code>null</code>使用<code>ContentValues.putNull()</code>.<br>并且不需要添加<code>_ID</code>值，因为这个栏自动维护的。</p><ul><li>返回的mNewUri内容的格式：<code>content://user_dictionary/words/&lt;id_value&gt;</code>.其中<code>&lt;id_value&gt;</code>是<code>_ID</code>中的新行值。</li><li>从返回的Uri中获得这个值<code>&lt;id_value&gt;</code>，可通过<code>ContentUris.parseId()</code></li></ul><h2 id="5-2update-data"><a href="#5-2update-data" class="headerlink" title="5.2update data"></a>5.2update data</h2><p>更新和插入类似。对selection条件进行约束。下面示例，将<code>en</code>改变成<code>null</code>。返回的的是更新的行号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ContentValue mUpdateValues=new ContentValues();</span><br><span class="line"></span><br><span class="line">String mSelectionClause=UserDictionary.Words.LOCALE +  &quot; LIKE ?&quot;;</span><br><span class="line">String[] mSelectionArgs = &#123;&quot;en_%&quot;&#125;;</span><br><span class="line"></span><br><span class="line">int mRowsUpdated=0;</span><br><span class="line">mUpdateValues.putNull(UserDictionary.Words.LOCALE);</span><br><span class="line">mRowsUpdated = getContentResolver().update(</span><br><span class="line">    UserDictionary.Words.CONTENT_URI,   // the user dictionary content URI</span><br><span class="line">    mUpdateValues                       // the columns to update</span><br><span class="line">    mSelectionClause                    // the column to select on</span><br><span class="line">    mSelectionArgs                      // the value to compare to</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="5-3-delete-data"><a href="#5-3-delete-data" class="headerlink" title="5.3 delete data"></a>5.3 delete data</h2><p>删除和获取类似。具体select的条件。返回被删除的行数。下面举例删除符合”user”的行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String mSelectionClause=UserDictionary.Words.APP_ID + <span class="string">" LIKE ?"</span>;</span><br><span class="line">String[] mSelectionArgs = &#123;<span class="string">"user"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mRowsDeleted = <span class="number">0</span>;</span><br><span class="line">mRowsDeleted = getContentResolver().delete(</span><br><span class="line">    UserDictionary.Words.CONTENT_URI,   <span class="comment">// the user dictionary content URI</span></span><br><span class="line">    mSelectionClause                    <span class="comment">// the column to select on</span></span><br><span class="line">    mSelectionArgs                      <span class="comment">// the value to compare to</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="6-提供的数据类型"><a href="#6-提供的数据类型" class="headerlink" title="6.提供的数据类型"></a>6.提供的数据类型</h1><p>providers可以提供很多数据类型如：</p><ul><li>string</li><li>integer</li><li>long integer(long)</li><li>floating point</li><li>long floating point(dobule)</li></ul><p>另一个数据类型使用BinaryLargeOBject(BLOB)比如一个64kb数据。<br>providers还提供MIME数据类型信息。可以使用MIME类型信息看提供的数据，自己应用能否进行处理。获得URI的MIME类型，使用方法<code>ContentResolver.getType()</code>.</p><h1 id="7-获得provider可选形式"><a href="#7-获得provider可选形式" class="headerlink" title="7.获得provider可选形式"></a>7.获得provider可选形式</h1><p>对应用开发者，有很重要的三种可选形式：</p><ul><li>Batch access:批量访问。通过<code>ContentProviderOperation</code>类获得一个批量访问方法，并且用<code>ContentResolver.applyBatch()</code>来应用。</li><li>异步获取。使用CursorLoader对象。</li><li><a href="https://developer.android.com/guide/topics/providers/content-provider-basics#Intents" target="_blank" rel="noopener">通过intent访问</a>：不能直接发送给intent，但是可以发送给provider的应用。</li></ul><h2 id="7-1批量访问"><a href="#7-1批量访问" class="headerlink" title="7.1批量访问"></a>7.1批量访问</h2><p>批量访问用来插入很多行，或者在不同表中使用同一个方法行插入。</p><p><a href="https://developer.android.com/reference/android/provider/ContactsContract.RawContacts" target="_blank" rel="noopener">ContactsContract.RawContacts</a></p><h2 id="7-2通过一个帮助app显示数据"><a href="#7-2通过一个帮助app显示数据" class="headerlink" title="7.2通过一个帮助app显示数据"></a>7.2通过一个帮助app显示数据</h2><p>如果没有获得权限，仍然想要intent显示另一个app的数据。比如日历应用接收一个<a href="">ACTION_VIEW</a>intent，来显示特定日期和事件。这个允许你显示日期信息，不必自己创建UI。详细见<a href="https://developer.android.com/guide/topics/providers/calendar-provider" target="_blank" rel="noopener">Calendar Provider</a></p><p>你发送intent的应用不必是绑定provider的应用。例如你从一个Contact Provider中获得一个信息，发送一个ACTION_VIEW给一个image viewer，intent中包含contact照片的URI信息。</p><h2 id="7-3通过intents获得数据"><a href="#7-3通过intents获得数据" class="headerlink" title="7.3通过intents获得数据"></a>7.3通过intents获得数据</h2><p>intents能够对contentprovider提供直接权限。</p><ul><li>可以允许用户这个用户即使没有权限也能获得数据。</li><li>或者通过一个result intent从一个有权限应用获得</li><li>获得激活一个有权限的应用让他来为你工作。</li></ul><h2 id="7-4通过临时权限获得"><a href="#7-4通过临时权限获得" class="headerlink" title="7.4通过临时权限获得"></a>7.4通过临时权限获得</h2><p>应用通过添加intent的flag获得临时权限，这个权限直到获取完成返回。添加的标志如下：</p><ul><li>read permission:<code>FLAG_GRANT_READ_URI_PERMISSION</code></li><li>write permission:<code>FLAG_GRANT_WRITE_URI_PERMISSION</code></li></ul><p>注意：这些flags不会给包含在URI中的authority权限，仅仅是URI本身。</p><p>在mainifest中定义URI，在<code>&lt;provider&gt;</code>中使用<code>android:grantUriPermission</code>属性，同时<code>&lt;grant-uri-permission&gt;</code>作为子元素。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ContentProvider&quot;&gt;&lt;a href=&quot;#ContentProvider&quot; class=&quot;headerlink&quot; title=&quot;ContentProvider&quot;&gt;&lt;/a&gt;ContentProvider&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Content Providers将自己的数据安全封装给自己或别的app访问。&lt;/li&gt;
&lt;li&gt;Content providers是一套接口，可连接不同的应用，能够让别的app安全访问和修改你的数据。&lt;/li&gt;
&lt;li&gt;还有一点好处，content provider进行数据抽象，当你修改自己的数据，比如SQL转到其他数据库，其他app不用去修改。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android组件" scheme="http://yoursite.com/tags/Android%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Logger系统 </title>
    <link href="http://yoursite.com/2016/12/26/Logger%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2016/12/26/Logger系统/</id>
    <published>2016-12-26T02:24:55.000Z</published>
    <updated>2019-02-02T11:21:31.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Logger日志系统"><a href="#1-Logger日志系统" class="headerlink" title="1.Logger日志系统"></a>1.Logger日志系统</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>Android提供的Logger日志系统，基内核中的Logger日志驱动程序实现的，将日志记录保存在内核空间中。有效利用内存空间,Logger日志驱动程序内部使用一个<code>环形缓冲区</code> 来保存日志。Logger日志环形缓冲区满了之后，新的日志会覆盖旧的日志。<br>为了避免重要信息被覆盖，日志类型分为四种：<code>main</code>,<code>system</code>,<code>radio</code>和<code>events</code>.对应实现的蠕动为：<code>/dev/log/main</code>,<code>/dev/log/system</code>,<code>/dev/log/radio</code>和<code>/dev/log/events</code>.</p><a id="more"></a><h2 id="1-2-日志作用"><a href="#1-2-日志作用" class="headerlink" title="1.2 日志作用"></a>1.2 日志作用</h2><p>类型具体作用：</p><ul><li>类型为<code>main</code>的日志是应用程序级别</li><li>类型为<code>system</code>日志为系统界别的</li><li>类型为<code>radio</code>日志是与无线设备相关的，量很大，因此单独记录在一起。</li><li>类型为<code>event</code>日志是专门用来诊断系统问题的，应用程序开发不应该使用这种类型日志。</li></ul><h2 id="1-3-日志的类"><a href="#1-3-日志的类" class="headerlink" title="1.3 日志的类"></a>1.3 日志的类</h2><p>Android系统应用框架层中提供了<code>android.util.Log</code>,<code>android.util.Slog</code>和<code>android.util.EventLog</code>三个java接口来往Logger日志驱动程序写入日志，分别对应的类型为main,system,events。其中特别的是使用<code>android.util.Log</code>和<code>android.util.Slog</code>接口写入日志标签值以<code>RIL</code>开头或者等于<code>HTL_RIL</code>，<code>AT</code>，<code>GSM</code>,<code>STK</code>,<code>CDMA</code>,<code>PHONE</code>和<code>SMS</code>时，转换为radio类型吸入到Logger日志中。</p><p>在C/C++层，Android系统运行时也提供了三组宏来写Logger日志驱动程序，<code>SLOGV</code>,<code>SLOGD</code>,<code>SLOGI</code>和<code>SLOGE</code>用来写入sytem类型日志，宏<code>LOG_EVENT_INT</code>,<code>LOG_EVENT_LONG</code>和<code>LOG_EVENT_STRING</code>用来写入events类型日志。</p><p>无论是java日志写入接口还是C/C++日志写入接口，它们重罪通过运行时库层日志的liblog来往Logger日志驱动程序写入到日志中，测外提供一个<code>Logcat</code>工具读取和显示Logger日志驱动程序中得日志。</p><h1 id="2-logger日志格式"><a href="#2-logger日志格式" class="headerlink" title="2. logger日志格式"></a>2. logger日志格式</h1><p>其中<code>main</code>,<code>system</code>和<code>radio</code>三种类型的格式相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority-tag-msg</span><br></pre></td></tr></table></figure><ul><li>priority表示日志优先级，是一个整数.</li><li>tag表示日志标签，一个字符串</li><li>msg表示日志内容，也是也一个字符串</li></ul><p>优先级一般划分为六种：<code>VERBOSE</code>,<code>DEBUG</code>,<code>INFO</code>,<code>WARN</code>,<code>ERROR</code>和<code>FATAL</code></p><p>events类型的日志标签是一个整数值，显示时候不具有可读性，因此，Android系统使用设备的日志标签文件<code>/system/etc/event-log-tags</code>来描述这些标签值的含义。这样Logcat工具在显示events类型日志时，可以把日志中的标签值转换为字符串。格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tag number-tag name-format for tag value</span><br></pre></td></tr></table></figure><ul><li><code>tag number</code>:表示日志标签值，取值范围0~2147483648</li><li><code>tag name</code>:日志标签值对应的字符串描述.字母数字加<code>_</code></li><li><code>format for tag value</code>:日志内容的值格式.</li></ul><p>日志内容值格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[name|data type|data unit]...</span><br></pre></td></tr></table></figure><ul><li>name：日志内容值的名称。</li><li>data type表示内容值数据类型，1~4(分别为：1整数，2长整型，3字符串，4列表)</li><li>data unit:表示日志内容的数据单位，1~6(对象数据numbers of objects,字节数number of bytes,毫秒数number of milliseconds,分配额number of allocation,标志(ID)和百分比Percent)</li></ul><p>从<code>/system/etc/event-log-tags</code>取出一行内容说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2722 battery_level (level|1|6),(voltage|1|1),(temperature|1|1))</span><br></pre></td></tr></table></figure><ul><li>2722表示日志标签值，<code>battery_level</code>用来描述日志标志值2722含义</li><li>日志便签值三个值组成：level,voltage,temperature</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Logger日志系统&quot;&gt;&lt;a href=&quot;#1-Logger日志系统&quot; class=&quot;headerlink&quot; title=&quot;1.Logger日志系统&quot;&gt;&lt;/a&gt;1.Logger日志系统&lt;/h1&gt;&lt;h2 id=&quot;1-1-简介&quot;&gt;&lt;a href=&quot;#1-1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.1 简介&quot;&gt;&lt;/a&gt;1.1 简介&lt;/h2&gt;&lt;p&gt;Android提供的Logger日志系统，基内核中的Logger日志驱动程序实现的，将日志记录保存在内核空间中。有效利用内存空间,Logger日志驱动程序内部使用一个&lt;code&gt;环形缓冲区&lt;/code&gt; 来保存日志。Logger日志环形缓冲区满了之后，新的日志会覆盖旧的日志。&lt;br&gt;为了避免重要信息被覆盖，日志类型分为四种：&lt;code&gt;main&lt;/code&gt;,&lt;code&gt;system&lt;/code&gt;,&lt;code&gt;radio&lt;/code&gt;和&lt;code&gt;events&lt;/code&gt;.对应实现的蠕动为：&lt;code&gt;/dev/log/main&lt;/code&gt;,&lt;code&gt;/dev/log/system&lt;/code&gt;,&lt;code&gt;/dev/log/radio&lt;/code&gt;和&lt;code&gt;/dev/log/events&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android调试" scheme="http://yoursite.com/tags/Android%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>EventLog</title>
    <link href="http://yoursite.com/2016/12/22/EventLog/"/>
    <id>http://yoursite.com/2016/12/22/EventLog/</id>
    <published>2016-12-21T22:18:35.000Z</published>
    <updated>2019-02-02T11:21:31.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Eventlog可以展示当前Activity各种状态，还可以显示window信息。<br>tags格式定义位于文件<code>/system/etc/event-log-tags</code>.<br>终端输入：<code>logcat -b events</code></p><a id="more"></a><p>那么会输出大量类似这样的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">06-01 13:44:55.518  7361  8289 I am_create_service: [0,111484394,.StatService,10094,7769]</span><br><span class="line">06-01 13:44:55.540  7361  8343 I am_proc_bound: [0,3976,com.android.providers.calendar]</span><br><span class="line">06-01 13:44:55.599  7361  8033 I am_create_service: [0,61349752,.UpdateService,10034,1351]</span><br><span class="line">06-01 13:44:55.625  7361  7774 I am_destroy_service: [0,61349752,1351]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过字面意思，就能得到不少信息量，比如<code>am_create_service</code>，创建service，但是后面括号中内容的具体含义，其实有很高的价值。 接下来通过一张表格来展示含义</p><h1 id="EventLog"><a href="#EventLog" class="headerlink" title="EventLog"></a>EventLog</h1><h2 id="ActivityManager"><a href="#ActivityManager" class="headerlink" title="ActivityManager"></a>ActivityManager</h2><table><thead><tr><th>num</th><th>TagName</th><th>格式</th><th>功能</th></tr></thead><tbody><tr><td>30001</td><td>am_finish_activity</td><td>User,Token,TaskID,ComponentName,Reason</td></tr></tbody></table><p>下面列举tag可能使用的部分场景：</p><ul><li><code>am_low_memory</code>：位于AMS.killAllBackgroundProcesses或者AMS.appDiedLocked，记录当前Lru进程队列长度。</li></ul><p>Activity生命周期相关的方法:</p><ul><li><code>am_on_resume_called</code>:位于AT.performResumeActivity</li></ul><p>Window相关</p><p>[参考][1]<br>[1]: <a href="http://gityuan.com/2016/05/15/event-log/" target="_blank" rel="noopener">http://gityuan.com/2016/05/15/event-log/</a> “Android EventLog含义”</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Eventlog可以展示当前Activity各种状态，还可以显示window信息。&lt;br&gt;tags格式定义位于文件&lt;code&gt;/system/etc/event-log-tags&lt;/code&gt;.&lt;br&gt;终端输入：&lt;code&gt;logcat -b events&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android调试" scheme="http://yoursite.com/tags/Android%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>dropbox</title>
    <link href="http://yoursite.com/2016/10/27/dropbox/"/>
    <id>http://yoursite.com/2016/10/27/dropbox/</id>
    <published>2016-10-26T18:34:49.000Z</published>
    <updated>2019-02-02T11:21:31.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-DropBoxManager"><a href="#1-DropBoxManager" class="headerlink" title="1.DropBoxManager"></a>1.DropBoxManager</h1><p>dropboxmanagerSerivce(DBMS)，记录系统关键log信息，主要用于Debug调试。收集的信息都存放在<code>/data/system/dropbox</code>目录下。</p><p>当出现crash,anr,wtf,lowmem，以及开机完成时会通过DropBoxManager，收集系统重要的信息。根据不同场景输出相应的信息：</p><ul><li>CRASH：输出发生crash时的当前线程的调用栈信息</li><li>ANR：输出Cpuinfo,以及重要进程的各个线程的traces文件(kill -3);</li><li>watchdog:也输出重要进程的各个线程traces文件(kill -3)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-DropBoxManager&quot;&gt;&lt;a href=&quot;#1-DropBoxManager&quot; class=&quot;headerlink&quot; title=&quot;1.DropBoxManager&quot;&gt;&lt;/a&gt;1.DropBoxManager&lt;/h1&gt;&lt;p&gt;dropboxmanager
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android调试" scheme="http://yoursite.com/tags/Android%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>bugreport</title>
    <link href="http://yoursite.com/2016/10/25/bugreport/"/>
    <id>http://yoursite.com/2016/10/25/bugreport/</id>
    <published>2016-10-25T15:43:26.000Z</published>
    <updated>2019-02-02T11:21:31.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>bugreport中路径为<code>framework/native/cmds</code>,生成可执行文件<code>/system/bin/bugreport</code>.bugreport信息量非常大，几乎涵盖系统各个层面内容。</p><ul><li>通过启动<code>property_set(&quot;ctl.start&quot;,&quot;dumpstate&quot;);</code>启动dumpstate服务(由init进程fork出来).</li><li>bugreport进程通过socket套接字与dumpstate进行通讯</li><li>bugreport作为客户端读取<code>length=read(s,buffer,sizeofo(buffer))</code>,并将读到的内容进行输出。<code>fwrite(buffer,1,length,stdout)</code><a id="more"></a></li></ul><h1 id="2-dumpstate"><a href="#2-dumpstate" class="headerlink" title="2.dumpstate"></a>2.<code>dumpstate</code></h1><h2 id="2-1-处理SIGPIPE信号"><a href="#2-1-处理SIGPIPE信号" class="headerlink" title="2.1 处理SIGPIPE信号"></a>2.1 处理SIGPIPE信号</h2><p>dumpstate为socket服务端，如果一个客服端关闭调用两次write，第二次会产生SIGPIPE信号，该信号默认结束进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;sigact,<span class="number">0</span>,<span class="keyword">sizeof</span>(sigact));</span><br><span class="line"><span class="comment">//句柄来处理，SIG_IGNORE则丢弃不处理该信号</span></span><br><span class="line">sigact.sa_hanlder=sigpipe_handler;</span><br><span class="line">sigaction(SIGPIPE,&amp;sigact,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h2 id="2-2-设置进程优先级"><a href="#2-2-设置进程优先级" class="headerlink" title="2.2 设置进程优先级"></a>2.2 设置进程优先级</h2><p>将dumpstate设置成高优先级，避免被OOM杀掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.linux设置优先级</span></span><br><span class="line">setpriority(PRIO_PROCESS,<span class="number">0</span>,<span class="number">-20</span>);</span><br><span class="line"><span class="comment">//2.self表示当前进程(链接),android oom概念</span></span><br><span class="line">FILE *oom_adj=fopen(<span class="string">"/proc/self/oom_adj"</span>,<span class="string">"w"</span>);</span><br><span class="line"><span class="keyword">if</span>(oom_adj)&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"-17"</span>,oom_adj);</span><br><span class="line">    fclose(oom_adj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>setpriority(int which,int who,int pri)</code>,表示设置程序调度优先级.可用<code>getpriority</code>获取：</p><ul><li>which:取值可能为<code>PRIO_PROCESS</code>,<code>PRIO_PGRP</code>,<code>PRIO_USER</code>。</li><li>who:是和which取值相对应相关。<code>PRIO_PROCESS</code>时候表示取进程id,<code>PRIO_PGRP</code>时候取进程组id,<code>PRIO_USER</code>时候取用户id。取0的时候表示调用的当前进程.</li><li>pri:范围是<code>-20~19</code>,默认为0.越小，优先级越高.</li></ul><h2 id="2-3-收集Dalvik和native进程栈信息"><a href="#2-3-收集Dalvik和native进程栈信息" class="headerlink" title="2.3 收集Dalvik和native进程栈信息"></a>2.3 收集Dalvik和native进程栈信息</h2><p><code>dump_traces()</code>函数来实现收集过程，<code>/data/anr/traces.txt</code>文件是由属性<code>dalvik.vm.stack-trace-file</code>指定。</p><ul><li>如果存在<code>/data/anr/traces.txt</code>文件，通过rename改成<code>/data/anr/traces.txt.anr</code>文件</li><li>新建新的一个空的<code>traces.txt</code>文件来收集栈的dump信息。</li></ul><p>遍历<code>/proc</code>目录，然后<code>kill -QUIT</code>(-3,相当于ctrl+d)所有Dalik进程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">DIR *proc=opendir(<span class="string">"/proc"</span>);</span><br><span class="line"><span class="comment">//当进程完成dump，发出通知</span></span><br><span class="line"><span class="keyword">int</span> ifd=inotify_init();</span><br><span class="line"><span class="comment">//指定pathname,mask关心的通知事件，通知写入发出通知</span></span><br><span class="line"><span class="keyword">int</span> wfd=inotify_add_watch(ifd,traces_path,IN_CLOSE_WRITE);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">d</span>;</span></span><br><span class="line"><span class="keyword">int</span> dalvik_found=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//读一个目录</span></span><br><span class="line"><span class="keyword">while</span>((d=readdir(proc)))&#123;</span><br><span class="line">    <span class="comment">// proc子目录是进程(号)</span></span><br><span class="line">    <span class="keyword">int</span> pid=atoi(d-&gt;d_name);</span><br><span class="line">    <span class="comment">//proc/%d/exe 执行程序名称</span></span><br><span class="line">    <span class="comment">//1. linux:ps -p 2345 -o comm</span></span><br><span class="line">    <span class="comment">//2. android:busybox ps</span></span><br><span class="line">    snprint(path,<span class="keyword">sizeof</span>(path),<span class="string">"/proc/%d/exe"</span>,pid);</span><br><span class="line">    <span class="keyword">ssize_t</span> len=readlink(path,data,<span class="keyword">sizeof</span>(data)<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(data,<span class="string">"/system/bin/app_process"</span>))&#123;</span><br><span class="line">        <span class="comment">//执行的命令行参数</span></span><br><span class="line">        <span class="built_in">snprintf</span>(path,<span class="keyword">sizeof</span>(pat),<span class="string">"proc/%d/cmdline"</span>,pid)</span><br><span class="line">        <span class="keyword">int</span> fd=open(path,O_READONLY);</span><br><span class="line">        len=read(fd,date,sizeoof(data)<span class="number">-1</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="comment">//跳过zygote进程</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(data,<span class="string">"zygote"</span>))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明dalvik进程来自app_process</span></span><br><span class="line">        ++dalvik_found;</span><br><span class="line">        <span class="keyword">if</span>(kill(pid,SIGQUIT))&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"kill(%d,SIGQUIT):%s\n"</span>,pid,strerror(errno));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待写完成通知</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfd</span>=&#123;</span>ifd,POLLIN,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//利用inotify来添加200ms超时判断.</span></span><br><span class="line">        <span class="keyword">int</span> ret=poll(&amp;pfd,<span class="number">1</span>,<span class="number">200</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"warining:time out dumping pid%d\n"</span>,pid);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            struct inotify_event id;</span><br><span class="line">            read(ifd,&amp;ie,<span class="keyword">sizeof</span>(ie));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(should_dump_native_traces(data))&#123;</span><br><span class="line">        <span class="comment">//dump native process if appropriate</span></span><br><span class="line">        <span class="keyword">if</span>(lseek(fd,<span class="number">0</span>,SEEK_END)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"lseek:%s\n"</span>,strerror(errno));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dump_backtrace_to_file(pid,fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//完成返回文件名为 traces.txt.bugreport</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-4回到非root用户和组"><a href="#2-4回到非root用户和组" class="headerlink" title="2.4回到非root用户和组"></a>2.4回到非root用户和组</h2><p>dumpstate由init启动，具有root权限<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">gid_t</span> groups[] =&#123;AID_LOG,AID_SDCARD,AID_SDCARD_RW,AID_MOUNT,AID_INET,AID_NET_BW_STATS&#125;;</span><br><span class="line">setgroups(<span class="keyword">sizeof</span>(groups)/<span class="keyword">sizeof</span>(groups[<span class="number">0</span>],groups)!=<span class="number">0</span>);</span><br><span class="line">setgid(AID_SHELL);</span><br><span class="line">setuid(AID_SHELL)</span><br></pre></td></tr></table></figure></p><h2 id="2-5-dumpstate-正真执行"><a href="#2-5-dumpstate-正真执行" class="headerlink" title="2.5 dumpstate()正真执行"></a>2.5 dumpstate()正真执行</h2><p>下面单独分析</p><h2 id="2-6-通知bugreport操作"><a href="#2-6-通知bugreport操作" class="headerlink" title="2.6 通知bugreport操作"></a>2.6 通知bugreport操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(do_broadcast &amp;&amp; use_outfile &amp;&amp; do_fb)&#123;</span><br><span class="line">    <span class="comment">//run_command(title,timeout,char*command,...);</span></span><br><span class="line">    run_command(<span class="literal">NULL</span>,<span class="number">5</span>,<span class="string">"/system/bin/am"</span>,<span class="string">"broadcast"</span>,<span class="string">"--user"</span>,<span class="string">"0"</span></span><br><span class="line">    <span class="string">"-a"</span>,<span class="string">"android.intent.action.BUGREPORT_FINISHED"</span>,</span><br><span class="line">    <span class="string">"--es"</span>,<span class="string">"android.intent.extra.BUGREPORT"</span>,path,</span><br><span class="line">    <span class="string">"--es"</span>,<span class="string">"android.intent.extra.SCREENSHOT"</span>,screenshot_path,</span><br><span class="line">    <span class="string">"--receiver-permission"</span>,<span class="string">"android.permission.DUMP"</span>,<span class="literal">NULL</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>utils.c文件中<code>run_command()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_command</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*title,<span class="keyword">int</span> timeout_seconds,<span class="keyword">const</span> <span class="keyword">char</span>*command)</span></span>&#123;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">clock_t</span> start=clock();</span><br><span class="line">    <span class="keyword">pid_t</span> pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork:%s\n"</span>,strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> pid;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;<span class="comment">//子进程</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *args[<span class="number">1024</span>]=&#123;command&#125;;</span><br><span class="line">        <span class="keyword">size_t</span> arg;</span><br><span class="line">        <span class="comment">//父进程死了，自己成发送SIGKILL</span></span><br><span class="line">        prctl(PR_SET_PDEATHSIG,SIGKILL);</span><br><span class="line">        va_list ap;</span><br><span class="line">        va_start(ap,command);</span><br><span class="line">        <span class="keyword">if</span>(title)<span class="built_in">printf</span>(<span class="string">"----- %s (%s"</span>,title,command);</span><br><span class="line">        <span class="keyword">for</span>(arg=<span class="number">1</span>;arg&lt;<span class="keyword">sizeof</span>(args)/<span class="keyword">sizeof</span>(args[<span class="number">0</span>]);++args)&#123;</span><br><span class="line">            args[arg]=va_arg(ap,<span class="keyword">const</span> <span class="keyword">char</span>*);</span><br><span class="line">            <span class="keyword">if</span>(args[arg]==<span class="literal">NULL</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(title)<span class="built_in">printf</span>(<span class="string">" %s"</span>,args[arg]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(title)<span class="built_in">printf</span>(<span class="string">") -----\n"</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        execvp(command,(<span class="keyword">char</span>**)args);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"***exec(%s):%s\n"</span>,command,strerror(errno));</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        _exit(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主进程处理</span></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        <span class="keyword">pid_t</span> p=waitpid(pid,&amp;status,WNOHANG);</span><br><span class="line">        <span class="keyword">float</span> elapsed=(<span class="keyword">float</span>)(clock()-start)/CLOCKS_PER_SEC;</span><br><span class="line">        <span class="comment">//fork()返回子进程pid</span></span><br><span class="line">        <span class="keyword">if</span>(p==pid)&#123;</span><br><span class="line">        <span class="comment">//判断子进程返回的状态</span></span><br><span class="line">           <span class="keyword">if</span>(WIFSIGNALED(status))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"*** %s Killed by signal %d\n"</span>,command,WIERMSIG(status));</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(WIFEXITED(status)&amp;&amp; WEXISTATUS(status)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"** %s Exit code %d\n"</span>,command,WEXISTATUS(status));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(title) <span class="built_in">printf</span>(<span class="string">"%s %.1fs elasped\n"</span>,command,elapsed);</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(timeout_seconds &amp;&amp; elapsed &gt; timeout_seconds)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"**** %sTimeout after %.1fs (killing pid %d)\n"</span>,command,elapsed,pid);</span><br><span class="line">            kill(pid,SIGTERM);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        usleep(<span class="number">100000</span>);<span class="comment">//pll every 0.1 sec</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-dumpstate分析"><a href="#3-dumpstate分析" class="headerlink" title="3.dumpstate分析"></a>3.dumpstate分析</h1><p>主要通过<code>run_command</code>,<code>dump_file</code>,<code>do_dmesg</code>,<code>print_properties</code>,<code>for_each_pid</code>，完成各种信息的dump.</p><h2 id="3-1-dump-file"><a href="#3-1-dump-file" class="headerlink" title="3.1 dump_file"></a>3.1 <code>dump_file</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dump_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* tile,<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd=open(path,O_RDONLY);</span><br><span class="line">    <span class="keyword">int</span> newline=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">int</span> ret=read(fd,buffer,<span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        ret=fwrite(buffer,ret,<span class="number">1</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(reg&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><h2 id="3-2-do-dmesg"><a href="#3-2-do-dmesg" class="headerlink" title="3.2 do_dmesg"></a>3.2 <code>do_dmesg</code></h2><p>打印KERNEL信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_dmesg</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"----------KERNEL LOG(dmesg)------\n"</span>);</span><br><span class="line">    <span class="comment">//get size of kernel buffer</span></span><br><span class="line">    <span class="keyword">int</span> size=klogctl(KLOG_SIZE_BUFFER,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> * buf=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(size+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> retval=klogctl(KLOG_READ_ALL,buf,size);</span><br><span class="line">    buf[retval]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n\n"</span>,buf);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-print-properties"><a href="#3-3-print-properties" class="headerlink" title="3.3 print_properties()"></a>3.3 <code>print_properties()</code></h2><p>打印所有的系统属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> num_props=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>*props[<span class="number">2000</span>];</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_prop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*key,<span class="keyword">const</span> <span class="keyword">char</span>*name,<span class="keyword">void</span>*user)</span></span>&#123;</span><br><span class="line">    <span class="comment">//未使用该变量，避免编译器出现 unused but defined warning.</span></span><br><span class="line">    (<span class="keyword">void</span>) user;</span><br><span class="line">    <span class="comment">//属性数目小于2000</span></span><br><span class="line">    <span class="keyword">if</span>(num_props&lt;<span class="keyword">sizeof</span>(props)/<span class="keyword">sizeof</span>(props[<span class="number">0</span>]))&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[PROPERTY_KEY_MAX+PROPERTY_VALUE_MAX+<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(buf,<span class="keyword">sizeof</span>(buf),<span class="string">"[%s] : [%s]\n"</span>,key,name);</span><br><span class="line">        props[num_props++]=strdup(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare_prop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*a,<span class="keyword">const</span> <span class="keyword">void</span>*b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(*(<span class="keyword">char</span>* <span class="keyword">const</span>*)a,*(<span class="keyword">char</span>*<span class="keyword">const</span>*)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_properties</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    num_props=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历所有的属性，并回调回来</span></span><br><span class="line">    property_list(print_prop,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//排序数组</span></span><br><span class="line">    qsort(&amp;prop,num_props,<span class="keyword">sizeof</span>(props[<span class="number">0</span>]),compare_prop);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"----------------SYSTEM PROPERTIES ---------\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num_props;++i)&#123;</span><br><span class="line">        <span class="built_in">fputs</span>(props[i],<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">free</span>(props[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中属性通过内存映射将<code>/dev/__properties__</code>到一个全局变量<code>__system_property_area__</code>.利用二叉树，管理属性。</p><h2 id="3-4-for-each-pid-和-for-each-tid"><a href="#3-4-for-each-pid-和-for-each-tid" class="headerlink" title="3.4 for_each_pid 和 for_each_tid"></a>3.4 <code>for_each_pid</code> 和 <code>for_each_tid</code></h2><p>调用<code>for_each_pid(do_showmap,&quot;SMAPS OF ALL PROCESS&quot;)</code>和<code>for_each_tid(show_wchan,&quot;BLOCKED PROCESS WAIT-CHANNELS&quot;)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">for_each_pid</span><span class="params">(for_each_pid_func func,<span class="keyword">const</span> <span class="keyword">char</span>*header)</span></span>&#123;</span><br><span class="line">    __for_each_pid(for_each_pid_helper,header,func); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">for_each_pid_helper</span><span class="params">(<span class="keyword">int</span> pid,<span class="keyword">const</span> <span class="keyword">char</span>*cmline,<span class="keyword">void</span>*arg)</span></span>&#123;</span><br><span class="line">    for_each_pid_func *func=arg;</span><br><span class="line">    func(pid,cmdline);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> __for_each_pid(<span class="keyword">void</span>(*helper)(<span class="keyword">int</span>,<span class="keyword">const</span> <span class="keyword">char</span>*,<span class="keyword">void</span>*),<span class="keyword">const</span> <span class="keyword">char</span>*header,<span class="keyword">void</span> *arg)&#123;</span><br><span class="line">    DIR*d;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">de</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(!(d=opendir(<span class="string">"/proc"</span>)));</span><br><span class="line">    <span class="keyword">while</span>((de=readdir(d)))&#123;</span><br><span class="line">        <span class="keyword">int</span> pid,fd;</span><br><span class="line">        <span class="keyword">char</span> cmdpath[<span class="number">256</span>],cmdline[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">if</span>(!(pid=atoi(de-&gt;[d_name])))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sprintf</span>(cmdpath,<span class="string">"/proc/%d/cmdline"</span>,pid);</span><br><span class="line">        <span class="built_in">memset</span>(cmdline,<span class="number">0</span>,<span class="keyword">sizeof</span>(cmdline));</span><br><span class="line">        <span class="keyword">if</span>((fd=open(cmdpath,O_RDONLY))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(cmdline,<span class="string">"N/A"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            read(fd,cmdline,<span class="keyword">sizeof</span>(cmdline),<span class="number">-1</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">        &#125;</span><br><span class="line">        helper(pid,cmdline,arg);</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for_each_tid类似。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><p>bugreport通过socket与dumpstate服务建立通信。dumpstate()主要5大类:</p><ul><li>current log:<code>kernel,system,event,radio</code></li><li>last log:<code>kernel ,system,radio</code></li><li>vm traces:<code>just now,last ANR,tombstones</code></li><li>dumpsys:<code>all checkin,app</code></li><li>system info:<code>cpu,memory,io</code></li></ul><p>从bugreport内容输出顺序角度，详细内容:</p><ul><li>系统build以及运行时长等信息。<code>/proc/version</code>,运行时间<code>uptime</code></li><li>内存/CPU进程等信息。<code>/proc/meminfo</code>,CPU信息：<code>top -n 1 -d 1 -m 30 -t</code>,<code>/proc/vmstat</code>,进程<code>ps -P</code>,线程<code>ps -t -p -P</code></li><li><code>kernel log</code></li><li><code>lsof</code>,<code>map</code>,<code>wait-channels</code>,LIST OF OPEN FILE(<code>/system/xbin/su lsof</code>)</li><li><code>system log</code>,<code>logcat -v threadtime -d *:v</code></li><li><code>event log</code>,<code>logcat -b events -v threadtime -d *:v</code></li><li><code>radio log</code>:<code>logcat -b radio -v threadtime -d *:v</code></li><li><code>vm traces</code><ul><li>VM TRACES JUST NOW(<code>/data/anr/traces.txt.bugreport</code>)(抓bugreport时出发)</li><li>VM TRACES AT LAST ANR(<code>/data/anr/traces.txt</code>)(存在就输出)</li><li>TOMBSTONE(/data/tombstones/tombstone_xx)(存在就输出)</li></ul></li><li>network相关信息:NETWORK DEV INFO<code>/proc/net/dev</code>,NETWORK ROUTES<code>/proc/net/route</code></li><li><code>last kernel log</code>,<code>proc/last_kmsg</code></li><li><code>last panic console</code>,<code>/data/dontpanic/apanic_console</code></li><li><code>last panic threads</code>,<code>/data/notpanic/apanic_threads</code></li><li>SYSTEM SETTINGS:<code>sqlite3 /data/data/com.android.providers.settings/databases/settings.db pragma user_version; select * from system; select * from secure; select * from global;</code></li><li><code>last system log</code></li><li><code>ip相关信息</code></li><li><code>中断向量表</code></li><li><code>property</code>以及fs等信息</li><li><code>last radio log</code></li><li>Binder相关信息</li><li>dumpsys all;</li><li>dumpsys checkin相关：<ul><li>dumpsys batterystats电池统计</li><li>dumpsys meminfo内存</li><li>dumpsys netstats 网络统计</li><li>dumpsys procstats 进程统计</li><li>dumpsys usagestats使用统计</li><li>dumpsys package</li></ul></li><li>dumpsys app相关<ul><li>dumpsys activity</li><li>dumpsys acitivty service all</li><li>dumpsys activity provider all</li></ul></li></ul><h2 id="4-1-ChkBugReport"><a href="#4-1-ChkBugReport" class="headerlink" title="4.1 ChkBugReport"></a>4.1 ChkBugReport</h2><p>1.通过命令生成bugreport文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bugreport &gt; bugreport.txt</span><br></pre></td></tr></table></figure><p>2.执行chkbugreport，命令中jar和txt都必须填写相应文件的完全路径</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java -jar chkbugreport.jar bugreport.txt</span><br></pre></td></tr></table></figure><p>当然可以吧<code>.jar</code>添加path，则直接使用<code>chkbugreport bugreport.txt</code></p><p>3.通过浏览器打开<code>/bugreport_out/index.html</code>，可视化信息出现</p><p><strong>参考</strong>：</p><p><a href="http://gityuan.com/2016/06/10/bugreport/" target="_blank" rel="noopener">bugreport源码篇</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h1&gt;&lt;p&gt;bugreport中路径为&lt;code&gt;framework/native/cmds&lt;/code&gt;,生成可执行文件&lt;code&gt;/system/bin/bugreport&lt;/code&gt;.bugreport信息量非常大，几乎涵盖系统各个层面内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过启动&lt;code&gt;property_set(&amp;quot;ctl.start&amp;quot;,&amp;quot;dumpstate&amp;quot;);&lt;/code&gt;启动dumpstate服务(由init进程fork出来).&lt;/li&gt;
&lt;li&gt;bugreport进程通过socket套接字与dumpstate进行通讯&lt;/li&gt;
&lt;li&gt;bugreport作为客户端读取&lt;code&gt;length=read(s,buffer,sizeofo(buffer))&lt;/code&gt;,并将读到的内容进行输出。&lt;code&gt;fwrite(buffer,1,length,stdout)&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android调试" scheme="http://yoursite.com/tags/Android%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>dumpsys</title>
    <link href="http://yoursite.com/2016/10/23/dumpsys/"/>
    <id>http://yoursite.com/2016/10/23/dumpsys/</id>
    <published>2016-10-23T01:53:57.000Z</published>
    <updated>2019-02-02T11:21:31.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Dumpsys-源码"><a href="#1-Dumpsys-源码" class="headerlink" title="1.Dumpsys 源码"></a>1.Dumpsys 源码</h1><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//framework/native/cmds/dumpsys/dumpsys.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span>&#123;</span><br><span class="line">    signal(SIGPIPE,SIG_IGN);</span><br><span class="line">    <span class="comment">//获取ServiceManager</span></span><br><span class="line">    sp&lt;IServiceManager&gt; sm=defaultSerivceManager();</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span>(sm==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Vector&lt;String16&gt; services;</span><br><span class="line">    Vector&lt;String16&gt; args;</span><br><span class="line">    <span class="keyword">bool</span> showListOnly=<span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//命令 dumpsys -l </span></span><br><span class="line">    <span class="keyword">if</span>((argc==<span class="number">2</span>)&amp;&amp;(<span class="built_in">strcmp</span>(argv[<span class="number">1</span>],<span class="string">"-l"</span>)==<span class="number">0</span>))&#123;</span><br><span class="line">        showListOnly=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((argc==<span class="number">1</span>)||showListOnly)&#123;</span><br><span class="line">        <span class="comment">//不带参数命令 dumpsys</span></span><br><span class="line">        services=sm-&gt;ListServices();</span><br><span class="line">        services=sort(sort_func);</span><br><span class="line">        args.add(String16(<span class="string">"-a"</span>))</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//带参数则只能指定服务器的信息</span></span><br><span class="line">        services.add(String16(argv[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;argc;i++)&#123;</span><br><span class="line">            args.add(String16(argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> N =service.size();</span><br><span class="line">    <span class="keyword">if</span>(N&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//打印出第一行信息</span></span><br><span class="line">        aout&lt;&lt;<span class="string">"Currently running services:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i =<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="comment">//获取相应服务</span></span><br><span class="line">            sp&lt;IBinder&gt; service=sm-&gt;checkSerivce(services[i]);</span><br><span class="line">            <span class="keyword">if</span>(service !=<span class="literal">NULL</span>)&#123;</span><br><span class="line">              aout&lt;&lt;<span class="string">""</span>&lt;&lt;service[i]&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(showListOnly)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i =<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        sp&lt;IBinder&gt; service=sm-&gt;checkService(service[i]);</span><br><span class="line">        <span class="keyword">if</span>(service !=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(N&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                aout&lt;&lt;<span class="string">"------------------------------------------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                aout&lt;&lt;<span class="string">"Dump OF SERVICE "</span>&lt;&lt;services[i]&lt;&lt;<span class="string">" : "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用service相应的dump方法，这个是整个dumpsys命令精华</span></span><br><span class="line">            <span class="keyword">int</span> err=service-&gt;dump(STDOUT_FIFLENO,args);</span><br><span class="line">            <span class="keyword">if</span>(err!=<span class="number">0</span>)&#123;</span><br><span class="line">                aerr&lt;&lt;<span class="string">"Error dumping service info:"</span>&lt;&lt;strerror(erro)&lt;&lt;<span class="string">" )"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            aerr&lt;&lt;<span class="string">"Can't find service: "</span>&lt;&lt;services[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dumpsys主要工作分为4个步骤：</p><ul><li><code>defaultSericeManager()</code>获取ServiceManager对象</li><li><code>sm-&gt;listServices()</code>获取系统所有向ServiceManager注册过的服务</li><li><code>sm-&gt;checkSerivce()</code>获取系统中年指定的Service</li><li><code>service-&gt;dump()</code>调用远程服务中<code>dump()</code>方法来获取相应的dump信息</li></ul><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h1><h2 id="2-1-dumpsys命令用法"><a href="#2-1-dumpsys命令用法" class="headerlink" title="2.1 dumpsys命令用法"></a>2.1 dumpsys命令用法</h2><p>通过dumpsys命令查询系统服务运行状态：<code>dumpsys 服务名</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dumpsys activity //查询AMS服务相关信息</span><br><span class="line">dumpsys window  //查询WMS服务相关信息</span><br><span class="line">dumpsys cpuinfo //查询CPU情况</span><br><span class="line">dumpsys meminfo //查询内存信息</span><br></pre></td></tr></table></figure><p>可查询服务很多，查看当前支持的dump服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys -l</span><br><span class="line">adb shell service list</span><br></pre></td></tr></table></figure><h2 id="2-2-系统服务"><a href="#2-2-系统服务" class="headerlink" title="2.2 系统服务"></a>2.2 系统服务</h2><p>重要服务</p><table><thead><tr><th>服务名</th><th>类名</th><th>功能</th></tr></thead><tbody><tr><td>activity</td><td>ActivityManagerService</td><td>AMS相关信息</td></tr><tr><td>package</td><td>PackageManagerService</td><td>PMS相关信息</td></tr><tr><td>window</td><td>WindowManagerService</td><td>WMS相关信息</td></tr><tr><td>input</td><td>InputManagerService</td><td>IMS相关信息</td></tr><tr><td>power</td><td>PowerManagerService</td><td>PMS相关信息</td></tr><tr><td>batterstats</td><td>BatterystatsService</td><td>电池统计消息</td></tr><tr><td>battery</td><td>BatteryService</td><td>电池信息</td></tr><tr><td>alarm</td><td>AlarmManagerService</td><td>闹钟信息</td></tr><tr><td>dropbox</td><td>DropboxManagerService</td><td>调试相关</td></tr><tr><td>prostats</td><td>ProcessStatsService</td><td>进程统计</td></tr><tr><td>cpuinfo</td><td>CpuBinder</td><td>CPU</td></tr><tr><td>meminfo</td><td>MemBinder</td><td>内存</td></tr><tr><td>gxinfo</td><td>GraphicsBinder</td><td>图像</td></tr><tr><td>dbinfo</td><td>DbBinder</td><td>数据库</td></tr></tbody></table><p>其他服务</p><table><thead><tr><th>服务名</th><th>功能</th></tr></thead><tbody><tr><td>SurfaceFlinger</td><td>图像相关</td></tr><tr><td>appops</td><td>app使用情况</td></tr><tr><td>permission</td><td>权限</td></tr><tr><td>processinfo</td><td>进程服务</td></tr><tr><td>batteryproperties</td><td>电池相关</td></tr><tr><td>audio</td><td>查看声音相关</td></tr><tr><td>netstats</td><td>查看网络统计信息</td></tr><tr><td>diskstats</td><td>查看空间free状态</td></tr><tr><td>jobscheduler</td><td>查看任务计划</td></tr></tbody></table><h2 id="2-3-Actitivty场景"><a href="#2-3-Actitivty场景" class="headerlink" title="2.3 Actitivty场景"></a>2.3 Actitivty场景</h2><p><strong>场景1</strong>： 查看某个APP所有Service状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpsys acitivty s com.sina.weibo</span><br></pre></td></tr></table></figure><ul><li>Service类型为<code>com.morgoo.droidplugin.PluginManagerService</code></li><li>运行在进程pid=7720，进程名为<code>com.sina.weibo</code>,uid=10094</li><li>通过bindeService连接该服务的进程Pid=7306，进程名为<code>com.sina.weibo:PluginP03</code></li></ul><p>当然还有<code>packageName</code>，<code>baseDir(apk路径)</code>，<code>dataDir(apk数据路径)</code>，<code>createTime</code>等各种信息。另外，新浪微博采用的是360开源的Android插件机制(<code>com.morgoo.droidplugin</code>)，主要用于hotfix等功能。</p><p><strong>场景2</strong>：查询某个APP所有的广播状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpsys activity b com.sina.weibo</span><br></pre></td></tr></table></figure><ul><li><code>android.intent.action.SCREEN_ON</code>代表手机亮屏广播；</li><li>接收该广播的receiver有很多个，其中一个所在进程为pid=7220，进程名为<code>com.sina.weibo</code></li></ul><p><strong>场景3</strong>:查询某个App所有的Activity状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpsys acitivty a com.sina.weibo</span><br></pre></td></tr></table></figure><ul><li>格式：<code>TaskRecord{Hashcode #TaskId Affinity UserId=0 Activity个数=1}</code>；所以上图信息解析后就是TaskId=1802，Affinity=com.sina.weibo，当前Task中Activity个数为1。</li><li><code>effectiveUid</code>为当前task所属Uid，mCallingUid为调用者Uid=u0a94，mCallingPackage为调用者包名，这里是com.sina.weibo；</li><li><code>realActivity</code>:task中的已启动的Activity组件名com.sina.weibo/.SplashActivity</li></ul><p><strong>场景4</strong>：查询某个App的进程状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpsys activity p com.sina.weibo</span><br></pre></td></tr></table></figure><ul><li>格式：<code>ProcessRecord{Hashcode pid:进程名/uid}</code>，进程pid=7306，进程名为com.sina.weibo:PluginP03，uid=10094.</li><li>该进程中还有Services，Connections, Providers, Receivers，可以看出该进程是没有Activity的进程。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dumpsys activity top</span><br><span class="line">dumpsys acitivity oom //查看进程状态</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Dumpsys-源码&quot;&gt;&lt;a href=&quot;#1-Dumpsys-源码&quot; class=&quot;headerlink&quot; title=&quot;1.Dumpsys 源码&quot;&gt;&lt;/a&gt;1.Dumpsys 源码&lt;/h1&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android调试" scheme="http://yoursite.com/tags/Android%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>init进程</title>
    <link href="http://yoursite.com/2016/09/30/init%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/09/30/init进程/</id>
    <published>2016-09-29T20:10:38.000Z</published>
    <updated>2019-02-02T11:21:31.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p><code>init进程</code>是Linux系统用户空间第一个进程，进程号为1.改进程功能分为4部分：</p><ul><li>1.分析和运行所有<code>init.rc</code>文件.</li><li>2.生成设备驱动节点（通过rc文件创建）</li><li>3.处理子进程的终止(signal方式)</li><li>4.提供属性服务</li></ul><a id="more"></a><h2 id="1-1-main"><a href="#1-1-main" class="headerlink" title="1.1 main"></a>1.1 main</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//init.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>**argv)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">umask(<span class="number">0</span>);<span class="comment">//设置文件属性0777</span></span><br><span class="line">klog_init();<span class="comment">//初始化kernel log,位于设备节点/dev/kmsg</span></span><br><span class="line">klog_set_level(KLOG_NOTICE_LEVEL);<span class="comment">//设置输出log级别</span></span><br><span class="line"><span class="comment">//输出init启动阶段的Log</span></span><br><span class="line">NOTICE(<span class="string">"init%s started\n"</span>,is_first_stage?<span class="string">""</span> : <span class="string">"second stage"</span>);</span><br><span class="line">property_init();<span class="comment">//创建一块共享内存空间，用于属性服务</span></span><br><span class="line">signal_handler_init();<span class="comment">//初始化子进程退出信号处理</span></span><br><span class="line">property_load_boot_defaults();<span class="comment">//加载default.prop文件</span></span><br><span class="line">start_property_service();<span class="comment">//启动属性服务器器(通过socket通信)</span></span><br><span class="line">init_parse_config_file(<span class="string">"/init.rc"</span>);</span><br><span class="line"><span class="comment">//执行rc文件中触发器on early_init 语句</span></span><br><span class="line">action_for_each_trigger(<span class="string">"early-init"</span>,action_add_queue_tail);</span><br><span class="line"><span class="comment">//等待设备初始化完成</span></span><br><span class="line">queue_buildin_aciton(wait_for_coldboot_done_action,<span class="string">"wit_for_coldboot_done"</span>);</span><br><span class="line">queue_builtin_action(mix_hwrng_into_linux_rng_action, <span class="string">"mix_hwrng_into_linux_rng"</span>);</span><br><span class="line"><span class="comment">//设备组合键的初始化操作</span></span><br><span class="line">queue_builtin_aciton(keychord_init_aciton,<span class="string">"keychord_init"</span>);</span><br><span class="line"><span class="comment">//屏幕上像是Android静态logo</span></span><br><span class="line">queue_builtin_action(console_init_action,<span class="string">"console_init"</span>);</span><br><span class="line"><span class="comment">//执行rc文件触发器on init 语句</span></span><br><span class="line">action_for_each_trigger(<span class="string">"init"</span>,action_add_queue_tail);</span><br><span class="line">queue_builtin_action(mix_hwrng_into_linux_rng_action,<span class="string">"mix_hwrng_info_linux_rng_action"</span>);</span><br><span class="line"><span class="keyword">char</span> bootmode[PROP_VALUE_MAX];</span><br><span class="line"><span class="comment">//当处于充电模式，则charger加入执行队列；否则late-init加入队列。</span></span><br><span class="line"><span class="keyword">if</span>(property_get(<span class="string">"ro.bootmode"</span>,bootmode)&gt;<span class="number">0</span>&amp;&amp;<span class="built_in">strcmp</span>(bootmode,<span class="string">"charger"</span>))&#123;</span><br><span class="line">action_for_each_trigger(<span class="string">"charger"</span>,action_add_queue_tail);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">action_for_each_trigger(<span class="string">"late-init"</span>,action_add_queue_tail);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//触发器为属性是否设置</span></span><br><span class="line"> queue_builtin_action(queue_property_triggers_action, <span class="string">"queue_property_triggers"</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!waiting_for_exec)&#123;</span><br><span class="line">execute_one_command();</span><br><span class="line">restart_processes();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> timeout=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(process_needs_restart)&#123;</span><br><span class="line">timeout=(process_needs_restart-gettime())*<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">if</span>(timeout&lt;<span class="number">0</span>)</span><br><span class="line">timeout=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!action_queue_empty()|| cur_action)&#123;</span><br><span class="line">timeout=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">epoll_event ev;</span><br><span class="line"><span class="comment">//循环 等待事件发生</span></span><br><span class="line"><span class="keyword">int</span> nr =TEMP_FAILURE_RETRY(epoll_wait(epoll_fd,&amp;ev,<span class="number">1</span>,timeout));</span><br><span class="line"><span class="keyword">if</span>(nr==<span class="number">-1</span>)&#123;</span><br><span class="line">ERROR(<span class="string">"epoll_wait failed:%s\n"</span>,strerror(errno));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(nr==<span class="number">1</span>)&#123;</span><br><span class="line">((<span class="keyword">void</span> (*)())ev.data.ptr)();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-log系统"><a href="#1-2-log系统" class="headerlink" title="1.2 log系统"></a>1.2 log系统</h2><p>此时android的log系统还没有启动，采用kernel的log系统，打开设备节点<code>/dev/kmsg</code>，那么可通过<code>cat /dev/kmsg</code>来获取内核Log.</p><p>设置log的输出级别为<code>KLOG_NOTICE_LEVEL(5)</code>，当log级别小于5时则会输出到kernel log， 默认值为3.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define KLOG_ERROR_LEVEL 3</span><br><span class="line">#define KLOG_WARNING_LEVEL 4</span><br><span class="line">#define KLOG_NOTICE_LEVEL 5</span><br><span class="line">#define KLOG_INFO_LEVEL 6</span><br><span class="line">#define KLOG_DEBUG_LEVEL 7</span><br><span class="line">#define KLOG_DEFAULT_LEVEL 3 //默认为3</span><br></pre></td></tr></table></figure><h2 id="1-3-console-init-action"><a href="#1-3-console-init-action" class="headerlink" title="1.3 console_init_action"></a>1.3 console_init_action</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//init.cpp</span><br><span class="line">static int console_init_action(int nargs,char** args)&#123;</span><br><span class="line">char console[PROP_VALUE_MAX];</span><br><span class="line">if(property_get(&quot;ro.boot.console&quot;,console)&gt;0)&#123;</span><br><span class="line">snprintf(console_name,sizeof(console_name),&quot;/dev/%s&quot;,console);</span><br><span class="line">&#125;</span><br><span class="line">int fd = open(console_name, O_RDWR | O_CLOEXEC);</span><br><span class="line">    if (fd &gt;= 0)</span><br><span class="line">        have_console = 1;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    fd = open(&quot;/dev/tty0&quot;, O_WRONLY | O_CLOEXEC);</span><br><span class="line">    if (fd &gt;= 0) &#123;</span><br><span class="line">        const char *msg;</span><br><span class="line">            msg = &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;  // console is 40 cols x 30 lines</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot; A N D R O I D &quot;;</span><br><span class="line">        write(fd, msg, strlen(msg));</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这便是开机显示的底部带ANDROID字样的画面。</p><h2 id="1-4-restart-processes"><a href="#1-4-restart-processes" class="headerlink" title="1.4 restart_processes"></a>1.4 restart_processes</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//init.cpp</span><br><span class="line">static void restart_processes()&#123;</span><br><span class="line">process_need_restart=0;</span><br><span class="line">service_for_each_flags(SVC_RESTARTING,restart_service_if_needed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查service_list中的所有服务，对于带有<code>SVC_RESTARTING</code>标志的服务，则都会调用其相应的<code>restart_service_if_needed</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型内核链表</span></span><br><span class="line">void service_for_each_flags(unsigned matchFlags,void(*func)(struct service *svc))&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listnode</span>*<span class="title">node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">service</span>*<span class="title">svc</span>;</span></span><br><span class="line">list_for_each(node,&amp;serivce_list)&#123;</span><br><span class="line">svc=node_to_item(node,struct service,slist);</span><br><span class="line"><span class="keyword">if</span>(svc-&gt;flags&amp;matchflags)</span><br><span class="line">func(svc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restart_service_if_needed</span><span class="params">(struct service*svc)</span></span>&#123;</span><br><span class="line"><span class="keyword">time_t</span> next_start_time =svc-&gt;time_started+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span>(next_start_time&lt;=gettime())&#123;</span><br><span class="line">svc-&gt;flags&amp;=(~SVC_RESTARTING);</span><br><span class="line">service_start(svc,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> ((next_start_time &lt; process_needs_restart) ||</span><br><span class="line">    (process_needs_restart == <span class="number">0</span>)) &#123;</span><br><span class="line">    process_needs_restart = next_start_time;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-信号处理"><a href="#2-信号处理" class="headerlink" title="2.信号处理"></a>2.信号处理</h1><p>通过<code>signal_handler_init()</code>来初始化信号处理过程.主要工作：</p><ul><li>1.初始化signal句柄</li><li>2.循环处理子进程</li><li>3.注册epoll句柄</li><li>4.处理子进程终止</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void signal_handler_init()&#123;</span><br><span class="line">int s[2];</span><br><span class="line">//创建socketpar</span><br><span class="line">socketpair(AF_UNIX,SOCK_STREAM|SOCK_NONBLOCK|SOCK_CLOEXEC,0,s);</span><br><span class="line">signal_write_fd=s[0];</span><br><span class="line">sinal_read_fd=s[1];</span><br><span class="line">//当捕获信息SIGCHLD,则写入signal_write_fd</span><br><span class="line">struct sigaciton act;</span><br><span class="line">act.sa_handler=SIGCHLD_handler;</span><br><span class="line">//SA_NOCLDSTOP使init进程只有在其子进程终止时收到SIGCHLD信号</span><br><span class="line">act.sa_flags=SA_NOCLDSTOP;</span><br><span class="line">sigaction(SIGCHLD,&amp;act,0);</span><br><span class="line">reap_any_outstanding_children();</span><br><span class="line">register_epoll_handler(signal_read_fd,handle_signal);</span><br><span class="line">&#125;</span><br><span class="line">static void SIGCHLD_handler(int)&#123;</span><br><span class="line">//向signal_write_fd写入1，知道成功为止</span><br><span class="line">if(TEMP_FAILURE_RETRY(signal_write_fd,&quot;1&quot;,1)==-1)&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//读取数据</span><br><span class="line">static void handle_signal()&#123;</span><br><span class="line">char buf[32];</span><br><span class="line">//读取signal_read_fd数据，放入buf</span><br><span class="line">read(signal_read_fd,buf,sizeof(buf));</span><br><span class="line">reap_any_outstanding_children();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个进程在处理其他进程发送的signal信号时都需要先注册，当进程的运行状态改变或终止时会产生某种signal信号，<code>init进程</code>是所有用户空间进程的父进程，当其子进程终止时产生<code>SIGCHLD信号</code>，init进程调用信号安装函数<code>sigaction()</code>，传递参数给sigaction结构体，便完成信号处理的过程。</p><h2 id="2-1-reap-any-outstanding-children"><a href="#2-1-reap-any-outstanding-children" class="headerlink" title="2.1 reap_any_outstanding_children"></a>2.1 reap_any_outstanding_children</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//signal_handler.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reap_any_outstanding_children</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(wait_for_one_process())&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> boolean <span class="title">wait_for_one_process</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"><span class="comment">//任意子进程，如果子进程没有退出则返回0，否则返回子进程pid</span></span><br><span class="line"><span class="keyword">pid_t</span> pid=TEMP_FAILURE_RETRY(waitpid(<span class="number">-1</span>,&amp;status,WNOHANG));</span><br><span class="line"><span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">serice* svc=servce_find_by_pid(pid);<span class="comment">//根据pid找到service</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">if</span>(!svc)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//当flag为RESTART不是ONESHORT,先kill进程组内所有子进程或子线程</span></span><br><span class="line"><span class="keyword">if</span>(!(svc-&gt;flags&amp; SVC_ONESHOT)||(svc-&gt;flags &amp; SVC_RESTART))&#123;</span><br><span class="line">kill(-pid,SIGKILL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除当前服务svc中所有创建的socket</span></span><br><span class="line"><span class="keyword">for</span>(socketinfo*si=svc-&gt;sockets;si;si=si-&gt;next)&#123;</span><br><span class="line"><span class="keyword">char</span> tmp[<span class="number">128</span>];</span><br><span class="line"><span class="built_in">snprintf</span>(tmp,<span class="keyword">sizeof</span>(tmp),ANDROID_SOCKET_DI<span class="string">R"/%s"</span>,si-&gt;name);</span><br><span class="line">unlink(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当flags为EXEC时，释放相应的服务</span></span><br><span class="line"><span class="keyword">if</span>(svc-&gt;flags &amp; SVC_EXEC)&#123;</span><br><span class="line">waiting_for_exec=<span class="literal">false</span>;</span><br><span class="line">list_remove(&amp;svc-&gt;slist);</span><br><span class="line"><span class="built_in">free</span>(svc-&gt;name);</span><br><span class="line"><span class="built_in">free</span>(svc-&gt;);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">svc-&gt;pid=<span class="number">0</span>;</span><br><span class="line">svc-&gt;flag&amp;=(~SVC_RUNNING);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于ONESHOT服务，使其进入disable状态</span></span><br><span class="line"><span class="keyword">if</span>((svc-&gt;flags&amp;SVC_ONESHOT)&amp;&amp;!(svc-&gt;flags&amp;SVC-&gt;RESTART))&#123;</span><br><span class="line">svc-&gt;flags|=SVC_DISABLED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//禁用和重置服务，都不再自动重启</span></span><br><span class="line"><span class="keyword">if</span>(svc-&gt;flag&amp; (SVC_DISABLE | SVC_RESET))&#123;</span><br><span class="line"><span class="comment">//设置相应的service状态为stopped</span></span><br><span class="line">svc-&gt;NotifyStateChange(<span class="string">"stopped"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务4分钟内启动次数超过4次，则重启手机进入recovery模式</span></span><br><span class="line"><span class="keyword">time_t</span> now=gettime();</span><br><span class="line"><span class="keyword">if</span>((svc-&gt;flags&amp;SVC_CRITICAL)&amp;&amp;!(svc-&gt;flags&amp;SVC_RESTART))&#123;</span><br><span class="line"><span class="keyword">if</span>(svc-&gt;time_crashed+CRITICAL_CRASH_WINDOW&gt;=now)&#123;</span><br><span class="line"><span class="keyword">if</span>(++svc-&gt;nr_crahsed&gt;CRITICAL_CRASH_THRESHOLD)&#123;</span><br><span class="line">android_reboot(ANDROID_RB_RESTART2,<span class="number">0</span>,<span class="string">"recovery"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">svc-&gt;time_crashed=now;</span><br><span class="line">svc-&gt;nr_crashed=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行当前service中所有onrestart命令</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listnode</span>*<span class="title">node</span>;</span></span><br><span class="line">list_for_each(node,&amp;svc-&gt;onrestart,commands)&#123;</span><br><span class="line">command* cmd=node_to_item(node,struct command,clist);</span><br><span class="line">cmd-&gt;func(cmd-&gt;nargs,cmd-&gt;args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置相应的service状态为restarting</span></span><br><span class="line">svc-&gt;NotifyStateChange(<span class="string">"restarting"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外：通过<code>getprop | grep init.svc</code>可查看所有的service运行状态。状态总共分为：<code>running</code>, <code>stopped</code>, <code>restarting</code></p><h2 id="2-2-register-epoll-handler"><a href="#2-2-register-epoll-handler" class="headerlink" title="2.2 register_epoll_handler"></a>2.2 register_epoll_handler</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//signal_handler.cpp</span></span><br><span class="line">void register_epoll_handler(int fd,void (*fn)())&#123;</span><br><span class="line">epoll_event ev;</span><br><span class="line">ev.events=EPOLLIN;</span><br><span class="line">ev.data.ptr=reinterrupt_cast&lt;<span class="keyword">void</span>*&gt;(fn);</span><br><span class="line"><span class="comment">//将fd可读事件加入到epoll_fd监听队列中</span></span><br><span class="line"><span class="keyword">if</span>(epoll_fd(epoll_fd,EPOLL_CTL_ADD,fd,&amp;ev)==<span class="number">-1</span>)&#123;</span><br><span class="line">ERROR(<span class="string">"epoll_ctl failed %s\n"</span>,strerror(errno));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-服务重启"><a href="#2-3-服务重启" class="headerlink" title="2.3 服务重启"></a>2.3 服务重启</h2><p><img src="/2016/09/30/init进程/init_oneshot.jpg" alt="服务重启流程"></p><p>当init子进程退出时，会产生SIGCHLD信号，并发送给init进程，通过socket套接字传递数据，调用到<code>wait_for_one_process()</code>方法，根据是否是<code>oneshot</code>，来决定是重启子进程，还是放弃启动。<br>所有的Service里面只有<code>servicemanager</code> ，<code>zygote</code> ，<code>surfaceflinger</code>这3个服务有onrestart关键字来触发其他service启动过程。</p><ul><li><code>zygote</code>：触发<code>media</code>、<code>netd</code>以及子进程(包括system_server进程)重启；</li><li><code>system_server</code>: 触发<code>zygote</code>重启;</li><li><code>surfaceflinger</code>：触发zygote重启;</li><li><code>servicemanager</code>: 触发<code>zygote</code>、<code>healthd</code>、<code>media</code>、<code>surfaceflinger</code>、<code>drm</code>重启</li></ul><p>所以<code>surfaceflinger</code>,<code>servicemanager</code>,<code>zygote</code>自身以及<code>system_server</code>进程被杀都会触发Zygote重启。</p><h1 id="3-rc文件语法"><a href="#3-rc文件语法" class="headerlink" title="3. rc文件语法"></a>3. rc文件语法</h1><p>rc文件语法是以<strong>行为单位</strong>，以<strong>空格间隔</strong>的语法，以<code>#</code>开始代表注释行。rc文件主要包含<code>Action</code>、<code>Service</code>、<code>Command</code>、<code>Options</code>，其中对于<code>Action</code>和<code>Service</code>的名称都是唯一的，<strong>对于重复的命名视为无效</strong>。</p><h2 id="3-1-Action"><a href="#3-1-Action" class="headerlink" title="3.1 Action"></a>3.1 Action</h2><p>Action： 通过<code>trigger</code>，即以<code>on</code>开头的语句，决定何时执行相应的service。<code>action_for_each_trigger(&quot;early-boot&quot;, action_add_queue_tail);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">on property:vold.decrypt=trigger_reset_main</span><br><span class="line">    class_reset main</span><br></pre></td></tr></table></figure><ul><li><code>on early-init</code>:在初始化早期阶段触发；</li><li><code>on init</code>:在初始化阶段触发；</li><li><code>on late-init</code>:在初始化晚期阶段触发；</li><li><code>on boot/charger</code>： 当系统启动/充电时触发，还包含其他情况，此处不一一列举；</li><li><code>on property:&lt;key&gt;=&lt;value&gt;</code>: 当属性值满足条件时触发；</li></ul><h2 id="3-2-Service"><a href="#3-2-Service" class="headerlink" title="3.2 Service"></a>3.2 Service</h2><p>服务Service，以<code>service</code>开头，由init进程启动，一般运行于另外一个<code>init的子进程</code>，所以启动service前<strong>需要判断对应的可执行文件是否存在</strong>。init生成的子进程，定义在rc文件，其中每一个service，在启动时会通过<code>fork方式</code>生成子进程。</p><p>例如： <code>service servicemanager /system/bin/servicemanager</code>代表的是服务名为<code>servicemanager</code>，服务的路径，也就是服务执行操作时运行<code>/system/bin/servicemanager</code>。</p><h2 id="3-3-Command"><a href="#3-3-Command" class="headerlink" title="3.3 Command"></a>3.3 Command</h2><ul><li><code>class_start &lt;service_class_name&gt;</code>： 启动属于同一个class的所有服务；</li><li><code>start &lt;service_name&gt;</code>： 启动指定的服务，若已启动则跳过；</li><li><code>stop &lt;service_name&gt;</code>： 停止正在运行的服务</li><li><code>setprop &lt;name&gt; &lt;value&gt;</code>：设置属性值</li><li><code>mkdir &lt;path&gt;</code>：创建指定目录</li><li><code>symlink &lt;target&gt; &lt;sym_link&gt;</code>： 创建连接到<code>&lt;target&gt;</code>的<code>&lt;sym_link&gt;</code>符号链接；</li><li><code>write &lt;path&gt; &lt;string&gt;</code>： 向文件path中写入字符串；</li><li><code>exec</code>： fork并执行，会阻塞init进程直到程序完毕；</li><li><code>exprot &lt;name&gt; &lt;name&gt;</code>：设定环境变量；</li><li><code>loglevel &lt;level&gt;</code>：设置log级别</li></ul><h2 id="3-4Options"><a href="#3-4Options" class="headerlink" title="3.4Options"></a>3.4Options</h2><p><code>Options</code>是<code>Services</code>的可选项，与service配合使用</p><ul><li><code>disabled</code>: 不随class自动启动，只有根据service名才启动；</li><li><code>oneshot</code>: service退出后不再重启；</li><li><code>user/group</code>： 设置执行服务的<code>用户/用户组</code>，默认都是<code>root</code>；</li><li><code>class</code>：设置所属的类名，当所属类启动/退出时，服务也<code>启动/停止</code>，默认为default；</li><li><code>onrestart</code>:当服务重启时执行相应命令；</li><li><code>socket</code>: 创建名为<code>/dev/socket/&lt;name&gt;</code>的socket</li><li><code>critical</code>: 在规定时间内该service不断重启，则系统会重启并进入恢复模式</li></ul><p><strong>default</strong>: 意味着<code>disabled=false</code>，<code>oneshot=false</code>，<code>critical=false</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h1&gt;&lt;p&gt;&lt;code&gt;init进程&lt;/code&gt;是Linux系统用户空间第一个进程，进程号为1.改进程功能分为4部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.分析和运行所有&lt;code&gt;init.rc&lt;/code&gt;文件.&lt;/li&gt;
&lt;li&gt;2.生成设备驱动节点（通过rc文件创建）&lt;/li&gt;
&lt;li&gt;3.处理子进程的终止(signal方式)&lt;/li&gt;
&lt;li&gt;4.提供属性服务&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android进程" scheme="http://yoursite.com/tags/Android%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>LinuxIO复用</title>
    <link href="http://yoursite.com/2016/03/01/LinuxIO%E5%A4%8D%E7%94%A8/"/>
    <id>http://yoursite.com/2016/03/01/LinuxIO复用/</id>
    <published>2016-02-29T16:53:03.000Z</published>
    <updated>2019-02-02T11:21:31.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-IO复用简介"><a href="#1-IO复用简介" class="headerlink" title="1.IO复用简介"></a>1.IO复用简介</h1><p>I/O 多路复用技术是为了解决进程或线程阻塞到某个 I/O 系统调用而出现的技术，使进程不阻塞于某个特定的 I/O 系统调用。</p><p><code>select()</code>，<code>poll()</code>，<code>epoll()</code>都是I/O多路复用的机制。I/O多路复用通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪，就是这个文件描述符进行读写操作之前），能够通知程序进行相应的读写操作。但<code>select()</code>，<code>poll()</code>，<code>epoll()</code>本质上都是<strong>同步I/O</strong>，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而<code>异步I/O</code>则无需自己负责进行读写，<code>异步I/O</code>的实现会负责把数据从内核拷贝到用户空间。<br>与多线程和多进程相比，<code>I/O 多路复用</code>的最大优势是系统开销小，系统不需要建立新的进程或者线程，也不必维护这些线程和进程。</p><a id="more"></a><h1 id="2-select"><a href="#2-select" class="headerlink" title="2.select"></a>2.select</h1><h2 id="2-1-api说明"><a href="#2-1-api说明" class="headerlink" title="2.1 api说明"></a>2.1 api说明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>监视并等待多个文件描述符的属性变化（<code>可读</code>、<code>可写</code>或<code>错误异常</code>）。<code>select()</code>函数监视的文件描述符分 3 类，分别是<code>writefds</code>、<code>readfds</code>、和 <code>exceptfds</code>。调用后 <code>select()</code>函数会阻塞，直到有描述符就绪（有数据可读、可写、或者有错误异常），或者超时（ timeout 指定等待时间），函数才返回。当<code>select()</code>函数返回后，可以通过遍历 <code>fdset</code>，来找到就绪的描述符。</p><ul><li><code>nfds</code>: 要监视的文件描述符的范围，一般取监视的描述符数的最大值+1，如这里写 10， 这样的话，描述符 0，1, 2 …… 9 都会被监视，在 Linux 上最大值一般为1024。</li><li><code>readfd</code>: 监视的可读描述符集合，只要有文件描述符即将进行读操作，这个文件描述符就存储到这。</li><li><code>writefds</code>: 监视的可写描述符集合。</li><li><code>exceptfds</code>: 监视的错误异常描述符集合</li></ul><p>中间的三个参数 readfds、writefds 和 exceptfds 指定我们要让内核监测读、写和异常条件的描述字。如果不需要使用某一个的条件，就可以把它设为空指针（ NULL ）。集合fd_set 中存放的是文件描述符，可通过以下四个宏进行设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////清空集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>; </span><br><span class="line"><span class="comment">//将一个给定的文件描述符加入集合之中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</span><br><span class="line"><span class="comment">//将一个给定的文件描述符从集合中删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</span><br><span class="line"><span class="comment">// 检查集合中指定的文件描述符是否可以读写 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>timeout</code>: 超时时间，它告知内核等待所指定描述字中的任何一个就绪可花多少时间。其 timeval 结构用于指定这段时间的秒数和微秒数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line"><span class="keyword">time_t</span> tv_sec;<span class="comment">//秒</span></span><br><span class="line"><span class="keyword">suseconds_t</span> tv_usec;<span class="comment">//微秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个参数有三种可能：</p><ul><li><code>永远等待下去</code>：仅在有一个描述字准备好<code>I/O</code>时才返回。为此，把该参数设置为空指针 <code>NULL</code>。</li><li><code>等待固定时间</code>：在指定的固定时间（ timeval 结构中指定的秒数和微秒数）内，在有一个描述字准备好<code>I/O</code>时返回，如果时间到了，就算没有文件描述符发生变化，这个函数会返回 0。</li><li><code>根本不等待（不阻塞)</code>:检查描述字后立即返回，这称为轮询。为此，<code>struct timeval</code>变量的时间值指定为 0 秒 0 微秒，文件描述符属性无变化返回 0，有变化返回准备好的描述符数量。</li></ul><p>返回值：</p><ul><li><code>成功</code>：就绪描述符的数目，超时返回 0，</li><li><code>出错</code>：-1</li></ul><h2 id="2-3-示例"><a href="#2-3-示例" class="headerlink" title="2.3 示例"></a>2.3 示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int mian(void)&#123;</span><br><span class="line">fd_set rfds;</span><br><span class="line">struct timeval tv;</span><br><span class="line">int retval;</span><br><span class="line">//监控标准输入stdin(0),看什么时候输入</span><br><span class="line">FD_ZERO(&amp;rfds);</span><br><span class="line">FD_SET(0,&amp;rfds);</span><br><span class="line">//等待5s</span><br><span class="line">tv.tv_sec=5;</span><br><span class="line">tv.tv_usec=0;</span><br><span class="line">retval=select(1,&amp;rfds,NULL,NULL,NULL,&amp;tv);</span><br><span class="line">//现在不用依赖tv的值了</span><br><span class="line">if(retval==-1)&#123;</span><br><span class="line">perror(&quot;select()&quot;);</span><br><span class="line">&#125;else if(retval)&#123;</span><br><span class="line">printf(&quot;Data is available now \n&quot;);</span><br><span class="line">//FD_ISSET(0,&amp;rfds)的值为true</span><br><span class="line">&#125;else&#123;</span><br><span class="line">printf(&quot;No data within five seconds&quot;);</span><br><span class="line">&#125;</span><br><span class="line">exit(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-缺点"><a href="#2-4-缺点" class="headerlink" title="2.4 缺点"></a>2.4 缺点</h2><p>1）每次调用<code>select()</code>，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大，同时每次调用<code>select()</code>都需要在内核遍历传递进来的<code>所有fd</code>，这个开销在fd很多时也很大。</p><p>2）单个进程能够监视的文件描述符的数量存在最大限制，在 Linux 上一般为 1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p><h1 id="3-poll"><a href="#3-poll" class="headerlink" title="3.poll"></a>3.poll</h1><h2 id="3-1-api说明"><a href="#3-1-api说明" class="headerlink" title="3.1 api说明"></a>3.1 api说明</h2><p><code>select()</code>和<code>poll()</code>系统调用的本质一样，前者在 BSD UNIX 中引入的，后者在 System V 中引入的。<code>poll()</code>的机制与<code>select()</code>类似，与<code>select()</code>在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是<code>poll()</code><strong>没有最大文件描述符数量的限</strong>（但是数量过大后性能也是会下降）。<code>poll()</code>和<code>select()</code>同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;poll.h&gt;</span><br><span class="line">int poll(struct pollfd *fds,nfds_t nfds,int timeout);</span><br></pre></td></tr></table></figure><p>监视并等待多个文件描述符的属性变化。</p><ul><li>1.<code>fds</code>: 不同与<code>select()</code>使用三个位图来表示三个fdset的方式，<code>poll()</code>使用一个 <code>pollfd的指针</code>实现。一个pollfd结构体数组，其中包括了你想测试的<code>文件描述符</code>和<code>事件</code>, <strong>事件由结构中事件域events来确定</strong>，<strong>调用后实际发生的时间将被填写在结构体的 revents域</strong>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> fd;<span class="comment">//文件描述符</span></span><br><span class="line"><span class="keyword">short</span> events;<span class="comment">//等待的事件</span></span><br><span class="line"><span class="keyword">short</span> reevents;<span class="comment">//实际发生了的事件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>fd</code>：每一个<code>pollfd</code>结构体指定了一个被监视的文件描述符，可以传递多个结构体，指示 <code>poll()</code>监视多个文件描述符。</p></li><li><p><code>events</code>：每个结构体的events域是监视该文件描述符的事件掩码，由用户来设置这个域。events 等待事件的掩码取值如下：</p><ul><li>处理输入：<ul><li><code>POLLIN</code>普通或优先级带数据可读</li><li><code>POLLRDNORM</code> 普通数据可读</li><li><code>POLLRDBAND</code> 优先级带数据可读</li><li><code>POLLPRI</code> 高优先级数据可读</li></ul></li><li>处理输出<ul><li><code>POLLOUT</code>普通或优先级带数据可写</li><li><code>POLLWRNORM</code>普通数据可写</li><li><code>POLLWRBAND</code>优先级带数据可写</li></ul></li><li>处理错误<ul><li><code>POLLERR</code>发生错误</li><li><code>POLLHUP</code>发生挂起</li><li><code>POLLVAL</code>描述字不是一个打开的文件</li></ul></li></ul></li></ul><p><code>poll()</code>处理三个级别的数据，普通 normal，优先级带<code>priority band</code>，高优先级<code>high priority</code>，这些都是出于流的实现。</p><p><code>POLLIN | POLLPRI</code>等价于<code>select()</code>的读事件,<code>POLLOUT | POLLWRBAND</code>等价于 select() 的写事件。<code>POLLIN</code>等价于 <code>POLLRDNORM | POLLRDBAND</code>，而<code>POLLOUT</code> 则等价于<code>POLLWRNORM</code>。例如，要同时监视一个文件描述符是否可读和可写，我们可以设置events为<code>POLLIN | POLLOUT</code>。</p><ul><li><code>revents</code>：revents域是文件描述符的操作<code>结果事件掩码</code>，内核在调用返回时设置这个域。events 域中请求的任何事件都可能在 revents域中返回。</li></ul><p>每个结构体的 events 域是由用户来设置，告诉内核我们关注的是什么，而 revents 域是返回时内核设置的，以说明对该描述符发生了什么事件。</p><ul><li>2.<code>nfds</code>: 用来指定第一个参数数组元素个数。</li><li>3.<code>timeout</code>: 指定等待的毫秒数，无论<code>I/O</code>是否准备好，poll() 都会返回。当等待时间为 0 时，poll() 函数立即返回，为 -1 则使 poll() 一直阻塞直到一个指定事件发生。</li></ul><p><strong>返回值</strong></p><ul><li><code>成功时</code>，<code>poll()</code>返回结构体中revents 域不为 0 的文件描述符个数；如果在超时前没有任何事件发生，poll()返回 0；</li><li><code>失败时</code>，<code>poll()</code>返回 -1，并设置 errno 为下列值之一：<ul><li><code>EBADF</code>：一个或多个结构体中指定的文件描述符无效。</li><li><code>EFAULT</code>：fds 指针指向的地址超出进程的地址空间。</li><li><code>EINTR</code>：请求的事件之前产生一个信号，调用可以重新发起。</li><li><code>EINVAL</code>：nfds 参数超出 PLIMIT_NOFILE值。</li><li><code>ENOMEM</code>：可用内存不足，无法完成请求。</li></ul></li></ul><h2 id="3-2-示例"><a href="#3-2-示例" class="headerlink" title="3.2 示例"></a>3.2 示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;stropts.h&gt;</span><br><span class="line">#include &lt;sys/poll.h&gt;</span><br><span class="line">#include &lt;sys/stropts.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;poll.h&gt;</span><br><span class="line"></span><br><span class="line">#define BUFSIZE 1024</span><br><span class="line">int main(int argc,char* argv[])&#123;</span><br><span class="line">char buf[BUFSIZE];</span><br><span class="line">int bytes,i=0,nummonitor=0,numready,errno;</span><br><span class="line">char * str;</span><br><span class="line">struct pollfd *pollfd;</span><br><span class="line">if(argc!=3)&#123;</span><br><span class="line">fprintf(stderr,&quot;useage:t&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">//struct pollfd分配空间</span><br><span class="line">if((pollfd=(struct pollfd*)calloc(2,sizeof(struct pollfd)))==NULL)&#123;</span><br><span class="line">exit(-1);</span><br><span class="line">&#125;</span><br><span class="line">//初始化struct pollfd结构</span><br><span class="line">for(i;i&lt;2;i++)&#123;</span><br><span class="line"> str = (char*)malloc(14*sizeof(char));        </span><br><span class="line">        memcpy(str,&quot;/root/pro/&quot;,14);</span><br><span class="line">        strcat(str,argv[i+1]);</span><br><span class="line">        printf(&quot;str=%s\n&quot;,str);</span><br><span class="line">        (pollfd+i)-&gt;fd = open(str,O_RDONLY);</span><br><span class="line">        if((pollfd+i)-&gt;fd &gt;= 0)</span><br><span class="line">        fprintf(stderr, &quot;open (pollfd+%d)-&gt;fd:%s\n&quot;, i, argv[i+1]);</span><br><span class="line">        nummonitor++;</span><br><span class="line">        (pollfd+i)-&gt;events = POLLIN;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;nummonitor=%d\n&quot;,nummonitor);</span><br><span class="line">while(nummonitor &gt; 0)&#123;</span><br><span class="line">        numready = poll(pollfd, 2, -1);</span><br><span class="line">        //被信号中断，继续等待</span><br><span class="line">        if ((numready == -1) &amp;&amp; (errno == EINTR))</span><br><span class="line">            continue;        </span><br><span class="line">        else if (numready == -1)//poll真正错误，退出</span><br><span class="line">            break; </span><br><span class="line">        printf(&quot;numready=%d\n&quot;,numready);</span><br><span class="line">        for (i=0;nummonitor&gt;0 &amp;&amp; numready&gt;0; i++)</span><br><span class="line">        &#123;</span><br><span class="line">        //返回内核做判断</span><br><span class="line">            if((pollfd+i)-&gt;revents &amp; POLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                bytes = read(pollfd[i].fd, buf, BUFSIZE);</span><br><span class="line">                numready--;</span><br><span class="line">                printf(&quot;pollfd[%d]-&gt;fd read buf:\n%s \n&quot;, i, buf);</span><br><span class="line">                nummonitor--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0; i&lt;nummonitor; i++)</span><br><span class="line">        close(pollfd[i].fd);</span><br><span class="line">    free(pollfd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-缺点"><a href="#3-3-缺点" class="headerlink" title="3.3 缺点"></a>3.3 缺点</h2><p><code>poll()</code>的实现和<code>select()</code>非常相似，只是描述<code>fd集合</code>的方式不同，<code>poll()</code>使用 <code>pollfd</code>结构而不是<code>select()</code>的<code>fd_set</code> 结构，其他的都差不多。</p><h1 id="4-epoll"><a href="#4-epoll" class="headerlink" title="4.epoll"></a>4.epoll</h1><h2 id="4-1-api说明"><a href="#4-1-api说明" class="headerlink" title="4.1 api说明"></a>4.1 api说明</h2><p>epoll是在 2.6 内核中提出的，是之前的 <code>select()</code>和<code>poll()</code>的增强版本。相对于 <code>select()</code>和<code>poll()</code>来说，epoll更加灵活，<strong>没有描述符限制</strong>。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在<strong>用户空间和内核空间的copy只需一次</strong>。</p><p>epoll 操作过程需要三个接口，分别如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_create(int size);</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure></p><h3 id="int-epoll-create-int-size"><a href="#int-epoll-create-int-size" class="headerlink" title="int epoll_create(int size)"></a><code>int epoll_create(int size)</code></h3><p>该函数生成一个 epoll 专用的文件描述符（创建一个 epoll 的句柄）。</p><ul><li>size: 用来告诉内核这个监听的数目一共有多大，参数 size 并不是限制了 epoll 所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。自从 linux 2.6.8 之后，<strong>size 参数是被忽略的</strong>，也就是说可以填只有大于 0 的任意值。需要注意的是，当创建好 epoll 句柄后，它就是会占用一个 fd 值，在 linux 下如果查看 <code>/proc/</code> 进程 <code>id/fd/</code>，是能够看到这个 fd 的，所以在使用完 epoll 后，必须调用<code>close()</code>关闭，否则可能导致fd被耗尽。</li></ul><p>返回值</p><ul><li><code>成功</code>：epoll 专用的文件描述符</li><li><code>失败</code>：-1</li></ul><h3 id="int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event"><a href="#int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event" class="headerlink" title="int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);"></a><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code></h3><p>epoll的事件注册函数，它不同于<code>select()</code> 是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。</p><ul><li><code>epfd</code>: epoll专用的文件描述符，<code>epoll_create()</code>的返回值</li><li><code>op</code>: 表示动作，用三个宏来表示：<ul><li><code>EPOLL_CTL_ADD</code>：注册新的 fd 到 epfd 中；</li><li><code>EPOLL_CTL_MOD</code>：修改已经注册的fd的监听事件；</li><li><code>EPOLL_CTL_DEL</code>：从 epfd 中删除一个 fd；</li></ul></li><li><code>fd</code>: 需要监听的文件描述符</li><li><code>event</code>: 告诉内核要监听什么事件，struct epoll_event 结构如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//保存触发事件某个文件描述符相关数据</span><br><span class="line">typdef union epoll_data&#123;</span><br><span class="line">void*ptr;</span><br><span class="line">int  fd;</span><br><span class="line">__uint32_t u32;</span><br><span class="line">__uint64_t u64;</span><br><span class="line">&#125;epoll_data_t;</span><br><span class="line">//感兴趣的事件和被触发的事件</span><br><span class="line">struct epoll_event&#123;</span><br><span class="line">__uint32_t events;</span><br><span class="line">epoll_data_t data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>events 可以是以下几个宏的集合：</p><ul><li><code>EPOLLIN</code>：表示对应的文件描述符可以读（包括对端 SOCKET 正常关闭）；</li><li><code>EPOLLOUT</code>：表示对应的文件描述符可以写；</li><li><code>EPOLLPRI</code>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li><li><code>EPOLLERR</code>：表示对应的文件描述符发生错误；</li><li><code>EPOLLHUP</code>：表示对应的文件描述符被挂断；</li><li><code>EPOLLET</code>：将 EPOLL 设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</li><li><code>EPOLLONESHOT</code>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 socket 的话，需要再次把这个 socket 加入到 EPOLL 队列里</li></ul><p>返回值：</p><ul><li><code>成功</code>：0</li><li><code>失败</code>：-1</li></ul><h3 id="int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout"><a href="#int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout" class="headerlink" title="int epoll_wait( int epfd, struct epoll_event * events, int maxevents, int timeout );"></a><code>int epoll_wait( int epfd, struct epoll_event * events, int maxevents, int timeout );</code></h3><p>等待事件的产生，收集在epoll监控的事件中已经发送的事件，类似于<code>select()</code>调用。</p><ul><li><code>epfd</code>:epoll 专用的文件描述符，epoll_create()的返回值</li><li><code>events</code>: 分配好的epoll_event结构体数组，epoll 将会把发生的事件赋值到events 数组中（events 不可以是空指针，内核只负责把数据复制到这个 events 数组中，不会去帮助我们在用户态中分配内存）。</li><li><code>maxevents</code>: maxevents告知内核这个 events 有多大 。</li><li><code>timeout</code>: 超时时间，单位为毫秒，为 -1 时，函数为阻塞</li></ul><p>返回值：</p><ul><li><code>成功</code>：返回需要处理的事件数目，如返回 0 表示已超时。</li><li><code>失败</code>：-1</li></ul><p>epoll对文件描述符的操作有两种模式：<strong>LT（level trigger)</strong>和<strong>ET（edge trigger)</strong>。LT模式是默认模式，LT模式与 ET 模式的区别如下：</p><ul><li><code>LT 模式</code>：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 epoll_wait 时，会再次响应应用程序并通知此事件。</li><li><code>ET 模式</code>：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此事件。</li></ul><p><code>ET 模式</code>在很大程度上减少了 epoll 事件被<strong>重复触发</strong>的次数，因此效率要比<code>LT 模式高</code>。epoll 工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h2 id="4-2-示例"><a href="#4-2-示例" class="headerlink" title="4.2 示例"></a>4.2 示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_events</span> <span class="title">ev</span>,<span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line"><span class="keyword">int</span> listen_sock,conn_sock,nfds,epollfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立socket监听</span></span><br><span class="line"><span class="comment">//socket(),bind(),listen()</span></span><br><span class="line">epollfd=epoll_create(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(epoll_fd==<span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"epll_create"</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">ev.events=EPOLLIN;</span><br><span class="line">ev.data.fd=listen_sock;</span><br><span class="line"><span class="comment">//注册描述符添加自己数据</span></span><br><span class="line"><span class="keyword">if</span>(epoll_ctl(epollfd,EPOLL_CTL_ADD,listen_sock,&amp;ev)==<span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"epoll_ctl:listen_sock"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">nfds=epoll_wait(epollfd,events,MAX_EVENTS,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(nfds==<span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"epoll_wait"</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;nfds;++n)&#123;</span><br><span class="line"><span class="keyword">if</span>(events[n].data.fd==listen_sock)&#123;</span><br><span class="line">conn_sock=accept(listen_sock,(struct sockaddr *) &amp;local, &amp;addrlen);</span><br><span class="line"><span class="keyword">if</span>(conn_sock==<span class="number">-1</span>)&#123;</span><br><span class="line">(struct sockaddr *) &amp;local, &amp;addrlen</span><br><span class="line">&#125;</span><br><span class="line">setnonblocking(conn_sock);</span><br><span class="line">ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">ev.data.fd=conn_sock;</span><br><span class="line"><span class="keyword">if</span>(epoll_ctl(epollfd,EPOLL_CTL_ADD,conn_sock,&amp;ev)==<span class="number">-1</span>)&#123;</span><br><span class="line"> perror(<span class="string">"epoll_ctl: conn_sock"</span>);</span><br><span class="line">                 <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  do_use_fd(events[n].data.fd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>select/poll</code>中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而<code>epoll()</code>事先通过<code>epoll_ctl()</code>来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似<code>callback</code>的回调机制(软件中断)，迅速激活这个文件描述符，当进程调用<code>epoll_wait()</code>时便得到通知。</p><h2 id="4-3-优点"><a href="#4-3-优点" class="headerlink" title="4.3 优点"></a>4.3 优点</h2><p>1）监视的描述符数量不受限制，它所支持的FD 上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在 1GB 内存的机器上大约是 10 万左右，具体数目可以<code>cat /proc/sys/fs/file-max</code>察看,一般来说这个数目和系统内存关系很大。<code>select()</code>的最大缺点就是进程打开的 fd 是有数量限制的。这对于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache 就是这样实现的)，不过虽然 Linux 上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</p><p>2）I/O 的效率不会随着监视 fd 的数量的增长而下降。<code>select()</code>，<code>poll()</code> 实现需要自己不断轮询所有 fd 集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而 epoll 其实也需要调用<code>epoll_wait()</code>不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪 fd 放入就绪链表中，并唤醒在<code>epoll_wait()</code>中进入睡眠的进程。虽然都要睡眠和交替，但是<code>select()</code>和 <code>poll()</code>在“醒着”的时候要遍历整个 fd 集合，而 epoll 在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的 CPU 时间。这就是回调机制带来的性能提升。<br>3）<code>select()</code>，<code>poll()</code>每次调用都要把 fd 集合从用户态往内核态拷贝一次，而 epoll 只要一次拷贝，这也能节省不少的开销。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-IO复用简介&quot;&gt;&lt;a href=&quot;#1-IO复用简介&quot; class=&quot;headerlink&quot; title=&quot;1.IO复用简介&quot;&gt;&lt;/a&gt;1.IO复用简介&lt;/h1&gt;&lt;p&gt;I/O 多路复用技术是为了解决进程或线程阻塞到某个 I/O 系统调用而出现的技术，使进程不阻塞于某个特定的 I/O 系统调用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;select()&lt;/code&gt;，&lt;code&gt;poll()&lt;/code&gt;，&lt;code&gt;epoll()&lt;/code&gt;都是I/O多路复用的机制。I/O多路复用通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪，就是这个文件描述符进行读写操作之前），能够通知程序进行相应的读写操作。但&lt;code&gt;select()&lt;/code&gt;，&lt;code&gt;poll()&lt;/code&gt;，&lt;code&gt;epoll()&lt;/code&gt;本质上都是&lt;strong&gt;同步I/O&lt;/strong&gt;，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而&lt;code&gt;异步I/O&lt;/code&gt;则无需自己负责进行读写，&lt;code&gt;异步I/O&lt;/code&gt;的实现会负责把数据从内核拷贝到用户空间。&lt;br&gt;与多线程和多进程相比，&lt;code&gt;I/O 多路复用&lt;/code&gt;的最大优势是系统开销小，系统不需要建立新的进程或者线程，也不必维护这些线程和进程。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="LinuxAPI" scheme="http://yoursite.com/tags/LinuxAPI/"/>
    
  </entry>
  
</feed>
